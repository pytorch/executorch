/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <executorch/extension/tensor/tensor_ptr_maker.h>

#include <gtest/gtest.h>

#include <executorch/runtime/platform/runtime.h>

using namespace ::executorch::extension;
using namespace ::executorch::runtime;

class TensorPtrMakerTest : public ::testing::Test {
 protected:
  static void SetUpTestSuite() {
    runtime_init();
  }
};

TEST_F(TensorPtrMakerTest, CreateTensorUsingTensorMaker) {
  float data[20] = {2};
  auto tensor =
      for_blob(data, {4, 5})
          .dim_order({0, 1})
          .strides({5, 1})
          .dynamism(executorch::aten::TensorShapeDynamism::DYNAMIC_BOUND)
          .make_tensor_ptr();

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->strides()[0], 5);
  EXPECT_EQ(tensor->strides()[1], 1);
  EXPECT_EQ(tensor->const_data_ptr<float>(), data);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 2);
}

TEST_F(TensorPtrMakerTest, PerfectForwardingLValue) {
  float data[20] = {2};
  std::vector<executorch::aten::SizesType> sizes = {4, 5};
  std::vector<executorch::aten::DimOrderType> dim_order = {0, 1};
  std::vector<executorch::aten::StridesType> strides = {5, 1};

  auto tensor = for_blob(data, sizes)
                    .dim_order(dim_order)
                    .strides(strides)
                    .make_tensor_ptr();

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->strides()[0], 5);
  EXPECT_EQ(tensor->strides()[1], 1);

  EXPECT_EQ(sizes.size(), 2);
  EXPECT_EQ(dim_order.size(), 2);
  EXPECT_EQ(strides.size(), 2);
}

TEST_F(TensorPtrMakerTest, PerfectForwardingRValue) {
  float data[20] = {2};
  std::vector<executorch::aten::SizesType> sizes = {4, 5};
  std::vector<executorch::aten::DimOrderType> dim_order = {0, 1};
  std::vector<executorch::aten::StridesType> strides = {5, 1};

  auto tensor = for_blob(data, std::move(sizes))
                    .dim_order(std::move(dim_order))
                    .strides(std::move(strides))
                    .make_tensor_ptr();

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->strides()[0], 5);
  EXPECT_EQ(tensor->strides()[1], 1);
  // for_blob() moved the contents of the vectors, leaving these empty.
  EXPECT_EQ(sizes.size(), 0); // NOLINT(bugprone-use-after-move)
  EXPECT_EQ(dim_order.size(), 0); // NOLINT(bugprone-use-after-move)
  EXPECT_EQ(strides.size(), 0); // NOLINT(bugprone-use-after-move)
}

TEST_F(TensorPtrMakerTest, CreateTensorFromBlob) {
  float data[20] = {2};
  auto tensor = from_blob(data, {4, 5});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->strides()[0], 5);
  EXPECT_EQ(tensor->strides()[1], 1);
  EXPECT_EQ(tensor->const_data_ptr<float>(), data);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 2);
  EXPECT_EQ(tensor->const_data_ptr<float>()[19], 0);
}

TEST_F(TensorPtrMakerTest, CreateTensorUsingFromBlobWithStrides) {
  float data[20] = {3};
  auto tensor = from_blob(data, {2, 2, 2}, {4, 2, 1});

  EXPECT_EQ(tensor->dim(), 3);
  EXPECT_EQ(tensor->size(0), 2);
  EXPECT_EQ(tensor->size(1), 2);
  EXPECT_EQ(tensor->size(2), 2);
  EXPECT_EQ(tensor->strides()[0], 4);
  EXPECT_EQ(tensor->strides()[1], 2);
  EXPECT_EQ(tensor->strides()[2], 1);
  EXPECT_EQ(tensor->const_data_ptr<float>(), data);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 3);
}

TEST_F(TensorPtrMakerTest, TensorMakerConversionOperator) {
  float data[20] = {2};
  TensorPtr tensor =
      for_blob(data, {4, 5})
          .dynamism(executorch::aten::TensorShapeDynamism::DYNAMIC_BOUND);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
}

TEST_F(TensorPtrMakerTest, CreateTensorWithZeroDimensions) {
  float data[1] = {2};
  auto tensor = from_blob(data, {});

  EXPECT_EQ(tensor->dim(), 0);
  EXPECT_EQ(tensor->numel(), 1);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 2);
}

TEST_F(TensorPtrMakerTest, TensorWithCustomDataDeleter) {
  auto deleter_called = false;
  float* data = new float[20]();
  auto tensor = for_blob(data, {4, 5})
                    .deleter([&deleter_called](void* ptr) {
                      deleter_called = true;
                      delete[] static_cast<float*>(ptr);
                    })
                    .make_tensor_ptr();

  tensor.reset();
  EXPECT_TRUE(deleter_called);
}

TEST_F(TensorPtrMakerTest, TensorManagesMovedVector) {
  auto deleter_called = false;
  std::vector<float> data(20, 3.0f);
  auto* data_ptr = data.data();
  auto tensor = for_blob(data_ptr, {4, 5})
                    .deleter([moved_data = std::move(data), &deleter_called](
                                 void*) mutable { deleter_called = true; })
                    .make_tensor_ptr();

  EXPECT_TRUE(data.empty()); // NOLINT(bugprone-use-after-move)
  EXPECT_EQ(tensor->data_ptr<float>(), data_ptr);

  tensor.reset();
  EXPECT_TRUE(deleter_called);
}

TEST_F(TensorPtrMakerTest, TensorDeleterReleasesCapturedSharedPtr) {
  auto deleter_called = false;
  std::shared_ptr<float[]> data_ptr(
      new float[10], [](float* ptr) { delete[] ptr; });
  auto tensor = from_blob(
      data_ptr.get(),
      {4, 5},
      executorch::aten::ScalarType::Float,
      [data_ptr, &deleter_called](void*) mutable { deleter_called = true; });

  EXPECT_EQ(data_ptr.use_count(), 2);

  tensor.reset();
  EXPECT_TRUE(deleter_called);
  EXPECT_EQ(data_ptr.use_count(), 1);
}

TEST_F(TensorPtrMakerTest, CreateEmpty) {
  auto tensor = empty({4, 5});
  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  auto tensor2 = empty({4, 5}, executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->dim(), 2);
  EXPECT_EQ(tensor2->size(0), 4);
  EXPECT_EQ(tensor2->size(1), 5);
  EXPECT_EQ(tensor2->scalar_type(), executorch::aten::ScalarType::Int);

  auto tensor3 = empty({4, 5}, executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->dim(), 2);
  EXPECT_EQ(tensor3->size(0), 4);
  EXPECT_EQ(tensor3->size(1), 5);
  EXPECT_EQ(tensor3->scalar_type(), executorch::aten::ScalarType::Long);

  auto tensor4 = empty({4, 5}, executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->dim(), 2);
  EXPECT_EQ(tensor4->size(0), 4);
  EXPECT_EQ(tensor4->size(1), 5);
  EXPECT_EQ(tensor4->scalar_type(), executorch::aten::ScalarType::Double);
}

TEST_F(TensorPtrMakerTest, CreateFull) {
  auto tensor = full({4, 5}, 7);
  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 7);

  auto tensor2 = full({4, 5}, 3, executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->dim(), 2);
  EXPECT_EQ(tensor2->size(0), 4);
  EXPECT_EQ(tensor2->size(1), 5);
  EXPECT_EQ(tensor2->scalar_type(), executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->const_data_ptr<int32_t>()[0], 3);

  auto tensor3 = full({4, 5}, 9, executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->dim(), 2);
  EXPECT_EQ(tensor3->size(0), 4);
  EXPECT_EQ(tensor3->size(1), 5);
  EXPECT_EQ(tensor3->scalar_type(), executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->const_data_ptr<int64_t>()[0], 9);

  auto tensor4 = full({4, 5}, 11, executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->dim(), 2);
  EXPECT_EQ(tensor4->size(0), 4);
  EXPECT_EQ(tensor4->size(1), 5);
  EXPECT_EQ(tensor4->scalar_type(), executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->const_data_ptr<double>()[0], 11);

  auto tensor5 = full({4, 5}, 13, executorch::aten::ScalarType::Half);
  EXPECT_EQ(tensor5->dim(), 2);
  EXPECT_EQ(tensor5->size(0), 4);
  EXPECT_EQ(tensor5->size(1), 5);
  EXPECT_EQ(tensor5->scalar_type(), executorch::aten::ScalarType::Half);
  EXPECT_EQ(tensor5->const_data_ptr<executorch::aten::Half>()[0], 13);

  auto tensor6 = full({4, 5}, 15, executorch::aten::ScalarType::BFloat16);
  EXPECT_EQ(tensor6->dim(), 2);
  EXPECT_EQ(tensor6->size(0), 4);
  EXPECT_EQ(tensor6->size(1), 5);
  EXPECT_EQ(tensor6->scalar_type(), executorch::aten::ScalarType::BFloat16);
  EXPECT_EQ(tensor6->const_data_ptr<executorch::aten::BFloat16>()[0], 15);
}

TEST_F(TensorPtrMakerTest, CreateScalar) {
  auto tensor = scalar_tensor(3.14f);

  EXPECT_EQ(tensor->dim(), 0);
  EXPECT_EQ(tensor->numel(), 1);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 3.14f);

  auto tensor2 = scalar_tensor(5, executorch::aten::ScalarType::Int);

  EXPECT_EQ(tensor2->dim(), 0);
  EXPECT_EQ(tensor2->numel(), 1);
  EXPECT_EQ(tensor2->scalar_type(), executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->const_data_ptr<int32_t>()[0], 5);

  auto tensor3 = scalar_tensor(7.0, executorch::aten::ScalarType::Double);

  EXPECT_EQ(tensor3->dim(), 0);
  EXPECT_EQ(tensor3->numel(), 1);
  EXPECT_EQ(tensor3->scalar_type(), executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor3->const_data_ptr<double>()[0], 7.0);
}

TEST_F(TensorPtrMakerTest, CreateOnes) {
  auto tensor = ones({4, 5});
  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 1);

  auto tensor2 = ones({4, 5}, executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->dim(), 2);
  EXPECT_EQ(tensor2->size(0), 4);
  EXPECT_EQ(tensor2->size(1), 5);
  EXPECT_EQ(tensor2->scalar_type(), executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->const_data_ptr<int32_t>()[0], 1);

  auto tensor3 = ones({4, 5}, executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->dim(), 2);
  EXPECT_EQ(tensor3->size(0), 4);
  EXPECT_EQ(tensor3->size(1), 5);
  EXPECT_EQ(tensor3->scalar_type(), executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->const_data_ptr<int64_t>()[0], 1);

  auto tensor4 = ones({4, 5}, executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->dim(), 2);
  EXPECT_EQ(tensor4->size(0), 4);
  EXPECT_EQ(tensor4->size(1), 5);
  EXPECT_EQ(tensor4->scalar_type(), executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->const_data_ptr<double>()[0], 1);
}

TEST_F(TensorPtrMakerTest, CreateZeros) {
  auto tensor = zeros({4, 5});
  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
  EXPECT_EQ(tensor->const_data_ptr<float>()[0], 0);

  auto tensor2 = zeros({4, 5}, executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->dim(), 2);
  EXPECT_EQ(tensor2->size(0), 4);
  EXPECT_EQ(tensor2->size(1), 5);
  EXPECT_EQ(tensor2->scalar_type(), executorch::aten::ScalarType::Int);
  EXPECT_EQ(tensor2->const_data_ptr<int32_t>()[0], 0);

  auto tensor3 = zeros({4, 5}, executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->dim(), 2);
  EXPECT_EQ(tensor3->size(0), 4);
  EXPECT_EQ(tensor3->size(1), 5);
  EXPECT_EQ(tensor3->scalar_type(), executorch::aten::ScalarType::Long);
  EXPECT_EQ(tensor3->const_data_ptr<int64_t>()[0], 0);

  auto tensor4 = zeros({4, 5}, executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->dim(), 2);
  EXPECT_EQ(tensor4->size(0), 4);
  EXPECT_EQ(tensor4->size(1), 5);
  EXPECT_EQ(tensor4->scalar_type(), executorch::aten::ScalarType::Double);
  EXPECT_EQ(tensor4->const_data_ptr<double>()[0], 0);
}

TEST_F(TensorPtrMakerTest, CreateRandTensor) {
  auto tensor = rand({4, 5});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<float>()[i];
    EXPECT_GE(val, 0.0f);
    EXPECT_LT(val, 1.0f);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandTensorWithIntType) {
  auto tensor = rand({4, 5}, executorch::aten::ScalarType::Int);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Int);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<int32_t>()[i];
    EXPECT_EQ(val, 0);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandTensorWithDoubleType) {
  auto tensor = rand({4, 5}, executorch::aten::ScalarType::Double);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Double);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<double>()[i];
    EXPECT_GE(val, 0.0);
    EXPECT_LT(val, 1.0);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandTensorWithHalfType) {
  auto tensor = rand({4, 5}, executorch::aten::ScalarType::Half);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Half);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<executorch::aten::Half>()[i];
    EXPECT_GE(val, 0.0);
    EXPECT_LT(val, 1.0);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandTensorWithBFloatType) {
  auto tensor = rand({4, 5}, executorch::aten::ScalarType::BFloat16);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::BFloat16);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<executorch::aten::BFloat16>()[i];
    EXPECT_GE(val, 0.0);
    EXPECT_LT(val, 1.0);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandnTensor) {
  auto tensor = randn({100, 100});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 100);
  EXPECT_EQ(tensor->size(1), 100);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  auto sum = 0.0f;
  for (auto i = 0; i < tensor->numel(); ++i) {
    sum += tensor->const_data_ptr<float>()[i];
  }
  const auto average = sum / tensor->numel();
  EXPECT_NEAR(average, 0.0f, 1.0f);
}

TEST_F(TensorPtrMakerTest, CreateRandnTensorWithDoubleType) {
  auto tensor = randn({100, 100}, executorch::aten::ScalarType::Double);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 100);
  EXPECT_EQ(tensor->size(1), 100);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Double);

  auto sum = 0.0;
  for (auto i = 0; i < tensor->numel(); ++i) {
    sum += tensor->const_data_ptr<double>()[i];
  }
  const auto average = sum / tensor->numel();
  EXPECT_NEAR(average, 0.0, 1.0);
}

TEST_F(TensorPtrMakerTest, CreateRandIntTensorWithIntType) {
  auto tensor = randint(10, 20, {4, 5}, executorch::aten::ScalarType::Int);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Int);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<int32_t>()[i];
    EXPECT_GE(val, 10);
    EXPECT_LT(val, 20);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandIntTensorWithLongType) {
  auto tensor = randint(10, 20, {4, 5}, executorch::aten::ScalarType::Long);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Long);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<int64_t>()[i];
    EXPECT_GE(val, 10);
    EXPECT_LT(val, 20);
  }
}

TEST_F(TensorPtrMakerTest, CreateRandnTensorWithIntType) {
  auto tensor = rand({4, 5}, executorch::aten::ScalarType::Int);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4);
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Int);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<int32_t>()[i];
    EXPECT_EQ(val, 0);
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithDefaultStartAndStep) {
  auto tensor = arange(5);

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<float>()[i];
    EXPECT_EQ(val, static_cast<float>(i));
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithStartEndStep) {
  auto tensor = arange(2, 10, 2);

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 4); // (10-2)/2 = 4 elements
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<float>()[i];
    EXPECT_EQ(val, static_cast<float>(2 + i * 2));
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithNegativeStep) {
  auto tensor = arange(5, 0, -1);

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<float>()[i];
    EXPECT_EQ(val, static_cast<float>(5 - i));
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithIntType) {
  auto tensor = arange(0, 5, 1, {-1}, executorch::aten::ScalarType::Int);

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Int);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<int32_t>()[i];
    EXPECT_EQ(val, i);
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithLongType) {
  auto tensor = arange(0, 5, 1, {-1}, executorch::aten::ScalarType::Long);

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Long);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<int64_t>()[i];
    EXPECT_EQ(val, static_cast<int64_t>(i));
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithDoubleType) {
  auto tensor =
      arange(0.5, 5.5, 0.5, {-1}, executorch::aten::ScalarType::Double);

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 10); // (5.5-0.5)/0.5 = 10 elements
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Double);

  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<double>()[i];
    EXPECT_DOUBLE_EQ(val, 0.5 + i * 0.5);
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithEmptyRange) {
  // End < start with positive step should error out
  EXPECT_DEATH(
      arange(5, 0, 1), "inferred dimension size must be positive, got 0");
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithValidSizes) {
  // Test arange with compatible sizes
  auto tensor = arange(0, 12, 1, {3, 4});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 3);
  EXPECT_EQ(tensor->size(1), 4);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  // Check values are correct
  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<float>()[i];
    EXPECT_EQ(val, static_cast<float>(i));
  }
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithInferredDimension) {
  // Test arange with -1 dimension that should be inferred
  auto tensor = arange(0, 12, 1, {3, -1});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 3);
  EXPECT_EQ(tensor->size(1), 4); // Should be inferred as 12/3 = 4
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  // Check values are correct
  for (auto i = 0; i < tensor->numel(); ++i) {
    auto val = tensor->const_data_ptr<float>()[i];
    EXPECT_EQ(val, static_cast<float>(i));
  }
}

TEST_F(
    TensorPtrMakerTest,
    CreateArangeTensorWithInferredDimensionDifferentPosition) {
  // Test arange with -1 dimension in first position
  auto tensor = arange(0, 20, 1, {-1, 5});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 4); // Should be inferred as 20/5 = 4
  EXPECT_EQ(tensor->size(1), 5);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
}

TEST_F(
    TensorPtrMakerTest,
    CreateArangeTensorWithMultipleDimensionsAndInference) {
  // Test arange with 3D tensor and -1 dimension
  auto tensor = arange(0, 24, 1, {2, -1, 3});

  EXPECT_EQ(tensor->dim(), 3);
  EXPECT_EQ(tensor->size(0), 2);
  EXPECT_EQ(tensor->size(1), 4); // Should be inferred as 24/(2*3) = 4
  EXPECT_EQ(tensor->size(2), 3);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
}

TEST_F(TensorPtrMakerTest, ArangeTensorSizesValidationMultipleNegativeOnes) {
  // Test that multiple -1s cause an error
  EXPECT_DEATH(
      arange(0, 12, 1, {-1, -1, 3}), "sizes can contain at most one -1");
}

TEST_F(TensorPtrMakerTest, ArangeTensorSizesValidationZeroDimension) {
  // Test that zero dimensions cause an error
  EXPECT_DEATH(
      arange(0, 12, 1, {3, 0, 4}),
      "sizes must contain positive integers or -1");
}

TEST_F(TensorPtrMakerTest, ArangeTensorSizesValidationNegativeDimension) {
  // Test that negative dimensions (other than -1) cause an error
  EXPECT_DEATH(
      arange(0, 12, 1, {3, -2, 4}),
      "sizes must contain positive integers or -1");
}

TEST_F(TensorPtrMakerTest, ArangeTensorSizesValidationIncompatibleProduct) {
  // Test that incompatible product causes an error
  EXPECT_DEATH(
      arange(0, 12, 1, {3, 5}), // 3*5 = 15, but numel = 12
      "product of sizes \\(15\\) does not match numel \\(12\\)");
}

TEST_F(TensorPtrMakerTest, ArangeTensorSizesValidationNonDivisibleInference) {
  // Test that non-divisible inference causes an error
  EXPECT_DEATH(
      arange(0, 13, 1, {3, -1, 2}), // 13 is not divisible by 3*2 = 6
      "numel \\(13\\) is not divisible by the product of known dimensions \\(6\\)");
}

TEST_F(TensorPtrMakerTest, ArangeTensorSizesValidationZeroInferredDimension) {
  // Test that zero inferred dimension causes an error
  EXPECT_DEATH(
      arange(
          0,
          0,
          1,
          {5, -1}), // numel = 0, so inferred dimension would be 0/5 = 0
      "inferred dimension size must be positive, got 0");
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithFloatStepAndSizes) {
  // Test arange with float step and sizes
  auto tensor =
      arange(0.0, 2.0, 0.5, {2, 2}, executorch::aten::ScalarType::Float);

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 2);
  EXPECT_EQ(tensor->size(1), 2);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  // Check values: [0.0, 0.5, 1.0, 1.5]
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[0], 0.0f);
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[1], 0.5f);
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[2], 1.0f);
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[3], 1.5f);
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithNegativeStepAndSizes) {
  // Test arange with negative step and sizes
  auto tensor = arange(10, 6, -1, {2, 2});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 2);
  EXPECT_EQ(tensor->size(1), 2);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  // Check values: [10, 9, 8, 7]
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[0], 10.0f);
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[1], 9.0f);
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[2], 8.0f);
  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[3], 7.0f);
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithSingleElementAndSizes) {
  // Test arange with single element and sizes
  auto tensor = arange(5, 6, 1, {1, 1});

  EXPECT_EQ(tensor->dim(), 2);
  EXPECT_EQ(tensor->size(0), 1);
  EXPECT_EQ(tensor->size(1), 1);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);

  EXPECT_FLOAT_EQ(tensor->const_data_ptr<float>()[0], 5.0f);
}

TEST_F(TensorPtrMakerTest, CreateArangeTensorWithEmptyRangeAndSizes) {
  // Test arange with empty range and sizes
  auto tensor = arange(5, 0, 1, {});

  EXPECT_EQ(tensor->dim(), 1);
  EXPECT_EQ(tensor->size(0), 0);
  EXPECT_EQ(tensor->scalar_type(), executorch::aten::ScalarType::Float);
}
