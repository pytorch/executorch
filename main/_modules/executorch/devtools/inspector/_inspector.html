
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
  <meta name="robots" content="noindex">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>executorch.devtools.inspector._inspector &#8212; ExecuTorch main documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=047068a3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../../_static/documentation_options.js?v=a8da1a53"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/executorch/devtools/inspector/_inspector';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://docs.pytorch.org/executorch/executorch-versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'main';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="canonical" href="https://docs.pytorch.org/executorch/_modules/executorch/devtools/inspector/_inspector.html" />
    <link rel="icon" href="../../../../_static/executorch-chip-logo.svg"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/2.3.1/list.min.js"></script>
<script>
  if (window.location.hostname === 'docs.pytorch.org' || window.location.hostname === 'docs-preview.pytorch.org') {
    const script = document.createElement('script');
    script.src = 'https://cmp.osano.com/16A0DbT9yDNIaQkvZ/31b1b91a-e0b6-47ea-bde2-7f2bd13dbe5c/osano.js?variant=one';
    document.head.appendChild(script);
  }
</script>
<script>
  // Cookie banner for non-LF projects
  document.addEventListener('DOMContentLoaded', function () {
    // Hide cookie banner on local environments and LF owned docs
    if (window.location.hostname === 'localhost' ||
      window.location.hostname === '0.0.0.0' ||
      window.location.hostname === '127.0.0.1' ||
      window.location.hostname === 'docs.pytorch.org' ||
      window.location.hostname === 'docs-preview.pytorch.org' ||
      window.location.hostname.startsWith('192.168.')) {
      const banner = document.querySelector('.cookie-banner-wrapper');
      if (banner) {
        banner.style.display = 'none';
      }
    }
  });
</script>
<!-- Conditional CSS for header and footer height adjustment -->


<link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css" crossorigin="anonymous">
<script type="text/javascript" src="../../../../_static/js/theme.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400&display=swap" rel="stylesheet">
<meta property="og:image" content="../../../../_static/img/pytorch_seo.png" />
<link rel="stylesheet" href="../../../../_static/webfonts/all.min.css" crossorigin="anonymous">
<meta http-equiv="Content-Security-Policy"
  content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; style-src * 'unsafe-inline'; script-src * 'unsafe-inline' 'unsafe-eval' blob:;">
<meta name="pytorch_project" content="">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8XT4PS" height="0" width="0"
    style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Google Tag Manager -->
<script>(function (w, d, s, l, i) {
    w[l] = w[l] || []; w[l].push({
      'gtm.start':
        new Date().getTime(), event: 'gtm.js'
    }); var f = d.getElementsByTagName(s)[0],
      j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
        'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
    j.onload = function () {
      window.dispatchEvent(new Event('gtm_loaded'));
      console.log('GTM loaded successfully');
    };
  })(window, document, 'script', 'dataLayer', 'GTM-T8XT4PS');
</script>
<!-- End Google Tag Manager -->
<!-- Facebook Pixel Code -->
<script>
  !function (f, b, e, v, n, t, s) {
    if (f.fbq) return; n = f.fbq = function () {
      n.callMethod ?
        n.callMethod.apply(n, arguments) : n.queue.push(arguments)
    };
    if (!f._fbq) f._fbq = n; n.push = n; n.loaded = !0; n.version = '2.0';
    n.queue = []; t = b.createElement(e); t.async = !0;
    t.src = v; s = b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t, s)
  }(window, document, 'script',
    'https://connect.facebook.net/en_US/fbevents.js');
  fbq('init', '243028289693773');
  fbq('track', 'PageView');
</script>
<script>
  document.documentElement.setAttribute('data-version', 'main');
</script>
<noscript>
  <img height="1" width="1" src="https://www.facebook.com/tr?id=243028289693773&ev=PageView&noscript=1" />
</noscript>
<script>
  function gtag() {
    window.dataLayer.push(arguments);
  }
</script>
<!-- End Facebook Pixel Code -->
<!-- Repository configuration for tutorials -->

<!-- Script to Fix scrolling -->
<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Fix anchor scrolling
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const targetId = this.getAttribute('href').substring(1);
        const targetElement = document.getElementById(targetId);

        if (targetElement) {
          const headerHeight =
            (document.querySelector('.header-holder') ? document.querySelector('.header-holder').offsetHeight : 0) +
            (document.querySelector('.bd-header') ? document.querySelector('.bd-header').offsetHeight : 0) + 20;

          const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - headerHeight;
          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth'
          });

          // Update URL hash without scrolling
          history.pushState(null, null, '#' + targetId);
        }
      });
    });
  });
</script>

<script async src="https://cse.google.com/cse.js?cx=e65585f8c3ea1440e"></script>

<!--
   Search engines should not index the main version of documentation.
   Stable documentation are built without release == 'main'.
   -->
<meta name="robots" content="noindex">


  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>

  </head>

<body data-feedback-url="https://github.com/pytorch/executorch" class="pytorch-body">
  
    <div class="container-fluid header-holder tutorials-header" id="header-holder">
   <div class="header-container-wrapper">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                <span>Learn</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/get-started/locally">
                  <span class=dropdown-title>Get Started</span>
                </a>
                <a class="nav-dropdown-item" href="https://docs.pytorch.org/tutorials">
                  <span class="dropdown-title">Tutorials</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/basics/intro.html">
                  <span class="dropdown-title">Learn the Basics</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/recipes/recipes_index.html">
                  <span class="dropdown-title">PyTorch Recipes</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/introyt.html">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/webinars/">
                  <span class="dropdown-title">Webinars</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>Community</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://landscape.pytorch.org/" target="_blank">
                  <span class="dropdown-title">Landscape</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/join-ecosystem">
                  <span class="dropdown-title">Join the Ecosystem</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-hub/">
                  <span class="dropdown-title">Community Hub</span>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/">
                  <span class="dropdown-title">Forums</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class=dropdown-title>Developer Resources</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/contributor-awards/">
                  <span class="dropdown-title">Contributor Awards</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-events/">
                  <span class="dropdown-title">Community Events</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/programs/ambassadors/">
                  <span class="dropdown-title">PyTorch Ambassadors</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>Projects</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/pytorch/">
                  <span class="dropdown-title">PyTorch</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/vllm/">
                  <span class="dropdown-title">vLLM</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/deepspeed/">
                  <span class="dropdown-title">DeepSpeed</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/projects/host-your-project/">
                  <span class="dropdown-title">Host Your Project</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span> Docs</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://docs.pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/domains">
                  <span class="dropdown-title">Domains</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>Blogs & News</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/blog/">
                  <span class="dropdown-title">Blog</span>
                </a>
                 <a class="nav-dropdown-item" href="https://pytorch.org/announcements">
                  <span class="dropdown-title">Announcements</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/case-studies/">
                  <span class="dropdown-title">Case Studies</span>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/newsletter">
                  <span class="dropdown-title">Newsletter</span>
                </a>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
              <span>About</span>
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/members">
                  <span class="dropdown-title">Members</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/governing-board">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tac">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/credits">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/staff">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/contact">
                  <span class="dropdown-title">Contact</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown main-menu-button">
              <a href="https://pytorch.org/join" data-cta="join">
                JOIN
              </a>
            </div>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu">
        <i class="fa-solid fa-ellipsis"></i>
      </a>
    </div>
  </div>
 </div>

 <!-- Begin Mobile Menu -->

<div class="mobile-main-menu">
  <div class="container-fluid">
    <div class="header-container-wrapper">
      <div class="mobile-main-menu-header-container">
        <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu">
        </a>
      </div>
    </div>
  </div>

  <div class="mobile-main-menu-links-container">
    <div class="main-menu">
      <ul>
         <li class="resources-mobile-menu-title">
           <a>Learn</a>
         </li>
         <ul class="resources-mobile-menu-items">
           <li>
             <a href="https://pytorch.org/get-started/locally">Get Started</a>
           </li>
           <li>
             <a href="https://docs.pytorch.org/tutorials">Tutorials</a>
           </li>
           <li>
             <a href="https://pytorch.org/tutorials/beginner/basics/intro.html">Learn the Basics</a>
           </li>
           <li>
             <a href="https://pytorch.org/tutorials/recipes/recipes_index.html">PyTorch Recipes</a>
           </li>
           <li>
             <a href="https://pytorch.org/tutorials/beginner/introyt.html">Introduction to PyTorch - YouTube Series</a>
           </li>
           <li>
            <a href="https://pytorch.org/webinars/">Webinars</a>
          </li>
        </ul>
         <li class="resources-mobile-menu-title">
           <a>Community</a>
         </li>
         <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://landscape.pytorch.org/">Landscape</a>
          </li>
          <li>
             <a href="https://pytorch.org/join-ecosystem">Join the Ecosystem</a>
           </li>
           <li>
             <a href="https://pytorch.org/community-hub/">Community Hub</a>
           </li>
           <li>
             <a href="https://discuss.pytorch.org/">Forums</a>
           </li>
           <li>
             <a href="https://pytorch.org/resources">Developer Resources</a>
           </li>
           <li>
             <a href="https://pytorch.org/contributor-awards/">Contributor Awards</a>
           </li>
           <li>
            <a href="https://pytorch.org/community-events/">Community Events</a>
          </li>
          <li>
            <a href="https://pytorch.org/programs/ambassadors/">PyTorch Ambassadors</a>
          </li>
       </ul>

         <li class="resources-mobile-menu-title">
           <a>Projects</a>
         </li>

         <ul class="resources-mobile-menu-items">
           <li>
             <a href="https://pytorch.org/projects/pytorch/">PyTorch</a>
           </li>

           <li>
             <a href="https://pytorch.org/projects/vllm/">vLLM</a>
           </li>
           <li>
            <a href="https://pytorch.org/projects/deepspeed/">DeepSpeed</a>
          </li>
          <li>
             <a href="https://pytorch.org/projects/host-your-project/">Host Your Project</a>
           </li>
         </ul>

         <li class="resources-mobile-menu-title">
           <a>Docs</a>
         </li>

         <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://docs.pytorch.org/docs/stable/index.html">PyTorch</a>
          </li>

          <li>
            <a href="https://pytorch.org/domains">Domains</a>
          </li>
        </ul>

        <li class="resources-mobile-menu-title">
          <a>Blog & News</a>
        </li>

         <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://pytorch.org/blog/">Blog</a>
          </li>
          <li>
            <a href="https://pytorch.org/announcements">Announcements</a>
          </li>

          <li>
            <a href="https://pytorch.org/case-studies/">Case Studies</a>
          </li>
          <li>
            <a href="https://pytorch.org/events">Events</a>
          </li>
          <li>
             <a href="https://pytorch.org/newsletter">Newsletter</a>
           </li>
        </ul>

        <li class="resources-mobile-menu-title">
          <a>About</a>
        </li>

        <ul class="resources-mobile-menu-items">
          <li>
            <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
          </li>
          <li>
            <a href="https://pytorch.org/members">Members</a>
          </li>
          <li>
            <a href="https://pytorch.org/governing-board">Governing Board</a>
          </li>
          <li>
            <a href="https://pytorch.org/tac">Technical Advisory Council</a>
         </li>
         <li>
             <a href="https://pytorch.org/credits">Cloud Credit Program</a>
          </li>
          <li>
             <a href="https://pytorch.org/staff">Staff</a>
          </li>
          <li>
             <a href="https://pytorch.org/contact">Contact</a>
          </li>
        </ul>
      </ul>
    </div>
  </div>
</div>

<!-- End Mobile Menu -->
  
  
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../_static/et-logo.png" class="logo__image only-light" alt="ExecuTorch main documentation - Home"/>
    <script>document.write(`<img src="../../../../_static/et-logo.png" class="logo__image only-dark" alt="ExecuTorch main documentation - Home"/>`);</script>
  
  
</a></div>
    
      <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../intro-section.html">
    Intro
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../quick-start-section.html">
    Quick Start
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../edge-platforms-section.html">
    Edge
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../backends-section.html">
    Backends
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../llm/working-with-llms.html">
    LLMs
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../advanced-topics-section.html">
    Advanced
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../tools-section.html">
    Tools
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api-section.html">
    API
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../../../../support-section.html">
    Support
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
  
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
</div>
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/executorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discuss.pytorch.org/" title="Discourse" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Discourse</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/executorch" title="PyPi" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPi</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../intro-section.html">
    Intro
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../quick-start-section.html">
    Quick Start
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../edge-platforms-section.html">
    Edge
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../backends-section.html">
    Backends
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../llm/working-with-llms.html">
    LLMs
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../advanced-topics-section.html">
    Advanced
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../tools-section.html">
    Tools
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api-section.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../support-section.html">
    Support
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
  
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
</div>
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/executorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://discuss.pytorch.org/" title="Discourse" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-discourse fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Discourse</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/executorch" title="PyPi" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-python fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPi</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">executorch.d...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-behavior="tutorial-rating" data-count="1" data-value="1">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="2" data-value="2">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="3" data-value="3">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="4" data-value="4">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="5" data-value="5">★</span>
        
    </div>
</div>
</div>
      
    </div>
  
</div>
</div>
              
              
  
<div id="searchbox"></div>
  <article class="bd-article" id="pytorch-article">
    <!-- Hidden breadcrumb schema for SEO only -->
    <div style="display:none;" itemscope itemtype="https://schema.org/BreadcrumbList">
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <link itemprop="item" href="../../../index.html">
        <meta itemprop="name" content="Module code">
        <meta itemprop="position" content="1">
      </div>
      
      <div itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
        <meta itemprop="name" content="executorch.devtools.inspector._inspector">
        <meta itemprop="position" content="2">
      </div>
    </div>

    
    

    
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for executorch.devtools.inspector._inspector</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the BSD-style license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="c1"># pyre-unsafe</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">cached_property</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">IO</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeAlias</span><span class="p">,</span>
    <span class="n">TypedDict</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">executorch.devtools.etdump.schema_flatcc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">flatcc</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.devtools.debug_format.et_schema</span><span class="w"> </span><span class="kn">import</span> <span class="n">OperatorGraph</span><span class="p">,</span> <span class="n">OperatorNode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.devtools.etdump.schema_flatcc</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DebugEvent</span><span class="p">,</span>
    <span class="n">ETDumpFlatCC</span><span class="p">,</span>
    <span class="n">ProfileEvent</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.devtools.etrecord</span><span class="w"> </span><span class="kn">import</span> <span class="n">ETRecord</span><span class="p">,</span> <span class="n">parse_etrecord</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.devtools.inspector._inspector_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">calculate_time_scale_factor</span><span class="p">,</span>
    <span class="n">compare_intermediate_outputs</span><span class="p">,</span>
    <span class="n">create_debug_handle_to_op_node_mapping</span><span class="p">,</span>
    <span class="n">DebugHandle</span><span class="p">,</span>
    <span class="n">display_or_print_df</span><span class="p">,</span>
    <span class="n">EDGE_DIALECT_GRAPH_KEY</span><span class="p">,</span>
    <span class="n">EXCLUDED_COLUMNS_WHEN_PRINTING</span><span class="p">,</span>
    <span class="n">EXCLUDED_EVENTS_FOR_INTERMEDIATE_OUTPUT</span><span class="p">,</span>
    <span class="n">EXCLUDED_EVENTS_WHEN_PRINTING</span><span class="p">,</span>
    <span class="n">find_op_names</span><span class="p">,</span>
    <span class="n">find_populated_event</span><span class="p">,</span>
    <span class="n">FORWARD</span><span class="p">,</span>
    <span class="n">gen_etdump_object</span><span class="p">,</span>
    <span class="n">gen_graphs_from_etrecord</span><span class="p">,</span>
    <span class="n">get_aot_debug_handle_to_op_name_mapping</span><span class="p">,</span>
    <span class="n">inflate_runtime_output</span><span class="p">,</span>
    <span class="n">is_debug_output</span><span class="p">,</span>
    <span class="n">is_inference_output_equal</span><span class="p">,</span>
    <span class="n">map_runtime_aot_intermediate_outputs</span><span class="p">,</span>
    <span class="n">merge_runtime_overlapping_debug_handles</span><span class="p">,</span>
    <span class="n">ProgramOutput</span><span class="p">,</span>
    <span class="n">propagate_back_debug_handle</span><span class="p">,</span>
    <span class="n">RESERVED_FRAMEWORK_EVENT_NAMES</span><span class="p">,</span>
    <span class="n">TimeScale</span><span class="p">,</span>
    <span class="n">verify_debug_data_equivalence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.devtools.inspector._intermediate_output_capturer</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">IntermediateOutputCapturer</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.devtools.inspector.numerical_comparator</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">L1Comparator</span><span class="p">,</span>
    <span class="n">MSEComparator</span><span class="p">,</span>
    <span class="n">SNRComparator</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">executorch.exir</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExportedProgram</span>


<span class="n">log</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># Signature of an InstructionEvent</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InstructionEventSignature</span><span class="p">:</span>
    <span class="n">instruction_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">chain_index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">delegate_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">delegate_id_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># Aggregated Runtime Events for a single instruction</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InstructionEvent</span><span class="p">:</span>
    <span class="n">signature</span><span class="p">:</span> <span class="n">InstructionEventSignature</span>
    <span class="n">profile_events</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">ProfileEvent</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">debug_events</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DebugEvent</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gen_from_events</span><span class="p">(</span><span class="n">run_events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flatcc</span><span class="o">.</span><span class="n">Event</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;InstructionEvent&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of events from a run in ETDump, collate the ProfileEvent</span>
<span class="sd">        and DebugEvents by instruction id and return a list of InstructionEvents</span>
<span class="sd">        constructed from collated events (ignoring run_output events)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">instruction_events</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">InstructionEventSignature</span><span class="p">,</span> <span class="n">InstructionEvent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">run_events</span><span class="p">:</span>
            <span class="c1"># Find the event that was logged</span>
            <span class="n">populated_event</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DebugEvent</span><span class="p">,</span> <span class="n">ProfileEvent</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_populated_event</span><span class="p">(</span>
                <span class="n">event</span>
            <span class="p">)</span>

            <span class="c1"># Get existing InstructionEvent or insert a new one</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">InstructionEventSignature</span><span class="p">(</span>
                <span class="n">instruction_id</span><span class="o">=</span><span class="n">populated_event</span><span class="o">.</span><span class="n">instruction_id</span><span class="p">,</span>
                <span class="n">chain_index</span><span class="o">=</span><span class="n">populated_event</span><span class="o">.</span><span class="n">chain_index</span><span class="p">,</span>
                <span class="n">delegate_id</span><span class="o">=</span><span class="n">populated_event</span><span class="o">.</span><span class="n">delegate_debug_id_int</span><span class="p">,</span>
                <span class="n">delegate_id_str</span><span class="o">=</span><span class="n">populated_event</span><span class="o">.</span><span class="n">delegate_debug_id_str</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">instruction_event</span> <span class="o">=</span> <span class="n">instruction_events</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="n">signature</span><span class="p">,</span> <span class="n">InstructionEvent</span><span class="p">(</span><span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Update InstructionEvent based on event type</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">populated_event</span><span class="p">,</span> <span class="n">ProfileEvent</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">instruction_event</span><span class="o">.</span><span class="n">profile_events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">instruction_event</span><span class="o">.</span><span class="n">profile_events</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">instruction_event</span><span class="o">.</span><span class="n">profile_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">populated_event</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">populated_event</span><span class="p">,</span> <span class="n">DebugEvent</span><span class="p">):</span>
                <span class="c1"># Ignore run_output events</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_debug_output</span><span class="p">(</span><span class="n">populated_event</span><span class="o">.</span><span class="n">debug_entry</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">instruction_event</span><span class="o">.</span><span class="n">debug_events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">instruction_event</span><span class="o">.</span><span class="n">debug_events</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">instruction_event</span><span class="o">.</span><span class="n">debug_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">populated_event</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">instruction_events</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="c1"># Signature of a ProfileEvent</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ProfileEventSignature</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">instruction_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">delegate_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">delegate_id_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_from_event</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">ProfileEvent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ProfileEventSignature&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a ProfileEvent, extract the fields into a signature</span>

<span class="sd">        ProfileEvents from ETDump default to &quot;&quot; and -1 when the field is not populated</span>
<span class="sd">        The Signature will convert these back to the intended None value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProfileEventSignature</span><span class="p">(</span>
            <span class="n">event</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">instruction_id</span> <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">instruction_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_int</span> <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_int</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_str</span> <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_str</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>


<span class="c1"># Signature of a DebugEvent</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DebugEventSignature</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">instruction_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">delegate_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">delegate_id_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_from_event</span><span class="p">(</span><span class="n">event</span><span class="p">:</span> <span class="n">DebugEvent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DebugEventSignature&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a DebugEvent, extract the fields into a signature</span>

<span class="sd">        DebugEvents from ETDump default to &quot;&quot; and -1 when the field is not populated</span>
<span class="sd">        The Signature will convert these back to the intended None value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DebugEventSignature</span><span class="p">(</span>
            <span class="n">event</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">instruction_id</span> <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">instruction_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_int</span> <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_int</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_str</span> <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_id_str</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>


<span class="c1"># Signature of an Event inside of a Run</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EventSignature</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Note that (profile_event_signature, debug_event_signature) are sufficient</span>
<span class="sd">    signature identifiers.</span>

<span class="sd">    instruction_id is extracted from the signatures (equivalent in both) and</span>
<span class="sd">    surfaced for convenience</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instruction_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">profile_event_signature</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProfileEventSignature</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">debug_event_signature</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DebugEventSignature</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gen_from_instruction_event</span><span class="p">(</span>
        <span class="n">instruction_event</span><span class="p">:</span> <span class="n">InstructionEvent</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="s2">&quot;EventSignature&quot;</span><span class="p">,</span> <span class="n">InstructionEvent</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct EventSignatures from the given InstructionEvent</span>
<span class="sd">        and return tuples of (1) EventSignature and (2) related subset</span>
<span class="sd">        InstructionEvent</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Generate the DebugEventSignature</span>
        <span class="n">debug_events</span> <span class="o">=</span> <span class="n">instruction_event</span><span class="o">.</span><span class="n">debug_events</span>
        <span class="n">debug_signature</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">DebugEventSignature</span><span class="o">.</span><span class="n">_gen_from_event</span><span class="p">(</span><span class="n">debug_events</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">debug_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">debug_events</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># If no ProfileEvents, return a singleton EventSignature</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">profile_events</span> <span class="o">:=</span> <span class="n">instruction_event</span><span class="o">.</span><span class="n">profile_events</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">EventSignature</span><span class="p">(</span>
                        <span class="n">instruction_id</span><span class="o">=</span><span class="n">instruction_event</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">instruction_id</span><span class="p">,</span>
                        <span class="n">debug_event_signature</span><span class="o">=</span><span class="n">debug_signature</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">instruction_event</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># Generate the ProfileEventSignature</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">EventSignature</span><span class="p">(</span>
                    <span class="n">instruction_id</span><span class="o">=</span><span class="n">instruction_event</span><span class="o">.</span><span class="n">signature</span><span class="o">.</span><span class="n">instruction_id</span><span class="p">,</span>
                    <span class="n">profile_event_signature</span><span class="o">=</span><span class="n">ProfileEventSignature</span><span class="o">.</span><span class="n">_gen_from_event</span><span class="p">(</span>
                        <span class="n">profile_event</span>
                    <span class="p">),</span>
                    <span class="n">debug_event_signature</span><span class="o">=</span><span class="n">debug_signature</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">instruction_event</span><span class="p">,</span> <span class="n">profile_events</span><span class="o">=</span><span class="p">[</span><span class="n">profile_event</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">profile_event</span> <span class="ow">in</span> <span class="n">profile_events</span>
        <span class="p">]</span>


<span class="c1"># Signature of a Run</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RunSignature</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        name: Name of the run</span>
<span class="sd">        events: List of EventSignatures that correspond to the run</span>
<span class="sd">        bundled_input_index: Index of the bundled input used to generate the debug output</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">events</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">EventSignature</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bundled_input_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># Typing for mapping Event.delegate_debug_identifiers to debug_handle(s)</span>
<span class="n">DelegateIdentifierDebugHandleMap</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Mapping</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">DebugHandle</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DebugHandle</span><span class="p">]</span>
<span class="p">]</span>

<span class="c1"># Typing for Dict containig delegate metadata</span>
<span class="n">DelegateMetadata</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span>
    <span class="s2">&quot;DelegateMetadata&quot;</span><span class="p">,</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;delegate_map&quot;</span><span class="p">:</span> <span class="n">DelegateIdentifierDebugHandleMap</span><span class="p">},</span>
<span class="p">)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PerfData</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">p10</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">p50</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">p90</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">avg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="p">)</span>


<div class="viewcode-block" id="Event">
<a class="viewcode-back" href="../../../../model-inspector.html#executorch.devtools.inspector.Event">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Event</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An Event corresponds to an operator instance with perf data retrieved from the runtime and other metadata from `ETRecord`.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Name of the profiling `Event`, empty if no profiling event.</span>
<span class="sd">        perf_data: Performance data associated with the event retrived from the runtime (available attributes: p10, p50, p90, avg, min and max).</span>
<span class="sd">        op_type: List of op types corresponding to the event.</span>
<span class="sd">        delegate_debug_identifier: Supplemental identifier used in combination with instruction id.</span>
<span class="sd">        debug_handles: Debug handles in the model graph to which this event is correlated.</span>
<span class="sd">        num_outputs: Indicates the number of outputs generated by the node.</span>
<span class="sd">                     Right now only used for call_delegate nodes that output more than one tensor.</span>
<span class="sd">        stack_trace: A dictionary mapping the name of each associated op to its stack trace.</span>
<span class="sd">        module_hierarchy: A dictionary mapping the name of each associated op to its module hierarchy.</span>
<span class="sd">        is_delegated_op: Whether or not the event was delegated.</span>
<span class="sd">        delegate_backend_name: Name of the backend this event was delegated to.</span>

<span class="sd">        _delegate_debug_metadatas: A list of raw delegate debug metadata in string, one for each profile event.</span>
<span class="sd">            Available parsed (if parser provided) as Event.delegate_debug_metadatas</span>
<span class="sd">            Available as Event.raw_delegate_debug_metadatas</span>

<span class="sd">        debug_data: A list containing intermediate data collected.</span>

<span class="sd">        _instruction_id: Instruction Identifier for Symbolication</span>
<span class="sd">        _delegate_metadata_parser: Optional Parser for _delegate_debug_metadatas</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">perf_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PerfData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">op_types</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">delegate_debug_identifier</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">debug_handles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">num_outputs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">stack_traces</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">module_hierarchy</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">is_delegated_op</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">delegate_backend_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_delegate_debug_metadatas</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

    <span class="n">debug_data</span><span class="p">:</span> <span class="n">ProgramOutput</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">_instruction_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_delegate_metadata_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_delegate_time_scale_converter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_start_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delegate_debug_metadatas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parsed _delegate_debug_metadatas if a parser is available</span>
<span class="sd">        Otherwise returns the raw _delegate_debug_metadatas</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_delegated_op</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_metadata_parser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_debug_metadatas</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_metadata_parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_delegate_debug_metadatas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">raw_delegate_debug_metadatas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw unparsed _delegate_debug_metadatas</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_debug_metadatas</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the start time of the event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_units</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the Event into a pandas DataFrame</span>

<span class="sd">        Args:</span>
<span class="sd">            None</span>

<span class="sd">        Returns:</span>
<span class="sd">            A pandas DataFrame with the Event data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">_units</span><span class="o">=</span><span class="n">_units</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">event_dict</span><span class="p">)</span>

    <span class="c1"># Override the default implementation of dataclass.asdict to handle null perf data</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_units</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the Event into a dict</span>

<span class="sd">        Args:</span>
<span class="sd">            None</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dict with the Event data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">truncated_list</span><span class="p">(</span><span class="n">long_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[&#39;</span><span class="si">{</span><span class="n">long_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;, &#39;</span><span class="si">{</span><span class="n">long_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; ... &#39;</span><span class="si">{</span><span class="n">long_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;] (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">long_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> total)&quot;</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;event_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">raw</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">],</span>
            <span class="s2">&quot;p10&quot;</span> <span class="o">+</span> <span class="n">_units</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">p10</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;p50&quot;</span> <span class="o">+</span> <span class="n">_units</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">p50</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;p90&quot;</span> <span class="o">+</span> <span class="n">_units</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">p90</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;avg&quot;</span> <span class="o">+</span> <span class="n">_units</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">avg</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;min&quot;</span> <span class="o">+</span> <span class="n">_units</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">min</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;max&quot;</span> <span class="o">+</span> <span class="n">_units</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">perf_data</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;op_types&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">op_types</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op_types</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span>
                    <span class="k">else</span> <span class="n">truncated_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op_types</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">],</span>
            <span class="s2">&quot;delegate_debug_identifier&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">delegate_debug_identifier</span><span class="p">,</span>
            <span class="s2">&quot;stack_traces&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stack_traces</span><span class="p">],</span>
            <span class="s2">&quot;module_hierarchy&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">module_hierarchy</span><span class="p">],</span>
            <span class="s2">&quot;is_delegated_op&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_delegated_op</span><span class="p">,</span>
            <span class="s2">&quot;delegate_backend_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">delegate_backend_name</span><span class="p">,</span>
            <span class="s2">&quot;debug_data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">debug_data</span><span class="p">],</span>
            <span class="s2">&quot;start_time&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_start_time</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_from_inference_events</span><span class="p">(</span>
        <span class="n">signature</span><span class="p">:</span> <span class="n">EventSignature</span><span class="p">,</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">],</span>
        <span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delegate_metadata_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delegate_time_scale_converter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Event&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an EventSignature and a list of Events with that signature,</span>
<span class="sd">        return an Event object matching the EventSignature, with perf_data</span>
<span class="sd">        populated from the list of ProfileEvents and debug_data populated from</span>
<span class="sd">        the list of DebugEvents.</span>

<span class="sd">        An optional inverse scale factor can be provided to adjust the event timestamps</span>
<span class="sd">        An optional buffer can be provided to inflate etdump references</span>
<span class="sd">        An optional delegate_metadata_parser can be provided to parse the delegate metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">profile_event_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="o">.</span><span class="n">profile_event_signature</span>
        <span class="n">debug_event_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="o">.</span><span class="n">debug_event_signature</span>

        <span class="c1"># Event is gradually populated in this function</span>
        <span class="n">ret_event</span><span class="p">:</span> <span class="n">Event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">_instruction_id</span><span class="o">=</span><span class="n">signature</span><span class="o">.</span><span class="n">instruction_id</span><span class="p">,</span>
            <span class="n">_delegate_metadata_parser</span><span class="o">=</span><span class="n">delegate_metadata_parser</span><span class="p">,</span>
            <span class="n">_delegate_time_scale_converter</span><span class="o">=</span><span class="n">delegate_time_scale_converter</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Populate fields from profile events</span>
        <span class="n">Event</span><span class="o">.</span><span class="n">_populate_profiling_related_fields</span><span class="p">(</span>
            <span class="n">ret_event</span><span class="p">,</span> <span class="n">profile_event_signature</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">scale_factor</span>
        <span class="p">)</span>

        <span class="c1"># Populate fields from debug events</span>
        <span class="n">Event</span><span class="o">.</span><span class="n">_populate_debugging_related_fields</span><span class="p">(</span>
            <span class="n">ret_event</span><span class="p">,</span> <span class="n">debug_event_signature</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">output_buffer</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ret_event</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_elapsed_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">):</span>
        <span class="c1"># We&#39;re assuming if there&#39;s a wraparound in the time values, then</span>
        <span class="c1"># the time representation of that platform only contains 32 bits.</span>
        <span class="c1"># This should be fine for now, but ideally we should source the max</span>
        <span class="c1"># time value from the platform using etdump.</span>
        <span class="n">max_uint32</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start_time</span> <span class="o">&gt;</span> <span class="n">max_uint32</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&gt;</span> <span class="n">max_uint32</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected start_time (</span><span class="si">{</span><span class="n">start_time</span><span class="si">}</span><span class="s2">) and end_time (</span><span class="si">{</span><span class="n">end_time</span><span class="si">}</span><span class="s2">) to be less than </span><span class="si">{</span><span class="n">max_uint32</span><span class="si">}</span><span class="s2"> for cases where there is wrap-around of time values.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Handle wraparound</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_uint32</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normal case</span>
            <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="k">return</span> <span class="n">elapsed_time</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_populate_event_signature_fields</span><span class="p">(</span>
        <span class="n">ret_event</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">,</span>
        <span class="n">event_signature</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ProfileEventSignature</span><span class="p">,</span> <span class="n">DebugEventSignature</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a partially constructed Event, populate the fields related to</span>
<span class="sd">        the profile event signature or debug event signature</span>

<span class="sd">        Fields Updated:</span>
<span class="sd">            name</span>
<span class="sd">            delegate_debug_identifier</span>
<span class="sd">            is_delegated_op</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: T201347372 Push the None check to ealier in the stack.</span>
        <span class="k">if</span> <span class="n">event_signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event_signature</span><span class="o">.</span><span class="n">delegate_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 0 is a valid value</span>
                <span class="n">delegate_debug_identifier</span> <span class="o">=</span> <span class="n">event_signature</span><span class="o">.</span><span class="n">delegate_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delegate_debug_identifier</span> <span class="o">=</span> <span class="n">event_signature</span><span class="o">.</span><span class="n">delegate_id_str</span> <span class="ow">or</span> <span class="kc">None</span>

            <span class="c1"># Use the delegate identifier as the event name if delegated</span>
            <span class="n">is_delegated_op</span> <span class="o">=</span> <span class="n">delegate_debug_identifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">event_signature</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_delegated_op</span>
                <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">delegate_debug_identifier</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Update fields</span>
            <span class="c1"># This is for older version of etdump that doesn&#39;t have the name field for debug events, we don&#39;t update the name field</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">ret_event</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">ret_event</span><span class="o">.</span><span class="n">delegate_debug_identifier</span> <span class="o">=</span> <span class="n">delegate_debug_identifier</span>
            <span class="n">ret_event</span><span class="o">.</span><span class="n">is_delegated_op</span> <span class="o">=</span> <span class="n">is_delegated_op</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_populate_profiling_related_fields</span><span class="p">(</span>
        <span class="n">ret_event</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">,</span>
        <span class="n">profile_event_signature</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProfileEventSignature</span><span class="p">],</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">],</span>
        <span class="n">scale_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a partially constructed Event, populate the fields related to</span>
<span class="sd">        the profile events</span>

<span class="sd">        Fields Updated:</span>
<span class="sd">            name</span>
<span class="sd">            delegate_debug_identifier</span>
<span class="sd">            is_delegated_op</span>
<span class="sd">            perf_data</span>
<span class="sd">            delegate_debug_metadatas</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Fill out fields from profile event signature</span>
        <span class="n">Event</span><span class="o">.</span><span class="n">_populate_event_signature_fields</span><span class="p">(</span><span class="n">ret_event</span><span class="p">,</span> <span class="n">profile_event_signature</span><span class="p">)</span>

        <span class="c1"># Fill out fields from profile event</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">delegate_debug_metadatas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">profile_events</span> <span class="o">:=</span> <span class="n">event</span><span class="o">.</span><span class="n">profile_events</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile_events</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected exactly one profile event per InstructionEvent when generating Inspector Event, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">profile_events</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="n">profile_event</span> <span class="o">=</span> <span class="n">profile_events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Scale factor should only be applied to non-delegated ops</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">ret_event</span><span class="o">.</span><span class="n">is_delegated_op</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">convert_time_scale</span> <span class="o">:=</span> <span class="n">ret_event</span><span class="o">.</span><span class="n">_delegate_time_scale_converter</span><span class="p">)</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="n">scaled_time</span> <span class="o">=</span> <span class="n">Event</span><span class="o">.</span><span class="n">_calculate_elapsed_time</span><span class="p">(</span>
                        <span class="n">convert_time_scale</span><span class="p">(</span><span class="n">ret_event</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">profile_event</span><span class="o">.</span><span class="n">start_time</span><span class="p">),</span>
                        <span class="n">convert_time_scale</span><span class="p">(</span><span class="n">ret_event</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">profile_event</span><span class="o">.</span><span class="n">end_time</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="c1"># If it&#39;s not a delegated op then we can just use the raw time values</span>
                <span class="c1"># and then scale them according to the scale factor that was passed in.</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">ret_event</span><span class="o">.</span><span class="n">is_delegated_op</span><span class="p">:</span>
                    <span class="n">scaled_time</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">float</span><span class="p">(</span>
                            <span class="n">Event</span><span class="o">.</span><span class="n">_calculate_elapsed_time</span><span class="p">(</span>
                                <span class="n">profile_event</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">profile_event</span><span class="o">.</span><span class="n">end_time</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="o">/</span> <span class="n">scale_factor</span>
                    <span class="p">)</span>
                <span class="c1"># If there was no scale factor passed in just take a difference of the</span>
                <span class="c1"># end and start times.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scaled_time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
                        <span class="n">Event</span><span class="o">.</span><span class="n">_calculate_elapsed_time</span><span class="p">(</span>
                            <span class="n">profile_event</span><span class="o">.</span><span class="n">start_time</span><span class="p">,</span> <span class="n">profile_event</span><span class="o">.</span><span class="n">end_time</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaled_time</span><span class="p">)</span>
                <span class="n">stime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">profile_event</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span>
                <span class="n">delegate_debug_metadatas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">profile_event</span><span class="o">.</span><span class="n">delegate_debug_metadata</span>
                    <span class="k">if</span> <span class="n">profile_event</span><span class="o">.</span><span class="n">delegate_debug_metadata</span>
                    <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Update fields</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ret_event</span><span class="o">.</span><span class="n">perf_data</span> <span class="o">=</span> <span class="n">PerfData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">delegate_debug_metadatas</span><span class="p">):</span>
            <span class="n">ret_event</span><span class="o">.</span><span class="n">_delegate_debug_metadatas</span> <span class="o">=</span> <span class="n">delegate_debug_metadatas</span>

        <span class="c1"># add _start_time to the event</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ret_event</span><span class="o">.</span><span class="n">_start_time</span> <span class="o">=</span> <span class="n">stime</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_populate_debugging_related_fields</span><span class="p">(</span>
        <span class="n">ret_event</span><span class="p">:</span> <span class="s2">&quot;Event&quot;</span><span class="p">,</span>
        <span class="n">debug_event_signature</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DebugEventSignature</span><span class="p">],</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">],</span>
        <span class="n">output_buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a partially constructed Event, populate the fields related to</span>
<span class="sd">        the debug events</span>

<span class="sd">        Fields Updated:</span>
<span class="sd">            name</span>
<span class="sd">            delegate_debug_identifier</span>
<span class="sd">            is_delegated_op</span>
<span class="sd">            debug_data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Fill out fields from debug event signature</span>
        <span class="n">Event</span><span class="o">.</span><span class="n">_populate_event_signature_fields</span><span class="p">(</span><span class="n">ret_event</span><span class="p">,</span> <span class="n">debug_event_signature</span><span class="p">)</span>

        <span class="n">debug_data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flatcc</span><span class="o">.</span><span class="n">Value</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">debug_events</span> <span class="o">:=</span> <span class="n">event</span><span class="o">.</span><span class="n">debug_events</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Populate on the first iteration only, then verify equivalence for others</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">debug_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">debug_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">debug_event</span><span class="o">.</span><span class="n">debug_entry</span> <span class="k">for</span> <span class="n">debug_event</span> <span class="ow">in</span> <span class="n">debug_events</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">debug_event</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">debug_events</span><span class="p">,</span> <span class="n">debug_data</span><span class="p">):</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">inflate_runtime_output</span><span class="p">(</span><span class="n">debug_event</span><span class="o">.</span><span class="n">debug_entry</span><span class="p">,</span> <span class="n">output_buffer</span><span class="p">)</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">inflate_runtime_output</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">output_buffer</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">is_inference_output_equal</span><span class="p">(</span>
                        <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span>
                    <span class="p">),</span> <span class="s2">&quot;&quot;&quot;Corresponding debug events in multiple iterations of the model</span>
<span class="s2">                    must have the same debug entry values. This is not the case for the</span>
<span class="s2">                    intermediate data present in this ETDump and indicates potential issues</span>
<span class="s2">                    with the model/runtime.&quot;&quot;&quot;</span>

        <span class="n">ret_event</span><span class="o">.</span><span class="n">debug_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inflate_runtime_output</span><span class="p">(</span><span class="n">debug_value</span><span class="p">,</span> <span class="n">output_buffer</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">debug_value</span> <span class="ow">in</span> <span class="n">debug_data</span>
        <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_associate_with_op_graph_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">debug_handle_to_op_node_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">OperatorNode</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to populate the stack_traces, module_hierarchy and op_types attributes</span>
<span class="sd">        based on the debug handles of this event</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Framework events aren&#39;t logically associated with any nodes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">RESERVED_FRAMEWORK_EVENT_NAMES</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">debug_handles</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_handles</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">debug_handles</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">debug_handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">debug_handles</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">debug_handles</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">debug_handle_to_op_node_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="c1"># Attach node metadata including stack traces, module hierarchy and op_types to this event</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">metadata</span> <span class="o">:=</span> <span class="n">node</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack_traces</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stack_traces</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;stack_trace&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">module_hierarchy</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                            <span class="s2">&quot;nn_module_stack&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">:</span>
                        <span class="c1"># TODO: consider having this as a dict from node.name -&gt; node.op</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">op_types</span> <span class="o">+=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">]</span></div>



<div class="viewcode-block" id="EventBlock">
<a class="viewcode-back" href="../../../../model-inspector.html#executorch.devtools.inspector.EventBlock">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EventBlock</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An `EventBlock` contains a collection of events associated with a particular profiling/debugging block retrieved from the runtime.</span>
<span class="sd">    Each `EventBlock` represents a pattern of execution. For example, model initiation and loading lives in a single `EventBlock`.</span>
<span class="sd">    If there&#39;s a control flow, each branch will be represented by a separate `EventBlock`.</span>

<span class="sd">    Args:</span>
<span class="sd">        name: Name of the profiling/debugging block.</span>
<span class="sd">        events: List of `Event`\ s associated with the profiling/debugging block.</span>

<span class="sd">        bundled_input_idx: Index of the Bundled Input that this EventBlock corresponds to.</span>
<span class="sd">        run_output: Run output extracted from the encapsulated Events</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Event</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">source_time_scale</span><span class="p">:</span> <span class="n">TimeScale</span> <span class="o">=</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">NS</span>
    <span class="n">target_time_scale</span><span class="p">:</span> <span class="n">TimeScale</span> <span class="o">=</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">MS</span>
    <span class="n">bundled_input_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">run_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProgramOutput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">reference_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProgramOutput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">include_units</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">include_delegate_debug_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the EventBlock into a DataFrame with each row being an event instance</span>

<span class="sd">        Note: Rows that have an event_name = OPERATOR_CALL correspond to the perf of the</span>
<span class="sd">            previous operator + framework tax of making said operator call.</span>

<span class="sd">        Args:</span>
<span class="sd">            include_units: Whether headers should include units (default false)</span>
<span class="sd">            include_delegate_debug_data: Whether to show the delegate debug data</span>

<span class="sd">        Returns:</span>
<span class="sd">            A pandas DataFrame containing the data of each Event instance in this EventBlock.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">units</span> <span class="o">=</span> <span class="s2">&quot; (&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_time_scale</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="k">if</span> <span class="n">include_units</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="n">units</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;event_block_name&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">))]),</span>
            <span class="n">allow_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add Delegate Debug Metadata columns</span>
        <span class="k">if</span> <span class="n">include_delegate_debug_data</span><span class="p">:</span>
            <span class="n">delegate_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">metadata</span> <span class="o">:=</span> <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_metadatas</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">metadata</span>
                <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">delegate_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">metadata</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;delegate_debug_metadata&quot;</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">delegate_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Unexpected type for delegate_debug_metadata: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">delegate_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">empty</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">delegate_data</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">delegate_data</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_from_etdump</span><span class="p">(</span>
        <span class="n">etdump</span><span class="p">:</span> <span class="n">ETDumpFlatCC</span><span class="p">,</span>
        <span class="n">source_time_scale</span><span class="p">:</span> <span class="n">TimeScale</span> <span class="o">=</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">NS</span><span class="p">,</span>
        <span class="n">target_time_scale</span><span class="p">:</span> <span class="n">TimeScale</span> <span class="o">=</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">MS</span><span class="p">,</span>
        <span class="n">output_buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delegate_metadata_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delegate_time_scale_converter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;EventBlock&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an etdump, generate a list of EventBlocks corresponding to the</span>
<span class="sd">        contents.</span>

<span class="sd">        An optional (inverse) scale factor can be provided to adjust the</span>
<span class="sd">        etdump timestamps associated with each EventBlocks</span>

<span class="sd">        An optional buffer to inflate etdump references</span>

<span class="sd">        An optional delegate metadata parser function to parse delegate profiling metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Map each RunSignatures to instances of its constituent events.</span>
        <span class="c1">#   The value of the map is a GroupedRunInstance which contains:</span>
        <span class="c1">#   (1) a map from each EventSignature to InstructionEvents with the signature</span>
        <span class="c1">#   (2) the run output for this RunSignature</span>
        <span class="nd">@dataclass</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">GroupedRunInstances</span><span class="p">:</span>
            <span class="n">events</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">[</span><span class="n">EventSignature</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">]]</span>
            <span class="n">run_output</span><span class="p">:</span> <span class="n">ProgramOutput</span>

        <span class="n">run_groups</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">RunSignature</span><span class="p">,</span> <span class="n">GroupedRunInstances</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">GroupedRunInstances</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">(),</span> <span class="p">[])</span>
        <span class="p">)</span>

        <span class="c1"># Collect all the run data</span>
        <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">etdump</span><span class="o">.</span><span class="n">run_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">run_events</span> <span class="o">:=</span> <span class="n">run</span><span class="o">.</span><span class="n">events</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Collate the run_events into InstructionEvents</span>
            <span class="n">instruction_events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">InstructionEvent</span><span class="o">.</span><span class="n">gen_from_events</span><span class="p">(</span><span class="n">run_events</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Map EventSignatures to the InstructionEvents</span>
            <span class="n">event_signatures</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">EventSignature</span><span class="p">,</span> <span class="n">InstructionEvent</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">instruction_event</span> <span class="ow">in</span> <span class="n">instruction_events</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">instruction_event</span><span class="o">.</span><span class="n">debug_events</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">instruction_event</span><span class="o">.</span><span class="n">profile_events</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="c1"># Currently corresponds to run output</span>
                    <span class="k">continue</span>

                <span class="n">generated_event_signatures</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
                    <span class="n">Tuple</span><span class="p">[</span><span class="n">EventSignature</span><span class="p">,</span> <span class="n">InstructionEvent</span><span class="p">]</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">EventSignature</span><span class="o">.</span><span class="n">gen_from_instruction_event</span><span class="p">(</span><span class="n">instruction_event</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span>
                    <span class="n">event_signature</span><span class="p">,</span>
                    <span class="n">filtered_instruction_event</span><span class="p">,</span>
                <span class="p">)</span> <span class="ow">in</span> <span class="n">generated_event_signatures</span><span class="p">:</span>
                    <span class="n">event_signatures</span><span class="p">[</span><span class="n">event_signature</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_instruction_event</span>

            <span class="c1"># Create a RunSignature from the EventSignatures</span>
            <span class="n">run_signature</span> <span class="o">=</span> <span class="n">RunSignature</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">run</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">events</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">event_signatures</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                <span class="n">bundled_input_index</span><span class="o">=</span><span class="n">run</span><span class="o">.</span><span class="n">bundled_input_index</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Update the Run Groups, indexed on the RunSignature</span>
            <span class="n">run_signature_events</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">[</span>
                <span class="n">EventSignature</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">]</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">run_groups</span><span class="p">[</span><span class="n">run_signature</span><span class="p">]</span><span class="o">.</span><span class="n">events</span>
            <span class="k">for</span> <span class="n">event_signature</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">event_signatures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">run_signature_events</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">event_signature</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

            <span class="c1"># Populate (or Verify if already populated) Run Outputs</span>
            <span class="n">run_outputs</span><span class="p">:</span> <span class="n">ProgramOutput</span> <span class="o">=</span> <span class="n">EventBlock</span><span class="o">.</span><span class="n">_collect_run_outputs</span><span class="p">(</span>
                <span class="n">run_events</span><span class="p">,</span> <span class="n">output_buffer</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">existing_run_outputs</span> <span class="o">:=</span> <span class="n">run_groups</span><span class="p">[</span><span class="n">run_signature</span><span class="p">]</span><span class="o">.</span><span class="n">run_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">existing_run_outputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">run_outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">verify_debug_data_equivalence</span><span class="p">(</span><span class="n">existing_run_outputs</span><span class="p">,</span> <span class="n">run_outputs</span><span class="p">)</span>

        <span class="c1"># Construct the EventBlocks</span>
        <span class="n">event_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">calculate_time_scale_factor</span><span class="p">(</span><span class="n">source_time_scale</span><span class="p">,</span> <span class="n">target_time_scale</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">run_signature</span><span class="p">,</span> <span class="n">grouped_run_instance</span> <span class="ow">in</span> <span class="n">run_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">run_group</span><span class="p">:</span> <span class="n">OrderedDict</span><span class="p">[</span><span class="n">EventSignature</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">InstructionEvent</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">grouped_run_instance</span><span class="o">.</span><span class="n">events</span>
            <span class="p">)</span>
            <span class="n">run_outputs</span><span class="p">:</span> <span class="n">ProgramOutput</span> <span class="o">=</span> <span class="n">grouped_run_instance</span><span class="o">.</span><span class="n">run_output</span>

            <span class="c1"># Construct the Events</span>
            <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">Event</span><span class="o">.</span><span class="n">_gen_from_inference_events</span><span class="p">(</span>
                    <span class="n">signature</span><span class="p">,</span>
                    <span class="n">instruction_events</span><span class="p">,</span>
                    <span class="n">scale_factor</span><span class="p">,</span>
                    <span class="n">output_buffer</span><span class="p">,</span>
                    <span class="n">delegate_metadata_parser</span><span class="p">,</span>
                    <span class="n">delegate_time_scale_converter</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">signature</span><span class="p">,</span> <span class="n">instruction_events</span> <span class="ow">in</span> <span class="n">run_group</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="c1"># Add the EventBlock to the return list</span>
            <span class="n">event_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">EventBlock</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">run_signature</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">events</span><span class="o">=</span><span class="n">events</span><span class="p">,</span>
                    <span class="n">source_time_scale</span><span class="o">=</span><span class="n">source_time_scale</span><span class="p">,</span>
                    <span class="n">target_time_scale</span><span class="o">=</span><span class="n">target_time_scale</span><span class="p">,</span>
                    <span class="n">bundled_input_index</span><span class="o">=</span><span class="n">run_signature</span><span class="o">.</span><span class="n">bundled_input_index</span><span class="p">,</span>
                    <span class="n">run_output</span><span class="o">=</span><span class="n">run_outputs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">event_blocks</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_collect_run_outputs</span><span class="p">(</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">flatcc</span><span class="o">.</span><span class="n">Event</span><span class="p">],</span> <span class="n">output_buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProgramOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of events, search the events for ProgramOutputs (aka lists of InferenceOutputs) marked</span>
<span class="sd">        as run outputs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">output_events</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">debug_event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">debug_event</span><span class="o">.</span><span class="n">debug_entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Debug entry inside debug event should not be empty!&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_debug_output</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">debug_event</span><span class="o">.</span><span class="n">debug_entry</span><span class="p">):</span>
                <span class="n">output_events</span> <span class="o">+=</span> <span class="p">[</span><span class="n">event</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">inflate_runtime_output</span><span class="p">(</span><span class="n">debug_event</span><span class="o">.</span><span class="n">debug_entry</span><span class="p">,</span> <span class="n">output_buffer</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">output_event</span> <span class="ow">in</span> <span class="n">output_events</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">debug_event</span> <span class="o">:=</span> <span class="n">output_event</span><span class="o">.</span><span class="n">debug_event</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>

    <span class="c1"># TODO: Considering changing ETRecord deserialization logic to cast the ints in string format to actual ints</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_resolve_debug_handles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">handle_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">delegate_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DelegateMetadata</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">instruction_id_to_num_outs_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given mappings from instruction id to debug handles, populate the</span>
<span class="sd">        debug_handles field of all underlying events</span>

<span class="sd">        If the event is delegated, index with the instruction_id and delegate_debug_identifier</span>
<span class="sd">        to obtain the debug_handle via the delegate map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="c1"># Check if instruction_id is present in the event</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">_instruction_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Check for the instruction_id in handle map</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">instruction_id</span> <span class="o">:=</span> <span class="nb">str</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">_instruction_id</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">handle_map</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">num_outputs</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">instruction_id_to_num_outs_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_outputs</span> <span class="o">=</span> <span class="n">instruction_id_to_num_outs_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instruction_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">event</span><span class="o">.</span><span class="n">num_outputs</span> <span class="o">=</span> <span class="n">num_outputs</span>
            <span class="c1"># For non-delegated event, handles are found in handle_map</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">delegate_debug_id</span> <span class="o">:=</span> <span class="n">event</span><span class="o">.</span><span class="n">delegate_debug_identifier</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">event</span><span class="o">.</span><span class="n">debug_handles</span> <span class="o">=</span> <span class="n">handle_map</span><span class="p">[</span><span class="n">instruction_id</span><span class="p">]</span>

                <span class="c1"># DELEGATE_CALL is a special non-delegated event and benefits from having the name populated</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">event</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;DELEGATE_CALL&quot;</span>
                    <span class="ow">and</span> <span class="n">delegate_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">delegate_metadata</span> <span class="o">:=</span> <span class="n">delegate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instruction_id</span><span class="p">))</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="n">event</span><span class="o">.</span><span class="n">delegate_backend_name</span> <span class="o">=</span> <span class="n">delegate_metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="k">continue</span>

            <span class="c1"># Check that the delegated event has a corresponding mapping</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">delegate_map</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">delegate_metadata</span> <span class="o">:=</span> <span class="n">delegate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instruction_id</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">event</span><span class="o">.</span><span class="n">debug_handles</span> <span class="o">=</span> <span class="n">handle_map</span><span class="p">[</span><span class="n">instruction_id</span><span class="p">]</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot; No delegate mapping found for delegate with instruction id </span><span class="si">{</span><span class="n">event</span><span class="o">.</span><span class="n">_instruction_id</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># For delegated events, handles are found via delegateMetadata</span>
            <span class="n">event</span><span class="o">.</span><span class="n">delegate_backend_name</span> <span class="o">=</span> <span class="n">delegate_metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">delegate_metadata_delegate_map</span> <span class="o">=</span> <span class="n">delegate_metadata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;delegate_map&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>

            <span class="c1"># delegate_debug_id can be either int based or string based, therefore we need to check both</span>
            <span class="n">debug_handles</span> <span class="o">=</span> <span class="n">delegate_metadata_delegate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">delegate_debug_id</span>  <span class="c1"># pyre-ignore</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">debug_handles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">event</span><span class="o">.</span><span class="n">debug_handles</span> <span class="o">=</span> <span class="n">debug_handles</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">event</span><span class="o">.</span><span class="n">debug_handles</span> <span class="o">=</span> <span class="n">delegate_metadata_delegate_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">delegate_debug_id</span><span class="p">)</span>  <span class="c1"># pyre-ignore</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">delegate_metadata_delegate_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">delegate_debug_id</span><span class="p">):</span>
                        <span class="n">event</span><span class="o">.</span><span class="n">debug_handles</span> <span class="o">=</span> <span class="n">value</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">Inspector</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    APIs for examining model architecture and performance stats.</span>

<span class="sd">    Public Attributes:</span>
<span class="sd">        event_blocks: List[&quot;EventBlocks&quot;]. Structured data from ETDump (correlated with ETRecord if provided).</span>

<span class="sd">    Private Attributes:</span>
<span class="sd">        _etrecord: Optional[ETRecord]. File under etrecord_path deserialized into an object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">etdump_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">etdump_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">etrecord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ETRecord</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source_time_scale</span><span class="p">:</span> <span class="n">TimeScale</span> <span class="o">=</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">NS</span><span class="p">,</span>
        <span class="n">target_time_scale</span><span class="p">:</span> <span class="n">TimeScale</span> <span class="o">=</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">MS</span><span class="p">,</span>
        <span class="n">debug_buffer_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delegate_metadata_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delegate_time_scale_converter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">enable_module_hierarchy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an `Inspector` instance with the underlying `EventBlock`\ s populated with data from the provided ETDump path or binary,</span>
<span class="sd">        and optional ETRecord path.</span>

<span class="sd">        Args:</span>
<span class="sd">            etdump_path: Path to the ETDump file. Either this parameter or etdump_data should be provided.</span>
<span class="sd">            etdump_data: ETDump binary. Either this parameter or etdump_path should be provided.</span>
<span class="sd">            etrecord: Optional ETRecord object or path to the ETRecord file.</span>
<span class="sd">            source_time_scale: The time scale of the performance data retrieved from the runtime. The default time hook implentation in the runtime returns NS.</span>
<span class="sd">            target_time_scale: The target time scale to which the users want their performance data converted to. Defaults to MS.</span>
<span class="sd">            debug_buffer_path: Debug buffer file path that contains the debug data referenced by ETDump for intermediate and program outputs.</span>
<span class="sd">            delegate_metadata_parser: Optional function to parse delegate metadata from an Profiling Event. Expected signature of the function is:</span>
<span class="sd">                    (delegate_metadata_list: List[bytes]) -&gt; Union[List[str], Dict[str, Any]]</span>
<span class="sd">            delegate_time_scale_converter: Optional function to convert the time scale of delegate profiling data. If not given, use the conversion ratio of</span>
<span class="sd">                    target_time_scale/source_time_scale.</span>
<span class="sd">            enable_module_hierarchy: Enable submodules in the operator graph. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">source_time_scale</span> <span class="o">==</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">CYCLES</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span>
            <span class="n">target_time_scale</span> <span class="o">==</span> <span class="n">TimeScale</span><span class="o">.</span><span class="n">CYCLES</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;For TimeScale in cycles both the source and target time scale have to be in cycles.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source_time_scale</span> <span class="o">=</span> <span class="n">source_time_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_time_scale</span> <span class="o">=</span> <span class="n">target_time_scale</span>

        <span class="k">if</span> <span class="n">delegate_time_scale_converter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">calculate_time_scale_factor</span><span class="p">(</span>
                <span class="n">source_time_scale</span><span class="p">,</span> <span class="n">target_time_scale</span>
            <span class="p">)</span>
            <span class="n">delegate_time_scale_converter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">event_name</span><span class="p">,</span> <span class="n">input_time</span><span class="p">:</span> <span class="n">input_time</span> <span class="o">/</span> <span class="n">scale_factor</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">etrecord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">etrecord</span><span class="p">,</span> <span class="n">ETRecord</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span> <span class="o">=</span> <span class="n">etrecord</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">etrecord</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span> <span class="o">=</span> <span class="n">parse_etrecord</span><span class="p">(</span><span class="n">etrecord_path</span><span class="o">=</span><span class="n">etrecord</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported ETRecord type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">etdump_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">etdump_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expecting exactly one of etdump_path or etdump_data to be specified.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create EventBlocks from ETDump</span>
        <span class="n">etdump</span> <span class="o">=</span> <span class="n">gen_etdump_object</span><span class="p">(</span><span class="n">etdump_path</span><span class="o">=</span><span class="n">etdump_path</span><span class="p">,</span> <span class="n">etdump_data</span><span class="o">=</span><span class="n">etdump_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_buffer_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">debug_buffer_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">output_buffer</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_buffer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Output Buffer not found. Tensor Debug Data will not be available.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span> <span class="o">=</span> <span class="n">EventBlock</span><span class="o">.</span><span class="n">_gen_from_etdump</span><span class="p">(</span>
            <span class="n">etdump</span><span class="o">=</span><span class="n">etdump</span><span class="p">,</span>
            <span class="n">source_time_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_source_time_scale</span><span class="p">,</span>
            <span class="n">target_time_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_target_time_scale</span><span class="p">,</span>
            <span class="n">output_buffer</span><span class="o">=</span><span class="n">output_buffer</span><span class="p">,</span>
            <span class="n">delegate_metadata_parser</span><span class="o">=</span><span class="n">delegate_metadata_parser</span><span class="p">,</span>
            <span class="n">delegate_time_scale_converter</span><span class="o">=</span><span class="n">delegate_time_scale_converter</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Connect ETRecord to EventBlocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op_graph_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">OperatorGraph</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># _consume_etrecord() will populate the _reference_outputs dict</span>
        <span class="c1"># Key str is method name; value is list of ProgramOutputs because of list of test cases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_outputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">ProgramOutput</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_module_hierarchy</span> <span class="o">=</span> <span class="n">enable_module_hierarchy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consume_etrecord</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_consume_etrecord</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If an ETRecord is provided, connect it to the EventBlocks and populate the Event metadata.</span>

<span class="sd">        Steps:</span>
<span class="sd">            1. Debug Handle Symbolification:</span>
<span class="sd">                For each Event, find the debug_handle counterparts using</span>
<span class="sd">                ETRecord&#39;s debug_handle_map and delegate_map</span>

<span class="sd">            2. Event Metadata Association:</span>
<span class="sd">                For each Event, populate its metadata from OperatorGraph Nodes,</span>
<span class="sd">                generated from ETRecord. The debug_handle is used to</span>
<span class="sd">                identify the corresponding OperatorGraph Nodes.</span>

<span class="sd">            3. Reference Outputs Extraction:</span>
<span class="sd">                If there&#39;re reference outputs saved in ETRecord, assign each reference output to the corresponding</span>
<span class="sd">                EventBlock based on the method name (currently assumes only &quot;forward&quot;) and the</span>
<span class="sd">                bundled_input_index of the EventBlock.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># (1) Debug Handle Symbolification</span>
        <span class="k">for</span> <span class="n">event_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span><span class="p">:</span>
            <span class="n">event_block</span><span class="o">.</span><span class="n">_gen_resolve_debug_handles</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_debug_handle_map</span><span class="p">[</span><span class="n">FORWARD</span><span class="p">],</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_delegate_map</span><span class="p">[</span><span class="n">FORWARD</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_delegate_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="kc">None</span>
                <span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_instruction_id_to_num_outs_map</span><span class="p">[</span><span class="n">FORWARD</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># (2) Event Metadata Association</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op_graph_dict</span> <span class="o">=</span> <span class="n">gen_graphs_from_etrecord</span><span class="p">(</span>
            <span class="n">etrecord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="p">,</span>
            <span class="n">enable_module_hierarchy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_enable_module_hierarchy</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">debug_handle_to_op_node_map</span> <span class="o">=</span> <span class="n">create_debug_handle_to_op_node_mapping</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_graph_dict</span><span class="p">[</span><span class="n">EDGE_DIALECT_GRAPH_KEY</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">event_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">event_block</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="n">event</span><span class="o">.</span><span class="n">_associate_with_op_graph_nodes</span><span class="p">(</span>
                    <span class="n">debug_handle_to_op_node_map</span><span class="o">=</span><span class="n">debug_handle_to_op_node_map</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># (3) Reference Outputs Extraction</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_reference_outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reference_outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_reference_outputs</span>
            <span class="c1"># Associate each reference output to the corresponding event block</span>
            <span class="k">for</span> <span class="n">event_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">event_block</span><span class="o">.</span><span class="n">bundled_input_index</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">event_block</span><span class="o">.</span><span class="n">reference_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_outputs</span><span class="p">[</span><span class="n">FORWARD</span><span class="p">][</span>
                        <span class="n">index</span>
                    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_aot_intermediate_outputs_and_op_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">disable_debug_handle_valdiation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">DebugHandle</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DebugHandle</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Capture intermediate outputs only if _representative_inputs are provided</span>
<span class="sd">        when using bundled program to create the etrecord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_representative_inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="n">export_program</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Will use the exported program to extract intermediate output if and only if exported_program has been provided, and it is one of the ancestors of the edge_dialect_program</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">exported_program</span> <span class="ow">and</span> <span class="n">propagate_back_debug_handle</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">exported_program</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">export_graph_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">edge_dialect_program</span><span class="p">,</span>
            <span class="n">disable_debug_handle_valdiation</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">export_program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">exported_program</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Either aten dialect exported program is not in ETRecord, or it is not one of the ancestors of current edge dialect program.&quot;</span>
                <span class="s2">&quot;Will fall back to use edge dialect program to extract intermediate output&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">export_program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">edge_dialect_program</span>
        <span class="n">graph_module</span> <span class="o">=</span> <span class="n">export_program</span><span class="o">.</span><span class="n">module</span><span class="p">()</span>
        <span class="n">aot_debug_handle_to_op_name</span> <span class="o">=</span> <span class="n">get_aot_debug_handle_to_op_name_mapping</span><span class="p">(</span>
            <span class="n">graph_module</span>
        <span class="p">)</span>
        <span class="n">capturer</span> <span class="o">=</span> <span class="n">IntermediateOutputCapturer</span><span class="p">(</span><span class="n">graph_module</span><span class="p">)</span>
        <span class="n">aot_intermediate_outputs</span> <span class="o">=</span> <span class="n">capturer</span><span class="o">.</span><span class="n">run_and_capture</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">_representative_inputs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">aot_intermediate_outputs</span><span class="p">,</span> <span class="n">aot_debug_handle_to_op_name</span>

    <span class="c1"># TODO: Make it more extensible to further merge overlapping debug handles</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_runtime_intermediate_outputs_and_op_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">DebugHandle</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DebugHandle</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the runtime intermediate outputs(debug handles and intermediate values mappings)</span>
<span class="sd">        from the event blocks, along with the corresponding debug handles and op names mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">debug_handle_to_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">debug_handle_to_op_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">event_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">event_block</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="c1"># Skip OPERATOR_CALL events to avoid double-counting and exclude framework tax</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">event</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">EXCLUDED_EVENTS_FOR_INTERMEDIATE_OUTPUT</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">event</span><span class="o">.</span><span class="n">op_types</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># Normalize debug_handle to a tuple</span>
                <span class="n">debug_handle</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">debug_handles</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">debug_handle</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">debug_handle</span> <span class="o">=</span> <span class="p">(</span><span class="n">debug_handle</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">debug_handle</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">debug_handle</span><span class="p">)</span>
                <span class="n">current_entry</span> <span class="o">=</span> <span class="n">debug_handle_to_output</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">debug_handle</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">num_outputs</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># When event has same debug_handle, only keep the one with the largest instruction id</span>
                <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">_instruction_id</span> <span class="o">&gt;</span> <span class="n">current_entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">debug_handle_to_output</span><span class="p">[</span><span class="n">debug_handle</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">event</span><span class="o">.</span><span class="n">_instruction_id</span><span class="p">,</span>
                        <span class="n">event</span><span class="o">.</span><span class="n">debug_data</span><span class="p">,</span>
                        <span class="n">event</span><span class="o">.</span><span class="n">num_outputs</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># TODO: One debug handle can be associated with multiple op names</span>
                    <span class="n">debug_handle_to_op_names</span><span class="p">[</span><span class="n">debug_handle</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="n">debug_handle_to_output</span> <span class="o">=</span> <span class="n">merge_runtime_overlapping_debug_handles</span><span class="p">(</span>
            <span class="n">debug_handle_to_output</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">debug_handle_to_output</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">},</span> <span class="n">debug_handle_to_op_names</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include_units</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_delegate_debug_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            include_units: Whether headers should include units (default true)</span>
<span class="sd">            include_delegate_debug_data: Whether to include delegate debug metadata (default false)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a pandas DataFrame of the Events in each EventBlock in the inspector, with each row representing an Event.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">df_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">event_block</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span>
                <span class="n">include_units</span><span class="o">=</span><span class="n">include_units</span><span class="p">,</span>
                <span class="n">include_delegate_debug_data</span><span class="o">=</span><span class="n">include_delegate_debug_data</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">event_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df_list</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">include_units</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_delegate_debug_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            include_units: Whether headers should include units (default true)</span>
<span class="sd">            include_delegate_debug_data: Whether to include delegate debug metadata (default false)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Returns a pandas DataFrame of the Events in each EventBlock in the inspector, with additional filtering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">(</span><span class="n">include_units</span><span class="p">,</span> <span class="n">include_delegate_debug_data</span><span class="p">)</span>

        <span class="c1"># Filter out some columns and rows for better readability when printing</span>
        <span class="n">filtered_column_df</span> <span class="o">=</span> <span class="n">combined_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">EXCLUDED_COLUMNS_WHEN_PRINTING</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">filter_name</span> <span class="ow">in</span> <span class="n">EXCLUDED_EVENTS_WHEN_PRINTING</span><span class="p">:</span>
            <span class="n">filtered_column_df</span> <span class="o">=</span> <span class="n">filtered_column_df</span><span class="p">[</span>
                <span class="o">~</span><span class="n">filtered_column_df</span><span class="p">[</span><span class="s2">&quot;event_name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">filter_name</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="n">filtered_column_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_column_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_data_tabular</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file</span><span class="p">:</span> <span class="n">IO</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
        <span class="n">include_units</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_delegate_debug_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Displays the underlying EventBlocks in a structured tabular format, with each row representing an Event.</span>

<span class="sd">        Args:</span>
<span class="sd">            file: Which IO stream to print to. Defaults to stdout.</span>
<span class="sd">                Not used if this is in an IPython environment such as a Jupyter notebook.</span>
<span class="sd">            include_units: Whether headers should include units (default true)</span>
<span class="sd">            include_delegate_debug_data: Whether to include delegate debug metadata (default false)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_dataframe</span><span class="p">(</span><span class="n">include_units</span><span class="p">,</span> <span class="n">include_delegate_debug_data</span><span class="p">)</span>
        <span class="n">display_or_print_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save_data_to_tsv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file</span><span class="p">:</span> <span class="n">IO</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">include_units</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_delegate_debug_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores the underlying EventBlocks in tsv format to facilitate copy-paste into spreadsheets.</span>

<span class="sd">        Args:</span>
<span class="sd">            file: Which IO stream to print to. Do not use stdout, as tab separator is not preserved.</span>
<span class="sd">            include_units: Whether headers should include units (default true)</span>
<span class="sd">            include_delegate_debug_data: Whether to include delegate debug metadata (default false)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_dataframe</span><span class="p">(</span><span class="n">include_units</span><span class="p">,</span> <span class="n">include_delegate_debug_data</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: write unit test</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_total_for_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total average compute time of all operators within the specified module.</span>

<span class="sd">        Args:</span>
<span class="sd">            module_name: Name of the module to be aggregated against.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sum of the average compute time (in seconds) of all operators within the module with &quot;module_name&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
                <span class="c1"># Skip OPERATOR_CALL events to avoid double-counting and exclude framework tax</span>
                <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;OPERATOR_CALL&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">module_hierarchy</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">module_hierarchy</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">hierarchy</span> <span class="ow">in</span> <span class="n">module_hierarchy</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">hierarchy</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">module_name</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hierarchy</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">perf_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">total</span> <span class="o">+=</span> <span class="n">event</span><span class="o">.</span><span class="n">perf_data</span><span class="o">.</span><span class="n">avg</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">total</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_op_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">event_block</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">show_delegated_ops</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Event</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a map of op_types to Events of that op_type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implement</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_tensorboard_artifact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write to the provided path, the artifacts required for visualization in TensorBoard</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implement</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_exported_program</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ExportedProgram</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access helper for ETRecord, defaults to returning the Edge Dialect program.</span>

<span class="sd">        Args:</span>
<span class="sd">            graph: Optional name of the graph to access. If None, returns the Edge Dialect program.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The ExportedProgram object of &quot;graph&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Exported program is only available when a valid etrecord_path was provided at the time of Inspector construction&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">edge_dialect_program</span>
            <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_etrecord</span><span class="o">.</span><span class="n">graph_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_numeric_gap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;MSE&quot;</span><span class="p">,</span> <span class="n">disable_debug_handle_valdiation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares logged intermediate outputs from the exported graph (in ETRecord)</span>
<span class="sd">        with runtime outputs (in ETDump) using a user-specific numerical comparator.</span>
<span class="sd">        If the exported graph is not supported, the function will fall back to use edge dialect graph.</span>

<span class="sd">        To use this function, you must first generate the ETRecord with representative inputs,</span>
<span class="sd">        and then create the Inspector instance with the ETRecord and ETDump. The Inspector can then</span>
<span class="sd">        compare the intermediate outputs from the AOT and the runtime.</span>

<span class="sd">        Args:</span>
<span class="sd">            distance: the metrics the inspector will use for gap calculation. Should be one of &quot;MSE&quot;, &quot;L1&quot; and &quot;SNR&quot;.</span>
<span class="sd">            disable_debug_handle_validation: Often when aten graph has symbolic shape nodes, and inbuilt ops like gt/lt etc.,</span>
<span class="sd">            during re-export of such a graph &#39;from_node&#39; information is lost from node.meta. As a result we loose connection</span>
<span class="sd">            between edge IR nodes and aten nodes for such ops. By default we validate that every edge IR node has corresponding</span>
<span class="sd">            node in aten IR, and when such validation fails numeric debugger falls back to edge IR as reference graph. This</span>
<span class="sd">            flag allows one to override such behavior and make best effort comparison.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A DataFrame listing corresponding operator intermediate outputs from both stages and their computed numerical gaps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aot_intermediate_outputs</span><span class="p">,</span> <span class="n">aot_debug_handle_to_op_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_aot_intermediate_outputs_and_op_names</span><span class="p">(</span>
                <span class="n">disable_debug_handle_valdiation</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aot_intermediate_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">aot_debug_handle_to_op_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Missing etrecord or missing representative inputs within etrecord, both of which are required for calculating numerical gap&quot;</span>
            <span class="p">)</span>
        <span class="c1"># The runtime_op_names will be used later to map runtime debug_handle to op_name</span>
        <span class="n">runtime_intermediate_outputs</span><span class="p">,</span> <span class="n">runtime_debug_handle_to_op_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_runtime_intermediate_outputs_and_op_names</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">map_runtime_aot_intermediate_outputs</span><span class="p">(</span>
            <span class="n">aot_intermediate_outputs</span><span class="p">,</span> <span class="n">runtime_intermediate_outputs</span>
        <span class="p">)</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;MSE&quot;</span><span class="p">:</span>
            <span class="n">comparator</span> <span class="o">=</span> <span class="n">MSEComparator</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;L1&quot;</span><span class="p">:</span>
            <span class="n">comparator</span> <span class="o">=</span> <span class="n">L1Comparator</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;SNR&quot;</span><span class="p">:</span>
            <span class="n">comparator</span> <span class="o">=</span> <span class="n">SNRComparator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported distance metric </span><span class="si">{</span><span class="n">distance</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">aot_debug_handle</span><span class="p">,</span> <span class="n">aot_intermediate_output</span><span class="p">),</span> <span class="p">(</span>
            <span class="n">runtime_debug_handle</span><span class="p">,</span>
            <span class="n">runtime_intermediate_output</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">aot_intermediate_output</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">runtime_intermediate_output</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># If aot outputs length is &gt; 1 then comparison fails since we dont really have</span>
            <span class="c1"># any instances where runtime intermediate output is a tuple or list</span>
            <span class="c1"># This does not happen when edge dialect program is reference for comparison</span>
            <span class="c1"># but happens in aten graph where ops like unbind remain undecomposed</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">aot_intermediate_output</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">aot_intermediate_output</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;aot_ops&quot;</span><span class="p">:</span> <span class="n">find_op_names</span><span class="p">(</span>
                        <span class="n">aot_debug_handle</span><span class="p">,</span> <span class="n">aot_debug_handle_to_op_names</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;aot_intermediate_output&quot;</span><span class="p">:</span> <span class="n">aot_intermediate_output</span><span class="p">,</span>
                    <span class="s2">&quot;runtime_ops&quot;</span><span class="p">:</span> <span class="n">find_op_names</span><span class="p">(</span>
                        <span class="n">runtime_debug_handle</span><span class="p">,</span> <span class="n">runtime_debug_handle_to_op_names</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;runtime_intermediate_output&quot;</span><span class="p">:</span> <span class="n">runtime_intermediate_output</span><span class="p">,</span>
                    <span class="s2">&quot;gap&quot;</span><span class="p">:</span> <span class="n">compare_intermediate_outputs</span><span class="p">(</span>
                        <span class="n">aot_intermediate_output</span><span class="p">,</span> <span class="n">runtime_intermediate_output</span><span class="p">,</span> <span class="n">comparator</span>
                    <span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</pre></div>

                </article>
              
  </article>
  
              
              
                <footer class="bd-footer-article">
                  <div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item">
<div class="feedback">
  
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-behavior="tutorial-rating" data-count="1" data-value="1">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="2" data-value="2">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="3" data-value="3">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="4" data-value="4">★</span>
        
        <span class="star" data-behavior="tutorial-rating" data-count="5" data-value="5">★</span>
        
    </div>
</div>

  <div class="feedback-send">
    <button class="feedback-btn"
            onclick="openGitHubIssue()"
            data-bs-title="Create a GitHub Issue"
            data-bs-placement="bottom"
            data-bs-toggle="tooltip"
            data-gtm="feedback-btn-click">Send Feedback
    </button>
  </div>
</div>

<div class="prev-next-area">
</div>

<div class="footer-info">
  <p class="copyright">
    
  </p>

  <p class="theme-version">
    Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
  </p>
</div>
</div>
  
</div>
                </footer>
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  

<div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
  <div class="container">
    <div class="row">
      <div class="col-md-4">
        <h2>Docs</h2>
        <p>Access comprehensive developer documentation for PyTorch</p>
        <a class="with-right-arrow" href="https://docs.pytorch.org/docs/stable/index.html">View Docs</a>
      </div>

      <div class="col-md-4">
        <h2>Tutorials</h2>
        <p>Get in-depth tutorials for beginners and advanced developers</p>
        <a class="with-right-arrow" href="https://docs.pytorch.org/tutorials">View Tutorials</a>
      </div>

      <div class="col-md-4">
        <h2>Resources</h2>
        <p>Find development resources and get your questions answered</p>
        <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
      </div>
    </div>
  </div>
</div>




<footer class="site-footer">

  <div class="container footer-container">

    <div class="newsletter" id="newsletter">

      <p class="newsletter__title is-style-max-width-800"><strong>Stay in touch</strong> for updates, event info, and
        the latest news</p>


      <script charset="utf-8" type="text/javascript" src="//js.hsforms.net/forms/embed/v2.js"></script>
      <script>
        hbspt.forms.create({
          region: "na1",
          portalId: "8112310",
          formId: "2fb2231c-000b-4ec5-88a0-1ab242549c9e"
        });
      </script>


      <p class="newsletter__privacy">By submitting this form, I consent to receive marketing emails from the LF and its
        projects regarding their events, training, research, developments, and related announcements. I understand that
        I can unsubscribe at any time using the links in the footers of the emails I receive. <a
          href="https://www.linuxfoundation.org/privacy/">Privacy Policy</a>.</p>

    </div>

    <div class="lf-grid">
      <ul class="social-links">
        <li><a href="https://www.facebook.com/pytorch" target="_blank" title="PyTorch on Facebook">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="-0.51 -0.26 26.45 26.45" aria-label="Facebook">
              <path fill="currentColor"
                d="M25.497 13.075c0-2.45-.698-4.848-2.011-6.911a12.765 12.765 0 0 0-5.398-4.73A12.671 12.671 0 0 0 11.008.38a12.705 12.705 0 0 0-6.529 2.95A12.827 12.827 0 0 0 .563 9.358a12.896 12.896 0 0 0-.07 7.201 12.831 12.831 0 0 0 3.801 6.103 12.709 12.709 0 0 0 6.471 3.078v-8.957H7.53v-3.708h3.235v-2.824c0-3.213 1.903-4.988 4.813-4.988.956.014 1.909.097 2.852.25V8.67h-1.607a1.83 1.83 0 0 0-1.518.497 1.854 1.854 0 0 0-.561 1.505v2.404h3.535l-.563 3.708h-2.97v8.957a12.725 12.725 0 0 0 7.697-4.337 12.87 12.87 0 0 0 3.054-8.328z" />
            </svg>
          </a></li>
        <li><a href="https://twitter.com/pytorch" target="_blank" title="PyTorch on X">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 300 300" aria-label="X">
              <path fill="currentColor"
                d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66" />
            </svg>
          </a></li>
        <li><a href="https://www.youtube.com/pytorch" target="_blank" title="PyTorch on YouTube">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0.21 0.27 34.45 25.07" aria-label="YouTube">
              <path fill="currentColor"
                d="M33.729 6.084s-.327-2.33-1.317-3.356a4.691 4.691 0 0 0-3.32-1.432c-4.634-.34-11.589-.34-11.589-.34h-.014s-6.954 0-11.59.342a4.692 4.692 0 0 0-3.32 1.432c-.993 1.025-1.315 3.354-1.315 3.354a52.189 52.189 0 0 0-.331 5.473v2.566c.014 1.829.125 3.656.331 5.472 0 0 .322 2.33 1.316 3.36 1.26 1.345 2.916 1.3 3.653 1.445 2.65.26 11.263.34 11.263.34s6.96-.01 11.597-.353a4.691 4.691 0 0 0 3.32-1.432c.993-1.026 1.316-3.356 1.316-3.356.206-1.817.316-3.644.33-5.473v-2.57a52.26 52.26 0 0 0-.33-5.472zM14.076 17.232V7.729l8.951 4.768-8.95 4.735z" />
            </svg>
          </a></li>
        <li><a href="https://www.linkedin.com/company/pytorch" target="_blank" title="PyTorch on LinkedIn">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="-10.23 -10.23 531.96 531.96" aria-label="LinkedIn">
              <rect width="512" height="512" rx="0" fill="currentColor" />
              <circle fill="#000" cx="142" cy="138" r="37" />
              <path stroke="#000" stroke-width="66" d="M244 194v198M142 194v198" />
              <path fill="#000"
                d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32" />
            </svg>
          </a></li>
        <li><a href="https://pytorch.slack.com" target="_blank" title="PyTorch Slack">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0.16 -0.03 21.19 21.19" aria-label="Slack">
              <path fill="currentColor"
                d="M4.896 13.27a2.147 2.147 0 0 1-2.141 2.142A2.147 2.147 0 0 1 .613 13.27c0-1.178.963-2.141 2.142-2.141h2.141v2.141zm1.08 0c0-1.178.962-2.141 2.141-2.141s2.142.963 2.142 2.141v5.363a2.147 2.147 0 0 1-2.142 2.141 2.147 2.147 0 0 1-2.141-2.142V13.27zm2.141-8.6a2.147 2.147 0 0 1-2.141-2.14c0-1.18.962-2.142 2.141-2.142s2.142.963 2.142 2.141v2.142H8.117zm0 1.08c1.179 0 2.141.962 2.141 2.141a2.147 2.147 0 0 1-2.141 2.142H2.755A2.147 2.147 0 0 1 .613 7.89c0-1.179.963-2.141 2.142-2.141h5.362zm8.599 2.141c0-1.179.963-2.141 2.141-2.141 1.179 0 2.143.962 2.143 2.14a2.147 2.147 0 0 1-2.142 2.142h-2.141V7.89zm-1.08 0a2.147 2.147 0 0 1-2.141 2.142 2.147 2.147 0 0 1-2.141-2.142V2.53c0-1.178.962-2.141 2.141-2.141s2.142.963 2.142 2.141v5.362zm-2.141 8.6c1.179 0 2.142.962 2.142 2.14a2.147 2.147 0 0 1-2.142 2.142 2.147 2.147 0 0 1-2.141-2.141V16.49h2.141zm0-1.08a2.147 2.147 0 0 1-2.141-2.141c0-1.179.962-2.142 2.141-2.142h5.362c1.179 0 2.142.963 2.142 2.142a2.147 2.147 0 0 1-2.142 2.142h-5.362z">
              </path>
            </svg>
          </a></li>
        <li><a href="https://pytorch.org/wechat" title="PyTorch on WeChat">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0.14 -0.17 38.02 33.02" aria-label="WeChat">
              <path fill="currentColor"
                d="M26.289 10.976a12.972 12.972 0 0 0-8.742 3.53 10.386 10.386 0 0 0-3.224 8.795c-1.326-.164-2.535-.345-3.75-.448a2.332 2.332 0 0 0-1.273.216c-1.18.666-2.311 1.418-3.652 2.255.246-1.112.405-2.087.687-3.024a1.15 1.15 0 0 0-.523-1.52C1.737 17.902.02 13.601 1.307 9.165c1.189-4.1 4.11-6.587 8.077-7.884A13.54 13.54 0 0 1 24.18 5.617a10.135 10.135 0 0 1 2.109 5.359zM10.668 9.594a1.564 1.564 0 0 0-2.095-1.472 1.52 1.52 0 0 0-.895 1.964 1.502 1.502 0 0 0 1.391.966 1.545 1.545 0 0 0 1.598-1.46v.002zm8.15-1.566a1.567 1.567 0 0 0-1.528 1.543 1.528 1.528 0 0 0 1.571 1.492 1.52 1.52 0 0 0 1.375-2.117 1.518 1.518 0 0 0-1.415-.919l-.003.001z">
              </path>
              <path fill="currentColor"
                d="M33.914 32.137c-1.075-.478-2.062-1.196-3.11-1.306-1.049-.11-2.145.494-3.24.605a10.821 10.821 0 0 1-8.781-2.864c-4.682-4.33-4.013-10.97 1.403-14.518 4.811-3.154 11.874-2.102 15.268 2.273a8.671 8.671 0 0 1-1.002 12.095c-1.046.929-1.422 1.693-.751 2.917.102.257.174.525.213.798zM21.68 20.292a1.264 1.264 0 1 0 .01-2.528 1.264 1.264 0 0 0-.01 2.528zm7.887-2.526a1.266 1.266 0 0 0-1.256 1.21 1.247 1.247 0 1 0 1.256-1.21z">
              </path>
            </svg>
          </a></li>
      </ul>
    </div>
    
    <div class="privacy-policy">
      <div class="copyright">
      
        <p>
          &copy; PyTorch. Copyright © The Linux Foundation®. All rights reserved. The Linux Foundation has registered
          trademarks and uses trademarks. For more information, including terms of use, privacy policy, and trademark
          usage, please see our <a href="https://www.linuxfoundation.org/legal/policies">Policies</a> page. <a
            href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a>. <a
            href="http://www.linuxfoundation.org/privacy">Privacy Policy</a>.
        </p>
        
      </div>
    </div>


  </div>
</footer>

<div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../../_static/img/pytorch-x.svg">
  </div>
</div>
  
  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, ExecuTorch.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  <script type="application/ld+json">
    {
       "@context": "https://schema.org",
       "@type": "Article",
       "name": "executorch.devtools.inspector._inspector",
       "headline": "executorch.devtools.inspector._inspector",
       "description": "PyTorch Documentation. Explore PyTorch, an open-source machine learning library that accelerates the path from research prototyping to production deployment. Discover tutorials, API references, and guides to help you build and deploy deep learning models efficiently.",
       "url": "/_modules/executorch/devtools/inspector/_inspector.html",
       "articleBody": "Source code for executorch.devtools.inspector._inspector # Copyright (c) Meta Platforms, Inc. and affiliates. # All rights reserved. # # This source code is licensed under the BSD-style license found in the # LICENSE file in the root directory of this source tree. # pyre-unsafe import dataclasses import logging import sys import warnings from collections import defaultdict, OrderedDict from dataclasses import dataclass from functools import cached_property from typing import ( Any, Callable, Dict, IO, List, Mapping, Optional, Sequence, Tuple, TypeAlias, TypedDict, Union, ) import executorch.devtools.etdump.schema_flatcc as flatcc import numpy as np import pandas as pd from executorch.devtools.debug_format.et_schema import OperatorGraph, OperatorNode from executorch.devtools.etdump.schema_flatcc import ( DebugEvent, ETDumpFlatCC, ProfileEvent, ) from executorch.devtools.etrecord import ETRecord, parse_etrecord from executorch.devtools.inspector._inspector_utils import ( calculate_time_scale_factor, compare_intermediate_outputs, create_debug_handle_to_op_node_mapping, DebugHandle, display_or_print_df, EDGE_DIALECT_GRAPH_KEY, EXCLUDED_COLUMNS_WHEN_PRINTING, EXCLUDED_EVENTS_FOR_INTERMEDIATE_OUTPUT, EXCLUDED_EVENTS_WHEN_PRINTING, find_op_names, find_populated_event, FORWARD, gen_etdump_object, gen_graphs_from_etrecord, get_aot_debug_handle_to_op_name_mapping, inflate_runtime_output, is_debug_output, is_inference_output_equal, map_runtime_aot_intermediate_outputs, merge_runtime_overlapping_debug_handles, ProgramOutput, propagate_back_debug_handle, RESERVED_FRAMEWORK_EVENT_NAMES, TimeScale, verify_debug_data_equivalence, ) from executorch.devtools.inspector._intermediate_output_capturer import ( IntermediateOutputCapturer, ) from executorch.devtools.inspector.numerical_comparator import ( L1Comparator, MSEComparator, SNRComparator, ) from executorch.exir import ExportedProgram log: logging.Logger = logging.getLogger(__name__) # Signature of an InstructionEvent @dataclass(frozen=True, order=True) class InstructionEventSignature: instruction_id: int chain_index: int delegate_id: Optional[int] = None delegate_id_str: Optional[str] = None # Aggregated Runtime Events for a single instruction @dataclass class InstructionEvent: signature: InstructionEventSignature profile_events: Optional[List[ProfileEvent]] = None debug_events: Optional[List[DebugEvent]] = None @staticmethod def gen_from_events(run_events: List[flatcc.Event]) -\u003e List[\"InstructionEvent\"]: \"\"\" Given a list of events from a run in ETDump, collate the ProfileEvent and DebugEvents by instruction id and return a list of InstructionEvents constructed from collated events (ignoring run_output events) \"\"\" instruction_events: Dict[InstructionEventSignature, InstructionEvent] = ( OrderedDict() ) for event in run_events: # Find the event that was logged populated_event: Union[DebugEvent, ProfileEvent] = find_populated_event( event ) # Get existing InstructionEvent or insert a new one signature = InstructionEventSignature( instruction_id=populated_event.instruction_id, chain_index=populated_event.chain_index, delegate_id=populated_event.delegate_debug_id_int, delegate_id_str=populated_event.delegate_debug_id_str, ) instruction_event = instruction_events.setdefault( signature, InstructionEvent(signature=signature) ) # Update InstructionEvent based on event type if isinstance(populated_event, ProfileEvent): if instruction_event.profile_events is None: instruction_event.profile_events = [] instruction_event.profile_events.append(populated_event) elif isinstance(populated_event, DebugEvent): # Ignore run_output events if not is_debug_output(populated_event.debug_entry): if instruction_event.debug_events is None: instruction_event.debug_events = [] instruction_event.debug_events.append(populated_event) return list(instruction_events.values()) # Signature of a ProfileEvent @dataclass(frozen=True, order=True) class ProfileEventSignature: name: str instruction_id: Optional[int] delegate_id: Optional[int] = None delegate_id_str: Optional[str] = None @staticmethod def _gen_from_event(event: ProfileEvent) -\u003e \"ProfileEventSignature\": \"\"\" Given a ProfileEvent, extract the fields into a signature ProfileEvents from ETDump default to \"\" and -1 when the field is not populated The Signature will convert these back to the intended None value \"\"\" return ProfileEventSignature( event.name or \"\", event.instruction_id if event.instruction_id != -1 else None, event.delegate_debug_id_int if event.delegate_debug_id_int != -1 else None, event.delegate_debug_id_str if event.delegate_debug_id_str != \"\" else None, ) # Signature of a DebugEvent @dataclass(frozen=True, order=True) class DebugEventSignature: name: str = \"\" instruction_id: Optional[int] = -1 delegate_id: Optional[int] = None delegate_id_str: Optional[str] = None @staticmethod def _gen_from_event(event: DebugEvent) -\u003e \"DebugEventSignature\": \"\"\" Given a DebugEvent, extract the fields into a signature DebugEvents from ETDump default to \"\" and -1 when the field is not populated The Signature will convert these back to the intended None value \"\"\" return DebugEventSignature( event.name or \"\", event.instruction_id if event.instruction_id != -1 else None, event.delegate_debug_id_int if event.delegate_debug_id_int != -1 else None, event.delegate_debug_id_str if event.delegate_debug_id_str != \"\" else None, ) # Signature of an Event inside of a Run @dataclass(frozen=True, order=True) class EventSignature: \"\"\" Note that (profile_event_signature, debug_event_signature) are sufficient signature identifiers. instruction_id is extracted from the signatures (equivalent in both) and surfaced for convenience \"\"\" instruction_id: int profile_event_signature: Optional[ProfileEventSignature] = None debug_event_signature: Optional[DebugEventSignature] = None @staticmethod def gen_from_instruction_event( instruction_event: InstructionEvent, ) -\u003e List[Tuple[\"EventSignature\", InstructionEvent]]: \"\"\" Construct EventSignatures from the given InstructionEvent and return tuples of (1) EventSignature and (2) related subset InstructionEvent \"\"\" # Generate the DebugEventSignature debug_events = instruction_event.debug_events debug_signature = ( DebugEventSignature._gen_from_event(debug_events[0]) if debug_events is not None and len(debug_events) \u003e 0 else None ) # If no ProfileEvents, return a singleton EventSignature if (profile_events := instruction_event.profile_events) is None: return [ ( EventSignature( instruction_id=instruction_event.signature.instruction_id, debug_event_signature=debug_signature, ), instruction_event, ) ] # Generate the ProfileEventSignature return [ ( EventSignature( instruction_id=instruction_event.signature.instruction_id, profile_event_signature=ProfileEventSignature._gen_from_event( profile_event ), debug_event_signature=debug_signature, ), dataclasses.replace(instruction_event, profile_events=[profile_event]), ) for profile_event in profile_events ] # Signature of a Run @dataclass(frozen=True, order=True) class RunSignature: \"\"\" Args: name: Name of the run events: List of EventSignatures that correspond to the run bundled_input_index: Index of the bundled input used to generate the debug output \"\"\" name: str events: Optional[Tuple[EventSignature]] = None bundled_input_index: Optional[int] = None # Typing for mapping Event.delegate_debug_identifiers to debug_handle(s) DelegateIdentifierDebugHandleMap: TypeAlias = Union[ Mapping[int, DebugHandle], Mapping[str, DebugHandle] ] # Typing for Dict containig delegate metadata DelegateMetadata = TypedDict( \"DelegateMetadata\", {\"name\": str, \"delegate_map\": DelegateIdentifierDebugHandleMap}, ) @dataclass class PerfData: def __init__(self, raw: List[float]): self.raw: List[float] = raw @property def p10(self) -\u003e float: return np.percentile(self.raw, 10) @property def p50(self) -\u003e float: return np.percentile(self.raw, 50) @property def p90(self) -\u003e float: return np.percentile(self.raw, 90) @property def avg(self) -\u003e float: return np.mean(self.raw) @property def min(self) -\u003e float: return min(self.raw) @property def max(self) -\u003e float: return max(self.raw) [docs] @dataclass class Event: \"\"\" An Event corresponds to an operator instance with perf data retrieved from the runtime and other metadata from `ETRecord`. Args: name: Name of the profiling `Event`, empty if no profiling event. perf_data: Performance data associated with the event retrived from the runtime (available attributes: p10, p50, p90, avg, min and max). op_type: List of op types corresponding to the event. delegate_debug_identifier: Supplemental identifier used in combination with instruction id. debug_handles: Debug handles in the model graph to which this event is correlated. num_outputs: Indicates the number of outputs generated by the node. Right now only used for call_delegate nodes that output more than one tensor. stack_trace: A dictionary mapping the name of each associated op to its stack trace. module_hierarchy: A dictionary mapping the name of each associated op to its module hierarchy. is_delegated_op: Whether or not the event was delegated. delegate_backend_name: Name of the backend this event was delegated to. _delegate_debug_metadatas: A list of raw delegate debug metadata in string, one for each profile event. Available parsed (if parser provided) as Event.delegate_debug_metadatas Available as Event.raw_delegate_debug_metadatas debug_data: A list containing intermediate data collected. _instruction_id: Instruction Identifier for Symbolication _delegate_metadata_parser: Optional Parser for _delegate_debug_metadatas \"\"\" name: str perf_data: Optional[PerfData] = None op_types: List[str] = dataclasses.field(default_factory=list) delegate_debug_identifier: Optional[Union[int, str]] = None debug_handles: Optional[Union[int, Sequence[int]]] = None num_outputs: int = 1 stack_traces: Dict[str, str] = dataclasses.field(default_factory=dict) module_hierarchy: Dict[str, Dict] = dataclasses.field(default_factory=dict) is_delegated_op: Optional[bool] = None delegate_backend_name: Optional[str] = None _delegate_debug_metadatas: List[str] = dataclasses.field(default_factory=list) debug_data: ProgramOutput = dataclasses.field(default_factory=list) _instruction_id: Optional[int] = None _delegate_metadata_parser: Optional[Callable[[List[str]], Dict[str, Any]]] = None _delegate_time_scale_converter: Optional[ Callable[[Union[int, str], Union[int, float]], Union[int, float]] ] = None _start_time: Optional[List[Union[int, float]]] = None @cached_property def delegate_debug_metadatas(self) -\u003e Union[List[str], Dict[str, Any]]: \"\"\" Returns the parsed _delegate_debug_metadatas if a parser is available Otherwise returns the raw _delegate_debug_metadatas \"\"\" if not self.is_delegated_op or self._delegate_metadata_parser is None: return self._delegate_debug_metadatas return self._delegate_metadata_parser(self._delegate_debug_metadatas) @property def raw_delegate_debug_metadatas(self) -\u003e List[str]: \"\"\" Return the raw unparsed _delegate_debug_metadatas \"\"\" return self._delegate_debug_metadatas @property def start_time(self) -\u003e Optional[List[Union[int, float]]]: \"\"\" Returns the start time of the event. \"\"\" return self._start_time def to_dataframe(self, _units=\"\") -\u003e pd.DataFrame: \"\"\" Convert the Event into a pandas DataFrame Args: None Returns: A pandas DataFrame with the Event data \"\"\" event_dict = self.asdict(_units=_units) return pd.DataFrame(event_dict) # Override the default implementation of dataclass.asdict to handle null perf data def asdict(self, _units=\"\") -\u003e dict: \"\"\" Convert the Event into a dict Args: None Returns: A dict with the Event data \"\"\" def truncated_list(long_list: List[str]) -\u003e str: return f\"[\u0027{long_list[0]}\u0027, \u0027{long_list[1]}\u0027 ... \u0027{long_list[-1]}\u0027] ({len(long_list)} total)\" return { \"event_name\": self.name, \"raw\": [self.perf_data.raw if self.perf_data else None], \"p10\" + _units: self.perf_data.p10 if self.perf_data else None, \"p50\" + _units: self.perf_data.p50 if self.perf_data else None, \"p90\" + _units: self.perf_data.p90 if self.perf_data else None, \"avg\" + _units: self.perf_data.avg if self.perf_data else None, \"min\" + _units: self.perf_data.min if self.perf_data else None, \"max\" + _units: self.perf_data.max if self.perf_data else None, \"op_types\": [ ( self.op_types if len(self.op_types) \u003c 5 else truncated_list(self.op_types) ) ], \"delegate_debug_identifier\": self.delegate_debug_identifier, \"stack_traces\": [self.stack_traces], \"module_hierarchy\": [self.module_hierarchy], \"is_delegated_op\": self.is_delegated_op, \"delegate_backend_name\": self.delegate_backend_name, \"debug_data\": [self.debug_data], \"start_time\": [self._start_time], } @staticmethod def _gen_from_inference_events( signature: EventSignature, events: List[InstructionEvent], scale_factor: float = 1.0, output_buffer: Optional[bytes] = None, delegate_metadata_parser: Optional[ Callable[[List[str]], Dict[str, Any]] ] = None, delegate_time_scale_converter: Optional[ Callable[[Union[int, str], Union[int, float]], Union[int, float]] ] = None, ) -\u003e \"Event\": \"\"\" Given an EventSignature and a list of Events with that signature, return an Event object matching the EventSignature, with perf_data populated from the list of ProfileEvents and debug_data populated from the list of DebugEvents. An optional inverse scale factor can be provided to adjust the event timestamps An optional buffer can be provided to inflate etdump references An optional delegate_metadata_parser can be provided to parse the delegate metadata \"\"\" profile_event_signature = signature.profile_event_signature debug_event_signature = signature.debug_event_signature # Event is gradually populated in this function ret_event: Event = Event( name=\"\", _instruction_id=signature.instruction_id, _delegate_metadata_parser=delegate_metadata_parser, _delegate_time_scale_converter=delegate_time_scale_converter, ) # Populate fields from profile events Event._populate_profiling_related_fields( ret_event, profile_event_signature, events, scale_factor ) # Populate fields from debug events Event._populate_debugging_related_fields( ret_event, debug_event_signature, events, output_buffer ) return ret_event @staticmethod def _calculate_elapsed_time(start_time, end_time): # We\u0027re assuming if there\u0027s a wraparound in the time values, then # the time representation of that platform only contains 32 bits. # This should be fine for now, but ideally we should source the max # time value from the platform using etdump. max_uint32 = 2**32 - 1 if start_time \u003e end_time: if (start_time \u003e max_uint32) or (end_time \u003e max_uint32): raise ValueError( f\"Expected start_time ({start_time}) and end_time ({end_time}) to be less than {max_uint32} for cases where there is wrap-around of time values.\" ) # Handle wraparound elapsed_time = (max_uint32 - start_time) + end_time else: # Normal case elapsed_time = end_time - start_time return elapsed_time @staticmethod def _populate_event_signature_fields( ret_event: \"Event\", event_signature: Optional[Union[ProfileEventSignature, DebugEventSignature]], ) -\u003e None: \"\"\" Given a partially constructed Event, populate the fields related to the profile event signature or debug event signature Fields Updated: name delegate_debug_identifier is_delegated_op \"\"\" # TODO: T201347372 Push the None check to ealier in the stack. if event_signature is not None: if event_signature.delegate_id is not None: # 0 is a valid value delegate_debug_identifier = event_signature.delegate_id else: delegate_debug_identifier = event_signature.delegate_id_str or None # Use the delegate identifier as the event name if delegated is_delegated_op = delegate_debug_identifier is not None name = ( event_signature.name if not is_delegated_op else str(delegate_debug_identifier) ) # Update fields # This is for older version of etdump that doesn\u0027t have the name field for debug events, we don\u0027t update the name field if name: ret_event.name = name ret_event.delegate_debug_identifier = delegate_debug_identifier ret_event.is_delegated_op = is_delegated_op @staticmethod def _populate_profiling_related_fields( ret_event: \"Event\", profile_event_signature: Optional[ProfileEventSignature], events: List[InstructionEvent], scale_factor: float, ) -\u003e None: \"\"\" Given a partially constructed Event, populate the fields related to the profile events Fields Updated: name delegate_debug_identifier is_delegated_op perf_data delegate_debug_metadatas \"\"\" # Fill out fields from profile event signature Event._populate_event_signature_fields(ret_event, profile_event_signature) # Fill out fields from profile event data = [] stime = [] delegate_debug_metadatas = [] for event in events: if (profile_events := event.profile_events) is not None: if len(profile_events) != 1: raise ValueError( f\"Expected exactly one profile event per InstructionEvent when generating Inspector Event, but got {len(profile_events)}\" ) profile_event = profile_events[0] # Scale factor should only be applied to non-delegated ops if ( ret_event.is_delegated_op and (convert_time_scale := ret_event._delegate_time_scale_converter) is not None ): scaled_time = Event._calculate_elapsed_time( convert_time_scale(ret_event.name, profile_event.start_time), convert_time_scale(ret_event.name, profile_event.end_time), ) # If it\u0027s not a delegated op then we can just use the raw time values # and then scale them according to the scale factor that was passed in. elif not ret_event.is_delegated_op: scaled_time = ( float( Event._calculate_elapsed_time( profile_event.start_time, profile_event.end_time ) ) / scale_factor ) # If there was no scale factor passed in just take a difference of the # end and start times. else: scaled_time = float( Event._calculate_elapsed_time( profile_event.start_time, profile_event.end_time ) ) data.append(scaled_time) stime.append(profile_event.start_time) delegate_debug_metadatas.append( profile_event.delegate_debug_metadata if profile_event.delegate_debug_metadata else \"\" ) # Update fields if len(data) \u003e 0: ret_event.perf_data = PerfData(data) if any(delegate_debug_metadatas): ret_event._delegate_debug_metadatas = delegate_debug_metadatas # add _start_time to the event if len(stime) \u003e 0: ret_event._start_time = stime @staticmethod def _populate_debugging_related_fields( ret_event: \"Event\", debug_event_signature: Optional[DebugEventSignature], events: List[InstructionEvent], output_buffer: Optional[bytes] = None, ) -\u003e None: \"\"\" Given a partially constructed Event, populate the fields related to the debug events Fields Updated: name delegate_debug_identifier is_delegated_op debug_data \"\"\" # Fill out fields from debug event signature Event._populate_event_signature_fields(ret_event, debug_event_signature) debug_data: List[flatcc.Value] = [] for event in events: if (debug_events := event.debug_events) is None: continue # Populate on the first iteration only, then verify equivalence for others if len(debug_data) == 0: debug_data = [debug_event.debug_entry for debug_event in debug_events] else: for debug_event, value in zip(debug_events, debug_data): v1 = inflate_runtime_output(debug_event.debug_entry, output_buffer) v2 = inflate_runtime_output(value, output_buffer) assert is_inference_output_equal( v1, v2 ), \"\"\"Corresponding debug events in multiple iterations of the model must have the same debug entry values. This is not the case for the intermediate data present in this ETDump and indicates potential issues with the model/runtime.\"\"\" ret_event.debug_data = [ inflate_runtime_output(debug_value, output_buffer) for debug_value in debug_data ] def _associate_with_op_graph_nodes( self, debug_handle_to_op_node_map: Dict[int, List[OperatorNode]], ) -\u003e None: \"\"\" Helper function to populate the stack_traces, module_hierarchy and op_types attributes based on the debug handles of this event \"\"\" # Framework events aren\u0027t logically associated with any nodes if self.name in RESERVED_FRAMEWORK_EVENT_NAMES: return if (debug_handles := self.debug_handles) is None: return if isinstance(debug_handles, int): debug_handles = [debug_handles] for handle in debug_handles: nodes = debug_handle_to_op_node_map.get(handle, None) if nodes is None: continue for node in nodes: # Attach node metadata including stack traces, module hierarchy and op_types to this event if node is not None and (metadata := node.metadata) is not None: if node.name not in self.stack_traces: self.stack_traces[node.name] = metadata.get(\"stack_trace\") self.module_hierarchy[node.name] = metadata.get( \"nn_module_stack\" ) if node.op: # TODO: consider having this as a dict from node.name -\u003e node.op self.op_types += [node.op] [docs] @dataclass class EventBlock: r\"\"\" An `EventBlock` contains a collection of events associated with a particular profiling/debugging block retrieved from the runtime. Each `EventBlock` represents a pattern of execution. For example, model initiation and loading lives in a single `EventBlock`. If there\u0027s a control flow, each branch will be represented by a separate `EventBlock`. Args: name: Name of the profiling/debugging block. events: List of `Event`\\ s associated with the profiling/debugging block. bundled_input_idx: Index of the Bundled Input that this EventBlock corresponds to. run_output: Run output extracted from the encapsulated Events \"\"\" name: str events: List[Event] = dataclasses.field(default_factory=list) source_time_scale: TimeScale = TimeScale.NS target_time_scale: TimeScale = TimeScale.MS bundled_input_index: Optional[int] = None run_output: Optional[ProgramOutput] = None reference_output: Optional[ProgramOutput] = None def to_dataframe( self, include_units: bool = False, include_delegate_debug_data: bool = False ) -\u003e pd.DataFrame: \"\"\" Converts the EventBlock into a DataFrame with each row being an event instance Note: Rows that have an event_name = OPERATOR_CALL correspond to the perf of the previous operator + framework tax of making said operator call. Args: include_units: Whether headers should include units (default false) include_delegate_debug_data: Whether to show the delegate debug data Returns: A pandas DataFrame containing the data of each Event instance in this EventBlock. \"\"\" units = \" (\" + self.target_time_scale.value + \")\" if include_units else \"\" df = pd.concat([e.to_dataframe(units) for e in self.events], ignore_index=True) df.insert( 0, \"event_block_name\", np.asarray([self.name for _ in range(len(self.events))]), allow_duplicates=True, ) # Add Delegate Debug Metadata columns if include_delegate_debug_data: delegate_data = [] for event in self.events: if (metadata := event.delegate_debug_metadatas) is not None and len( metadata ) \u003e 0: if isinstance(metadata, list): delegate_data.append( pd.Series([metadata], index=[\"delegate_debug_metadata\"]) ) elif isinstance(metadata, dict): delegate_data.append(pd.Series(metadata)) else: raise ValueError( f\"Unexpected type for delegate_debug_metadata: {type(metadata)}\" ) else: delegate_data.append(pd.Series()) if any(not data.empty for data in delegate_data): df = pd.concat([df, pd.DataFrame(delegate_data)], axis=1) return df @staticmethod def _gen_from_etdump( etdump: ETDumpFlatCC, source_time_scale: TimeScale = TimeScale.NS, target_time_scale: TimeScale = TimeScale.MS, output_buffer: Optional[bytes] = None, delegate_metadata_parser: Optional[ Callable[[List[str]], Dict[str, Any]] ] = None, delegate_time_scale_converter: Optional[ Callable[[Union[int, str], Union[int, float]], Union[int, float]] ] = None, ) -\u003e List[\"EventBlock\"]: \"\"\" Given an etdump, generate a list of EventBlocks corresponding to the contents. An optional (inverse) scale factor can be provided to adjust the etdump timestamps associated with each EventBlocks An optional buffer to inflate etdump references An optional delegate metadata parser function to parse delegate profiling metadata \"\"\" # Map each RunSignatures to instances of its constituent events. # The value of the map is a GroupedRunInstance which contains: # (1) a map from each EventSignature to InstructionEvents with the signature # (2) the run output for this RunSignature @dataclass class GroupedRunInstances: events: OrderedDict[EventSignature, List[InstructionEvent]] run_output: ProgramOutput run_groups: Mapping[RunSignature, GroupedRunInstances] = defaultdict( lambda: GroupedRunInstances(OrderedDict(), []) ) # Collect all the run data for run in etdump.run_data: if (run_events := run.events) is None: continue # Collate the run_events into InstructionEvents instruction_events: List[InstructionEvent] = ( InstructionEvent.gen_from_events(run_events) ) # Map EventSignatures to the InstructionEvents event_signatures: Dict[EventSignature, InstructionEvent] = OrderedDict() for instruction_event in instruction_events: if ( instruction_event.debug_events is None and instruction_event.profile_events is None ): # Currently corresponds to run output continue generated_event_signatures: List[ Tuple[EventSignature, InstructionEvent] ] = EventSignature.gen_from_instruction_event(instruction_event) for ( event_signature, filtered_instruction_event, ) in generated_event_signatures: event_signatures[event_signature] = filtered_instruction_event # Create a RunSignature from the EventSignatures run_signature = RunSignature( name=run.name, events=tuple(event_signatures.keys()), bundled_input_index=run.bundled_input_index, ) # Update the Run Groups, indexed on the RunSignature run_signature_events: OrderedDict[ EventSignature, List[InstructionEvent] ] = run_groups[run_signature].events for event_signature, event in event_signatures.items(): run_signature_events.setdefault(event_signature, []).append(event) # Populate (or Verify if already populated) Run Outputs run_outputs: ProgramOutput = EventBlock._collect_run_outputs( run_events, output_buffer ) if len(existing_run_outputs := run_groups[run_signature].run_output) == 0: existing_run_outputs.extend(run_outputs) else: verify_debug_data_equivalence(existing_run_outputs, run_outputs) # Construct the EventBlocks event_blocks = [] scale_factor = calculate_time_scale_factor(source_time_scale, target_time_scale) for run_signature, grouped_run_instance in run_groups.items(): run_group: OrderedDict[EventSignature, List[InstructionEvent]] = ( grouped_run_instance.events ) run_outputs: ProgramOutput = grouped_run_instance.run_output # Construct the Events events: List[Event] = [ Event._gen_from_inference_events( signature, instruction_events, scale_factor, output_buffer, delegate_metadata_parser, delegate_time_scale_converter, ) for signature, instruction_events in run_group.items() ] # Add the EventBlock to the return list event_blocks.append( EventBlock( name=run_signature.name, events=events, source_time_scale=source_time_scale, target_time_scale=target_time_scale, bundled_input_index=run_signature.bundled_input_index, run_output=run_outputs, ) ) return event_blocks @staticmethod def _collect_run_outputs( events: List[flatcc.Event], output_buffer: Optional[bytes] = None ) -\u003e ProgramOutput: \"\"\" Given a list of events, search the events for ProgramOutputs (aka lists of InferenceOutputs) marked as run outputs \"\"\" output_events = [] for event in events: if event.debug_event is None: continue if event.debug_event.debug_entry is None: raise RuntimeError( \"Debug entry inside debug event should not be empty!\" ) if is_debug_output(event.debug_event.debug_entry): output_events += [event] return [ inflate_runtime_output(debug_event.debug_entry, output_buffer) for output_event in output_events if (debug_event := output_event.debug_event) is not None ] # TODO: Considering changing ETRecord deserialization logic to cast the ints in string format to actual ints def _gen_resolve_debug_handles( self, handle_map: Dict[str, List[int]], delegate_map: Optional[Dict[str, DelegateMetadata]] = None, instruction_id_to_num_outs_map: Dict[int, int] = None, ): \"\"\" Given mappings from instruction id to debug handles, populate the debug_handles field of all underlying events If the event is delegated, index with the instruction_id and delegate_debug_identifier to obtain the debug_handle via the delegate map \"\"\" for event in self.events: # Check if instruction_id is present in the event if event._instruction_id is None: continue # Check for the instruction_id in handle map if (instruction_id := str(event._instruction_id)) not in handle_map: continue num_outputs = 1 if instruction_id_to_num_outs_map is not None: num_outputs = instruction_id_to_num_outs_map.get(instruction_id, 1) event.num_outputs = num_outputs # For non-delegated event, handles are found in handle_map if (delegate_debug_id := event.delegate_debug_identifier) is None: event.debug_handles = handle_map[instruction_id] # DELEGATE_CALL is a special non-delegated event and benefits from having the name populated if ( event.name == \"DELEGATE_CALL\" and delegate_map is not None and (delegate_metadata := delegate_map.get(instruction_id)) is not None ): event.delegate_backend_name = delegate_metadata.get(\"name\", \"\") continue # Check that the delegated event has a corresponding mapping if ( delegate_map is None or (delegate_metadata := delegate_map.get(instruction_id)) is None ): event.debug_handles = handle_map[instruction_id] log.warning( f\" No delegate mapping found for delegate with instruction id {event._instruction_id}\" ) continue # For delegated events, handles are found via delegateMetadata event.delegate_backend_name = delegate_metadata.get(\"name\", \"\") delegate_metadata_delegate_map = delegate_metadata.get(\"delegate_map\") or {} # delegate_debug_id can be either int based or string based, therefore we need to check both debug_handles = delegate_metadata_delegate_map.get( delegate_debug_id # pyre-ignore ) if debug_handles is not None: event.debug_handles = debug_handles else: event.debug_handles = delegate_metadata_delegate_map.get( str(delegate_debug_id) # pyre-ignore ) for key, value in delegate_metadata_delegate_map.items(): if key in str(delegate_debug_id): event.debug_handles = value class Inspector: \"\"\" APIs for examining model architecture and performance stats. Public Attributes: event_blocks: List[\"EventBlocks\"]. Structured data from ETDump (correlated with ETRecord if provided). Private Attributes: _etrecord: Optional[ETRecord]. File under etrecord_path deserialized into an object. \"\"\" def __init__( self, etdump_path: Optional[str] = None, etdump_data: Optional[bytes] = None, etrecord: Optional[Union[ETRecord, str]] = None, source_time_scale: TimeScale = TimeScale.NS, target_time_scale: TimeScale = TimeScale.MS, debug_buffer_path: Optional[str] = None, delegate_metadata_parser: Optional[ Callable[[List[str]], Dict[str, Any]] ] = None, delegate_time_scale_converter: Optional[ Callable[[Union[int, str], Union[int, float]], Union[int, float]] ] = None, enable_module_hierarchy: bool = False, ) -\u003e None: r\"\"\" Initialize an `Inspector` instance with the underlying `EventBlock`\\ s populated with data from the provided ETDump path or binary, and optional ETRecord path. Args: etdump_path: Path to the ETDump file. Either this parameter or etdump_data should be provided. etdump_data: ETDump binary. Either this parameter or etdump_path should be provided. etrecord: Optional ETRecord object or path to the ETRecord file. source_time_scale: The time scale of the performance data retrieved from the runtime. The default time hook implentation in the runtime returns NS. target_time_scale: The target time scale to which the users want their performance data converted to. Defaults to MS. debug_buffer_path: Debug buffer file path that contains the debug data referenced by ETDump for intermediate and program outputs. delegate_metadata_parser: Optional function to parse delegate metadata from an Profiling Event. Expected signature of the function is: (delegate_metadata_list: List[bytes]) -\u003e Union[List[str], Dict[str, Any]] delegate_time_scale_converter: Optional function to convert the time scale of delegate profiling data. If not given, use the conversion ratio of target_time_scale/source_time_scale. enable_module_hierarchy: Enable submodules in the operator graph. Defaults to False. Returns: None \"\"\" if (source_time_scale == TimeScale.CYCLES) ^ ( target_time_scale == TimeScale.CYCLES ): raise RuntimeError( \"For TimeScale in cycles both the source and target time scale have to be in cycles.\" ) self._source_time_scale = source_time_scale self._target_time_scale = target_time_scale if delegate_time_scale_converter is None: scale_factor = calculate_time_scale_factor( source_time_scale, target_time_scale ) delegate_time_scale_converter = ( lambda event_name, input_time: input_time / scale_factor ) if etrecord is None: self._etrecord = None elif isinstance(etrecord, ETRecord): self._etrecord = etrecord elif isinstance(etrecord, str): self._etrecord = parse_etrecord(etrecord_path=etrecord) else: raise TypeError(\"Unsupported ETRecord type\") if (etdump_path is None) == (etdump_data is None): raise ValueError( \"Expecting exactly one of etdump_path or etdump_data to be specified.\" ) # Create EventBlocks from ETDump etdump = gen_etdump_object(etdump_path=etdump_path, etdump_data=etdump_data) if debug_buffer_path is not None: with open(debug_buffer_path, \"rb\") as f: output_buffer = f.read() else: output_buffer = None warnings.warn( \"Output Buffer not found. Tensor Debug Data will not be available.\", stacklevel=1, ) self.event_blocks = EventBlock._gen_from_etdump( etdump=etdump, source_time_scale=self._source_time_scale, target_time_scale=self._target_time_scale, output_buffer=output_buffer, delegate_metadata_parser=delegate_metadata_parser, delegate_time_scale_converter=delegate_time_scale_converter, ) # Connect ETRecord to EventBlocks self.op_graph_dict: Optional[Mapping[str, OperatorGraph]] = None # _consume_etrecord() will populate the _reference_outputs dict # Key str is method name; value is list of ProgramOutputs because of list of test cases self._reference_outputs: Dict[str, List[ProgramOutput]] = {} self._enable_module_hierarchy = enable_module_hierarchy self._consume_etrecord() def _consume_etrecord(self) -\u003e None: \"\"\" If an ETRecord is provided, connect it to the EventBlocks and populate the Event metadata. Steps: 1. Debug Handle Symbolification: For each Event, find the debug_handle counterparts using ETRecord\u0027s debug_handle_map and delegate_map 2. Event Metadata Association: For each Event, populate its metadata from OperatorGraph Nodes, generated from ETRecord. The debug_handle is used to identify the corresponding OperatorGraph Nodes. 3. Reference Outputs Extraction: If there\u0027re reference outputs saved in ETRecord, assign each reference output to the corresponding EventBlock based on the method name (currently assumes only \"forward\") and the bundled_input_index of the EventBlock. \"\"\" if self._etrecord is None: return # (1) Debug Handle Symbolification for event_block in self.event_blocks: event_block._gen_resolve_debug_handles( self._etrecord._debug_handle_map[FORWARD], ( self._etrecord._delegate_map[FORWARD] if self._etrecord._delegate_map is not None else None ), self._etrecord._instruction_id_to_num_outs_map[FORWARD], ) # (2) Event Metadata Association self.op_graph_dict = gen_graphs_from_etrecord( etrecord=self._etrecord, enable_module_hierarchy=self._enable_module_hierarchy, ) debug_handle_to_op_node_map = create_debug_handle_to_op_node_mapping( self.op_graph_dict[EDGE_DIALECT_GRAPH_KEY], ) for event_block in self.event_blocks: for event in event_block.events: event._associate_with_op_graph_nodes( debug_handle_to_op_node_map=debug_handle_to_op_node_map, ) # (3) Reference Outputs Extraction if self._etrecord._reference_outputs is not None: self._reference_outputs = self._etrecord._reference_outputs # Associate each reference output to the corresponding event block for event_block in self.event_blocks: index = event_block.bundled_input_index if index is not None: event_block.reference_output = self._reference_outputs[FORWARD][ index ] def _get_aot_intermediate_outputs_and_op_names( self, disable_debug_handle_valdiation: bool = False, ) -\u003e Tuple[Dict[DebugHandle, Any], Dict[DebugHandle, List[str]]]: \"\"\" Capture intermediate outputs only if _representative_inputs are provided when using bundled program to create the etrecord \"\"\" if self._etrecord._representative_inputs is None: return {}, {} export_program = None # Will use the exported program to extract intermediate output if and only if exported_program has been provided, and it is one of the ancestors of the edge_dialect_program if self._etrecord.exported_program and propagate_back_debug_handle( self._etrecord.exported_program, self._etrecord.export_graph_id, self._etrecord.edge_dialect_program, disable_debug_handle_valdiation, ): export_program = self._etrecord.exported_program else: log.warning( \"Either aten dialect exported program is not in ETRecord, or it is not one of the ancestors of current edge dialect program.\" \"Will fall back to use edge dialect program to extract intermediate output\", ) export_program = self._etrecord.edge_dialect_program graph_module = export_program.module() aot_debug_handle_to_op_name = get_aot_debug_handle_to_op_name_mapping( graph_module ) capturer = IntermediateOutputCapturer(graph_module) aot_intermediate_outputs = capturer.run_and_capture( self._etrecord._representative_inputs ) return aot_intermediate_outputs, aot_debug_handle_to_op_name # TODO: Make it more extensible to further merge overlapping debug handles def _get_runtime_intermediate_outputs_and_op_names( self, ) -\u003e Tuple[Dict[DebugHandle, Tuple[Any, int]], Dict[DebugHandle, List[str]]]: \"\"\" Retrieve the runtime intermediate outputs(debug handles and intermediate values mappings) from the event blocks, along with the corresponding debug handles and op names mapping. \"\"\" debug_handle_to_output = {} debug_handle_to_op_names = {} for event_block in self.event_blocks: for event in event_block.events: # Skip OPERATOR_CALL events to avoid double-counting and exclude framework tax if ( event.name in EXCLUDED_EVENTS_FOR_INTERMEDIATE_OUTPUT or not event.op_types ): continue # Normalize debug_handle to a tuple debug_handle = event.debug_handles if isinstance(debug_handle, int): debug_handle = (debug_handle,) else: debug_handle = tuple(debug_handle) current_entry = debug_handle_to_output.get( debug_handle, (-1, None, event.num_outputs) ) # When event has same debug_handle, only keep the one with the largest instruction id if event._instruction_id \u003e current_entry[0]: debug_handle_to_output[debug_handle] = ( event._instruction_id, event.debug_data, event.num_outputs, ) # TODO: One debug handle can be associated with multiple op names debug_handle_to_op_names[debug_handle] = [event.name] debug_handle_to_output = merge_runtime_overlapping_debug_handles( debug_handle_to_output ) return { k: (v[1], v[2]) for k, v in debug_handle_to_output.items() }, debug_handle_to_op_names def to_dataframe( self, include_units: bool = True, include_delegate_debug_data: bool = False, ) -\u003e pd.DataFrame: \"\"\" Args: include_units: Whether headers should include units (default true) include_delegate_debug_data: Whether to include delegate debug metadata (default false) Returns: Returns a pandas DataFrame of the Events in each EventBlock in the inspector, with each row representing an Event. \"\"\" df_list = [ event_block.to_dataframe( include_units=include_units, include_delegate_debug_data=include_delegate_debug_data, ) for event_block in self.event_blocks ] return pd.concat(df_list, ignore_index=True) def _prepare_dataframe( self, include_units: bool = True, include_delegate_debug_data: bool = False, ) -\u003e pd.DataFrame: \"\"\" Args: include_units: Whether headers should include units (default true) include_delegate_debug_data: Whether to include delegate debug metadata (default false) Returns: Returns a pandas DataFrame of the Events in each EventBlock in the inspector, with additional filtering. \"\"\" combined_df = self.to_dataframe(include_units, include_delegate_debug_data) # Filter out some columns and rows for better readability when printing filtered_column_df = combined_df.drop(columns=EXCLUDED_COLUMNS_WHEN_PRINTING) for filter_name in EXCLUDED_EVENTS_WHEN_PRINTING: filtered_column_df = filtered_column_df[ ~filtered_column_df[\"event_name\"].str.contains(filter_name) ] filtered_column_df.reset_index(drop=True, inplace=True) return filtered_column_df def print_data_tabular( self, file: IO[str] = sys.stdout, include_units: bool = True, include_delegate_debug_data: bool = False, ) -\u003e None: \"\"\" Displays the underlying EventBlocks in a structured tabular format, with each row representing an Event. Args: file: Which IO stream to print to. Defaults to stdout. Not used if this is in an IPython environment such as a Jupyter notebook. include_units: Whether headers should include units (default true) include_delegate_debug_data: Whether to include delegate debug metadata (default false) Returns: None \"\"\" df = self._prepare_dataframe(include_units, include_delegate_debug_data) display_or_print_df(df, file) def save_data_to_tsv( self, file: IO[str], include_units: bool = True, include_delegate_debug_data: bool = False, ) -\u003e None: \"\"\" Stores the underlying EventBlocks in tsv format to facilitate copy-paste into spreadsheets. Args: file: Which IO stream to print to. Do not use stdout, as tab separator is not preserved. include_units: Whether headers should include units (default true) include_delegate_debug_data: Whether to include delegate debug metadata (default false) Returns: None \"\"\" df = self._prepare_dataframe(include_units, include_delegate_debug_data) df.to_csv(file, sep=\"\\t\") # TODO: write unit test def find_total_for_module(self, module_name: str) -\u003e float: \"\"\" Returns the total average compute time of all operators within the specified module. Args: module_name: Name of the module to be aggregated against. Returns: Sum of the average compute time (in seconds) of all operators within the module with \"module_name\". \"\"\" total = 0.0 for block in self.event_blocks: for event in block.events: # Skip OPERATOR_CALL events to avoid double-counting and exclude framework tax if event.name == \"OPERATOR_CALL\": continue module_hierarchy = event.module_hierarchy.values() for hierarchy in module_hierarchy: if not hierarchy: continue found = any(module_name in key for key in hierarchy.keys()) if found: if event.perf_data is not None: total += event.perf_data.avg break return total def get_op_list( self, event_block: str, show_delegated_ops: Optional[bool] = True ) -\u003e Dict[str, List[Event]]: \"\"\" Return a map of op_types to Events of that op_type \"\"\" # TODO: implement return {} def write_tensorboard_artifact(self, path: str) -\u003e None: \"\"\" Write to the provided path, the artifacts required for visualization in TensorBoard \"\"\" # TODO: implement pass def get_exported_program( self, graph: Optional[str] = None ) -\u003e Optional[ExportedProgram]: \"\"\" Access helper for ETRecord, defaults to returning the Edge Dialect program. Args: graph: Optional name of the graph to access. If None, returns the Edge Dialect program. Returns: The ExportedProgram object of \"graph\". \"\"\" if self._etrecord is None: log.warning( \"Exported program is only available when a valid etrecord_path was provided at the time of Inspector construction\" ) return None return ( self._etrecord.edge_dialect_program if graph is None else self._etrecord.graph_map.get(graph) ) def calculate_numeric_gap( self, distance: str = \"MSE\", disable_debug_handle_valdiation: bool = False ): \"\"\" Compares logged intermediate outputs from the exported graph (in ETRecord) with runtime outputs (in ETDump) using a user-specific numerical comparator. If the exported graph is not supported, the function will fall back to use edge dialect graph. To use this function, you must first generate the ETRecord with representative inputs, and then create the Inspector instance with the ETRecord and ETDump. The Inspector can then compare the intermediate outputs from the AOT and the runtime. Args: distance: the metrics the inspector will use for gap calculation. Should be one of \"MSE\", \"L1\" and \"SNR\". disable_debug_handle_validation: Often when aten graph has symbolic shape nodes, and inbuilt ops like gt/lt etc., during re-export of such a graph \u0027from_node\u0027 information is lost from node.meta. As a result we loose connection between edge IR nodes and aten nodes for such ops. By default we validate that every edge IR node has corresponding node in aten IR, and when such validation fails numeric debugger falls back to edge IR as reference graph. This flag allows one to override such behavior and make best effort comparison. Returns: pd.DataFrame: A DataFrame listing corresponding operator intermediate outputs from both stages and their computed numerical gaps. \"\"\" aot_intermediate_outputs, aot_debug_handle_to_op_names = ( self._get_aot_intermediate_outputs_and_op_names( disable_debug_handle_valdiation ) ) if len(aot_intermediate_outputs) == 0 or len(aot_debug_handle_to_op_names) == 0: raise ValueError( \"Missing etrecord or missing representative inputs within etrecord, both of which are required for calculating numerical gap\" ) # The runtime_op_names will be used later to map runtime debug_handle to op_name runtime_intermediate_outputs, runtime_debug_handle_to_op_names = ( self._get_runtime_intermediate_outputs_and_op_names() ) mapping = map_runtime_aot_intermediate_outputs( aot_intermediate_outputs, runtime_intermediate_outputs ) metric = distance.strip().upper() if metric == \"MSE\": comparator = MSEComparator() elif metric == \"L1\": comparator = L1Comparator() elif metric == \"SNR\": comparator = SNRComparator() else: raise ValueError(f\"Unsupported distance metric {distance!r}\") rows = [] for (aot_debug_handle, aot_intermediate_output), ( runtime_debug_handle, runtime_intermediate_output, ) in mapping.items(): if aot_intermediate_output is None or runtime_intermediate_output is None: continue # If aot outputs length is \u003e 1 then comparison fails since we dont really have # any instances where runtime intermediate output is a tuple or list # This does not happen when edge dialect program is reference for comparison # but happens in aten graph where ops like unbind remain undecomposed if ( isinstance(aot_intermediate_output, Sequence) and len(aot_intermediate_output) \u003e 1 ): continue rows.append( { \"aot_ops\": find_op_names( aot_debug_handle, aot_debug_handle_to_op_names ), \"aot_intermediate_output\": aot_intermediate_output, \"runtime_ops\": find_op_names( runtime_debug_handle, runtime_debug_handle_to_op_names ), \"runtime_intermediate_output\": runtime_intermediate_output, \"gap\": compare_intermediate_outputs( aot_intermediate_output, runtime_intermediate_output, comparator ), } ) return pd.DataFrame(rows)",
       "author": {
         "@type": "Organization",
         "name": "PyTorch Contributors",
         "url": "https://pytorch.org"
       },
       "image": "../../../../_static/img/pytorch_seo.png",
       "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "/_modules/executorch/devtools/inspector/_inspector.html"
       },
       "datePublished": "2023-01-01T00:00:00Z",
       "dateModified": "2023-01-01T00:00:00Z"
     }
 </script>
  <script>
    // Tutorials Call to action event tracking
    $("[data-behavior='call-to-action-event']").on('click', function () {
      fbq('trackCustom', "Download", {
        tutorialTitle: $('h1:first').text(),
        downloadLink: this.href,
        tutorialLink: window.location.href,
        downloadTitle: $(this).attr("data-response")
      });
      if (typeof gtag === 'function') {
        gtag('event', 'click', {
          'event_category': $(this).attr("data-response"),
          'event_label': $("h1").first().text(),
          'tutorial_link': window.location.href
        });
      }
    });
  </script>
  
  </body>
</html>