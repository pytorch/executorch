include "scalar_type.fbs";

namespace etdump;

// Identifier of a valid executor schema.
file_identifier "ED00";
// Extension of written files.
file_extension "etdp";

table Null {}

table Tensor {
  scalar_type:executorch.ScalarType;
  sizes:[int];
  strides:[int];
  data: [ubyte];
}

table Int {
  int_val:long;
}

table Bool {
  bool_val:bool;
}

table Double {
  double_val:double;
}

table String {
  string_val:string;
}

union ValueType {
  Null,
  Int,
  Bool,
  Double,
  Tensor,
  String,
}

// This table is only necessary because flatbuffer can't support a list of 
// union elements directly, they need to be wrapped in a table.
table Value {
    val:ValueType;
}

// This table contains all the details that we store to debug an op executed in the
// runtime. Each entry here reprsents an op executed in the runtime during inference.
table DebugEvent {
  // If this event corresponds to an operator execution then this is the debug
  // handle that was generated by the compiler that will help us map back this
  // operator to the source code.
  debug_handle:ulong;
  
  // List of debug entries corresponding to this debug event. These could be
  // scalars, tensors etc.
  // The order of these entries is expected to be the same as the parameters 
  // that are passed into a operator.
  debug_entries:[Value];
}

// This table contains all the debugging events that were logged during a single
// run. These could be anything from a operator debug event to something more explicitly
// logged by the user for debugging.
table DebugBlock {
  // Name assigned to this debug block.
  name:string;
  
  // List of debug events corresponding to this debug block.
  debug_events:[DebugEvent];
}

// This table contains all the details we need to represent a profiling event that
// has occurred in the runtime. These could be an operator profiling event or something
// more generic like the total time taken to execute an inference loop.
table ProfileEvent {
  // Name assigned to this profiling event by the runtime. If it is an operator
  // call this will just be the name of the operator that was executed.
  name:string;
  
  // If this event corresponds to an operator execution then this is the debug
  // handle that was generated by the compiler that will help us map back this
  // operator to the source code.
  debug_handle:ulong;
  
  // Time at which this event started. Could be in units of time or CPU cycles.
  start_time:ulong;
  
  // Time at which this event ended. Could be in units of time or CPU cycles.
  end_time:ulong;
}

// All the details pertaining to an allocation done in the runtime. The main
// details that we care about currently are the allocator id (which directly maps
// to the allocators table in ProfileBlock) and the size of the allocation done from it.
table AllocationEvent {
  // Allocator id of the allocator from which this memory was allocated.
  allocator_id:uint;
  
  // Size of allocation in bytes.
  allocation_size:ulong;
}

// Representation of an ExecuTorch memory allocator that is used in the runtime.
table Allocator {
  // Name of the allocator.  
  name:string;
}

// Contains all the profiling events collected in a single run. These profiling
// events can be performance events represented by ProfilEvent or they could also
// be memory allocation events represented by AllocationEvent.
table ProfileBlock {  
  // Name assigned to this profiling block. 
  name:string;

  // List of allocators on which profiling was enabled in the runtime.
  allocators:[Allocator];

  // List of performance profiling events that were logged in the runtime.
  profile_events:[ProfileEvent];
  
  // List of memory allocations that were done across all the allocators.
  allocation_events:[AllocationEvent];
 
}

// This table contains the total set of debug and profiling data that was
// collected for a single run. It's not always necessary that the profiling
// data and debug data map 1:1.
table RunData {
  // List of debug data entries a single run.
  debug_blocks:[DebugBlock];

  // List of profiling data entries for a single run.
  profile_blocks:[ProfileBlock];
}

table ETDump {
  // Schema version.
  version:uint;
    
  // This is the base level abstraction. One entry here will correspond
  // to one run.
  run_data:[RunData];

}

root_type ETDump;
