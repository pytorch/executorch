# automatically generated by the FlatBuffers compiler, do not modify

# namespace: executorch_flatbuffer

from executorch.exir._serialize.generated import executorch_flatbuffer
import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from executorch.exir._serialize.generated.executorch_flatbuffer.BackendDelegateInlineData import BackendDelegateInlineData
from executorch.exir._serialize.generated.executorch_flatbuffer.Buffer import Buffer
from executorch.exir._serialize.generated.executorch_flatbuffer.DataSegment import DataSegment
from executorch.exir._serialize.generated.executorch_flatbuffer.ExecutionPlan import ExecutionPlan
from executorch.exir._serialize.generated.executorch_flatbuffer.NamedData import NamedData
from executorch.exir._serialize.generated.executorch_flatbuffer.SubsegmentOffsets import SubsegmentOffsets
from typing import Optional
np = import_numpy()

class Program(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Program()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsProgram(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ProgramBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Program
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Program
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # Program
    def ExecutionPlan(self, j: int) -> Optional[ExecutionPlan]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ExecutionPlan()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def ExecutionPlanLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def ExecutionPlanIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Program
    def ConstantBuffer(self, j: int) -> Optional[Buffer]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def ConstantBufferLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def ConstantBufferIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Program
    def BackendDelegateData(self, j: int) -> Optional[BackendDelegateInlineData]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = BackendDelegateInlineData()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def BackendDelegateDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def BackendDelegateDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Program
    def Segments(self, j: int) -> Optional[DataSegment]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = DataSegment()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def SegmentsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def SegmentsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Program
    def ConstantSegment(self) -> Optional[SubsegmentOffsets]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = SubsegmentOffsets()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def MutableDataSegments(self, j: int) -> Optional[SubsegmentOffsets]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SubsegmentOffsets()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def MutableDataSegmentsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def MutableDataSegmentsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Program
    def NamedData(self, j: int) -> Optional[NamedData]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = NamedData()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def NamedDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def NamedDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

def ProgramStart(builder: flatbuffers.Builder):
    builder.StartObject(8)

def Start(builder: flatbuffers.Builder):
    ProgramStart(builder)

def ProgramAddVersion(builder: flatbuffers.Builder, version: int):
    builder.PrependUint32Slot(0, version, 0)

def AddVersion(builder: flatbuffers.Builder, version: int):
    ProgramAddVersion(builder, version)

def ProgramAddExecutionPlan(builder: flatbuffers.Builder, executionPlan: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(executionPlan), 0)

def AddExecutionPlan(builder: flatbuffers.Builder, executionPlan: int):
    ProgramAddExecutionPlan(builder, executionPlan)

def ProgramStartExecutionPlanVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartExecutionPlanVector(builder, numElems: int) -> int:
    return ProgramStartExecutionPlanVector(builder, numElems)

def ProgramAddConstantBuffer(builder: flatbuffers.Builder, constantBuffer: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(constantBuffer), 0)

def AddConstantBuffer(builder: flatbuffers.Builder, constantBuffer: int):
    ProgramAddConstantBuffer(builder, constantBuffer)

def ProgramStartConstantBufferVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartConstantBufferVector(builder, numElems: int) -> int:
    return ProgramStartConstantBufferVector(builder, numElems)

def ProgramAddBackendDelegateData(builder: flatbuffers.Builder, backendDelegateData: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(backendDelegateData), 0)

def AddBackendDelegateData(builder: flatbuffers.Builder, backendDelegateData: int):
    ProgramAddBackendDelegateData(builder, backendDelegateData)

def ProgramStartBackendDelegateDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartBackendDelegateDataVector(builder, numElems: int) -> int:
    return ProgramStartBackendDelegateDataVector(builder, numElems)

def ProgramAddSegments(builder: flatbuffers.Builder, segments: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(segments), 0)

def AddSegments(builder: flatbuffers.Builder, segments: int):
    ProgramAddSegments(builder, segments)

def ProgramStartSegmentsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartSegmentsVector(builder, numElems: int) -> int:
    return ProgramStartSegmentsVector(builder, numElems)

def ProgramAddConstantSegment(builder: flatbuffers.Builder, constantSegment: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(constantSegment), 0)

def AddConstantSegment(builder: flatbuffers.Builder, constantSegment: int):
    ProgramAddConstantSegment(builder, constantSegment)

def ProgramAddMutableDataSegments(builder: flatbuffers.Builder, mutableDataSegments: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(mutableDataSegments), 0)

def AddMutableDataSegments(builder: flatbuffers.Builder, mutableDataSegments: int):
    ProgramAddMutableDataSegments(builder, mutableDataSegments)

def ProgramStartMutableDataSegmentsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartMutableDataSegmentsVector(builder, numElems: int) -> int:
    return ProgramStartMutableDataSegmentsVector(builder, numElems)

def ProgramAddNamedData(builder: flatbuffers.Builder, namedData: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(namedData), 0)

def AddNamedData(builder: flatbuffers.Builder, namedData: int):
    ProgramAddNamedData(builder, namedData)

def ProgramStartNamedDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartNamedDataVector(builder, numElems: int) -> int:
    return ProgramStartNamedDataVector(builder, numElems)

def ProgramEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return ProgramEnd(builder)

from executorch.exir._serialize.generated.executorch_flatbuffer import BackendDelegateInlineData
from executorch.exir._serialize.generated.executorch_flatbuffer import Buffer
from executorch.exir._serialize.generated.executorch_flatbuffer import DataSegment
from executorch.exir._serialize.generated.executorch_flatbuffer import ExecutionPlan
from executorch.exir._serialize.generated.executorch_flatbuffer import NamedData
from executorch.exir._serialize.generated.executorch_flatbuffer import SubsegmentOffsets
try:
    from typing import List, Optional
except:
    pass

class ProgramT(object):

    # ProgramT
    def __init__(self):
        self.version = 0  # type: int
        self.executionPlan = None  # type: List[executorch_flatbuffer.ExecutionPlan.ExecutionPlanT]
        self.constantBuffer = None  # type: List[executorch_flatbuffer.Buffer.BufferT]
        self.backendDelegateData = None  # type: List[executorch_flatbuffer.BackendDelegateInlineData.BackendDelegateInlineDataT]
        self.segments = None  # type: List[executorch_flatbuffer.DataSegment.DataSegmentT]
        self.constantSegment = None  # type: Optional[executorch_flatbuffer.SubsegmentOffsets.SubsegmentOffsetsT]
        self.mutableDataSegments = None  # type: List[executorch_flatbuffer.SubsegmentOffsets.SubsegmentOffsetsT]
        self.namedData = None  # type: List[executorch_flatbuffer.NamedData.NamedDataT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        program = Program()
        program.Init(buf, pos)
        return cls.InitFromObj(program)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, program):
        x = ProgramT()
        x._UnPack(program)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.version == other.version and \
            self.executionPlan == other.executionPlan and \
            self.constantBuffer == other.constantBuffer and \
            self.backendDelegateData == other.backendDelegateData and \
            self.segments == other.segments and \
            self.constantSegment == other.constantSegment and \
            self.mutableDataSegments == other.mutableDataSegments and \
            self.namedData == other.namedData

    # ProgramT
    def _UnPack(self, program):
        if program is None:
            return
        self.version = program.Version()
        if not program.ExecutionPlanIsNone():
            self.executionPlan = []
            for i in range(program.ExecutionPlanLength()):
                if program.ExecutionPlan(i) is None:
                    self.executionPlan.append(None)
                else:
                    executionPlan_ = executorch_flatbuffer.ExecutionPlan.ExecutionPlanT.InitFromObj(program.ExecutionPlan(i))
                    self.executionPlan.append(executionPlan_)
        if not program.ConstantBufferIsNone():
            self.constantBuffer = []
            for i in range(program.ConstantBufferLength()):
                if program.ConstantBuffer(i) is None:
                    self.constantBuffer.append(None)
                else:
                    buffer_ = executorch_flatbuffer.Buffer.BufferT.InitFromObj(program.ConstantBuffer(i))
                    self.constantBuffer.append(buffer_)
        if not program.BackendDelegateDataIsNone():
            self.backendDelegateData = []
            for i in range(program.BackendDelegateDataLength()):
                if program.BackendDelegateData(i) is None:
                    self.backendDelegateData.append(None)
                else:
                    backendDelegateInlineData_ = executorch_flatbuffer.BackendDelegateInlineData.BackendDelegateInlineDataT.InitFromObj(program.BackendDelegateData(i))
                    self.backendDelegateData.append(backendDelegateInlineData_)
        if not program.SegmentsIsNone():
            self.segments = []
            for i in range(program.SegmentsLength()):
                if program.Segments(i) is None:
                    self.segments.append(None)
                else:
                    dataSegment_ = executorch_flatbuffer.DataSegment.DataSegmentT.InitFromObj(program.Segments(i))
                    self.segments.append(dataSegment_)
        if program.ConstantSegment() is not None:
            self.constantSegment = executorch_flatbuffer.SubsegmentOffsets.SubsegmentOffsetsT.InitFromObj(program.ConstantSegment())
        if not program.MutableDataSegmentsIsNone():
            self.mutableDataSegments = []
            for i in range(program.MutableDataSegmentsLength()):
                if program.MutableDataSegments(i) is None:
                    self.mutableDataSegments.append(None)
                else:
                    subsegmentOffsets_ = executorch_flatbuffer.SubsegmentOffsets.SubsegmentOffsetsT.InitFromObj(program.MutableDataSegments(i))
                    self.mutableDataSegments.append(subsegmentOffsets_)
        if not program.NamedDataIsNone():
            self.namedData = []
            for i in range(program.NamedDataLength()):
                if program.NamedData(i) is None:
                    self.namedData.append(None)
                else:
                    namedData_ = executorch_flatbuffer.NamedData.NamedDataT.InitFromObj(program.NamedData(i))
                    self.namedData.append(namedData_)

    # ProgramT
    def Pack(self, builder):
        if self.executionPlan is not None:
            executionPlanlist = []
            for i in range(len(self.executionPlan)):
                executionPlanlist.append(self.executionPlan[i].Pack(builder))
            ProgramStartExecutionPlanVector(builder, len(self.executionPlan))
            for i in reversed(range(len(self.executionPlan))):
                builder.PrependUOffsetTRelative(executionPlanlist[i])
            executionPlan = builder.EndVector()
        if self.constantBuffer is not None:
            constantBufferlist = []
            for i in range(len(self.constantBuffer)):
                constantBufferlist.append(self.constantBuffer[i].Pack(builder))
            ProgramStartConstantBufferVector(builder, len(self.constantBuffer))
            for i in reversed(range(len(self.constantBuffer))):
                builder.PrependUOffsetTRelative(constantBufferlist[i])
            constantBuffer = builder.EndVector()
        if self.backendDelegateData is not None:
            backendDelegateDatalist = []
            for i in range(len(self.backendDelegateData)):
                backendDelegateDatalist.append(self.backendDelegateData[i].Pack(builder))
            ProgramStartBackendDelegateDataVector(builder, len(self.backendDelegateData))
            for i in reversed(range(len(self.backendDelegateData))):
                builder.PrependUOffsetTRelative(backendDelegateDatalist[i])
            backendDelegateData = builder.EndVector()
        if self.segments is not None:
            segmentslist = []
            for i in range(len(self.segments)):
                segmentslist.append(self.segments[i].Pack(builder))
            ProgramStartSegmentsVector(builder, len(self.segments))
            for i in reversed(range(len(self.segments))):
                builder.PrependUOffsetTRelative(segmentslist[i])
            segments = builder.EndVector()
        if self.constantSegment is not None:
            constantSegment = self.constantSegment.Pack(builder)
        if self.mutableDataSegments is not None:
            mutableDataSegmentslist = []
            for i in range(len(self.mutableDataSegments)):
                mutableDataSegmentslist.append(self.mutableDataSegments[i].Pack(builder))
            ProgramStartMutableDataSegmentsVector(builder, len(self.mutableDataSegments))
            for i in reversed(range(len(self.mutableDataSegments))):
                builder.PrependUOffsetTRelative(mutableDataSegmentslist[i])
            mutableDataSegments = builder.EndVector()
        if self.namedData is not None:
            namedDatalist = []
            for i in range(len(self.namedData)):
                namedDatalist.append(self.namedData[i].Pack(builder))
            ProgramStartNamedDataVector(builder, len(self.namedData))
            for i in reversed(range(len(self.namedData))):
                builder.PrependUOffsetTRelative(namedDatalist[i])
            namedData = builder.EndVector()
        ProgramStart(builder)
        ProgramAddVersion(builder, self.version)
        if self.executionPlan is not None:
            ProgramAddExecutionPlan(builder, executionPlan)
        if self.constantBuffer is not None:
            ProgramAddConstantBuffer(builder, constantBuffer)
        if self.backendDelegateData is not None:
            ProgramAddBackendDelegateData(builder, backendDelegateData)
        if self.segments is not None:
            ProgramAddSegments(builder, segments)
        if self.constantSegment is not None:
            ProgramAddConstantSegment(builder, constantSegment)
        if self.mutableDataSegments is not None:
            ProgramAddMutableDataSegments(builder, mutableDataSegments)
        if self.namedData is not None:
            ProgramAddNamedData(builder, namedData)
        program = ProgramEnd(builder)
        return program
