# automatically generated by the FlatBuffers compiler, do not modify

# namespace: executorch_flatbuffer

from executorch.exir._serialize.generated import executorch_flatbuffer
import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from executorch.exir._serialize.generated.executorch_flatbuffer.FrameList import FrameList
from executorch.exir._serialize.generated.executorch_flatbuffer.Instruction import Instruction
from typing import Optional
np = import_numpy()

class Chain(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Chain()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsChain(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ChainBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Chain
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Chain
    def Inputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Chain
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Chain
    def InputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def InputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Chain
    def Outputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Chain
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Chain
    def OutputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def OutputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Chain
    def Instructions(self, j: int) -> Optional[Instruction]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Instruction()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Chain
    def InstructionsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def InstructionsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Chain
    def Stacktrace(self, j: int) -> Optional[FrameList]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = FrameList()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Chain
    def StacktraceLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def StacktraceIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ChainStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def Start(builder: flatbuffers.Builder):
    ChainStart(builder)

def ChainAddInputs(builder: flatbuffers.Builder, inputs: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def AddInputs(builder: flatbuffers.Builder, inputs: int):
    ChainAddInputs(builder, inputs)

def ChainStartInputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartInputsVector(builder, numElems: int) -> int:
    return ChainStartInputsVector(builder, numElems)

def ChainAddOutputs(builder: flatbuffers.Builder, outputs: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def AddOutputs(builder: flatbuffers.Builder, outputs: int):
    ChainAddOutputs(builder, outputs)

def ChainStartOutputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartOutputsVector(builder, numElems: int) -> int:
    return ChainStartOutputsVector(builder, numElems)

def ChainAddInstructions(builder: flatbuffers.Builder, instructions: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(instructions), 0)

def AddInstructions(builder: flatbuffers.Builder, instructions: int):
    ChainAddInstructions(builder, instructions)

def ChainStartInstructionsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartInstructionsVector(builder, numElems: int) -> int:
    return ChainStartInstructionsVector(builder, numElems)

def ChainAddStacktrace(builder: flatbuffers.Builder, stacktrace: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(stacktrace), 0)

def AddStacktrace(builder: flatbuffers.Builder, stacktrace: int):
    ChainAddStacktrace(builder, stacktrace)

def ChainStartStacktraceVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartStacktraceVector(builder, numElems: int) -> int:
    return ChainStartStacktraceVector(builder, numElems)

def ChainEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return ChainEnd(builder)

from executorch.exir._serialize.generated.executorch_flatbuffer import FrameList
from executorch.exir._serialize.generated.executorch_flatbuffer import Instruction
try:
    from typing import List
except:
    pass

class ChainT(object):

    # ChainT
    def __init__(self):
        self.inputs = None  # type: List[int]
        self.outputs = None  # type: List[int]
        self.instructions = None  # type: List[executorch_flatbuffer.Instruction.InstructionT]
        self.stacktrace = None  # type: List[executorch_flatbuffer.FrameList.FrameListT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        chain = Chain()
        chain.Init(buf, pos)
        return cls.InitFromObj(chain)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, chain):
        x = ChainT()
        x._UnPack(chain)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.inputs == other.inputs and \
            self.outputs == other.outputs and \
            self.instructions == other.instructions and \
            self.stacktrace == other.stacktrace

    # ChainT
    def _UnPack(self, chain):
        if chain is None:
            return
        if not chain.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(chain.InputsLength()):
                    self.inputs.append(chain.Inputs(i))
            else:
                self.inputs = chain.InputsAsNumpy()
        if not chain.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(chain.OutputsLength()):
                    self.outputs.append(chain.Outputs(i))
            else:
                self.outputs = chain.OutputsAsNumpy()
        if not chain.InstructionsIsNone():
            self.instructions = []
            for i in range(chain.InstructionsLength()):
                if chain.Instructions(i) is None:
                    self.instructions.append(None)
                else:
                    instruction_ = executorch_flatbuffer.Instruction.InstructionT.InitFromObj(chain.Instructions(i))
                    self.instructions.append(instruction_)
        if not chain.StacktraceIsNone():
            self.stacktrace = []
            for i in range(chain.StacktraceLength()):
                if chain.Stacktrace(i) is None:
                    self.stacktrace.append(None)
                else:
                    frameList_ = executorch_flatbuffer.FrameList.FrameListT.InitFromObj(chain.Stacktrace(i))
                    self.stacktrace.append(frameList_)

    # ChainT
    def Pack(self, builder):
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                ChainStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                ChainStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        if self.instructions is not None:
            instructionslist = []
            for i in range(len(self.instructions)):
                instructionslist.append(self.instructions[i].Pack(builder))
            ChainStartInstructionsVector(builder, len(self.instructions))
            for i in reversed(range(len(self.instructions))):
                builder.PrependUOffsetTRelative(instructionslist[i])
            instructions = builder.EndVector()
        if self.stacktrace is not None:
            stacktracelist = []
            for i in range(len(self.stacktrace)):
                stacktracelist.append(self.stacktrace[i].Pack(builder))
            ChainStartStacktraceVector(builder, len(self.stacktrace))
            for i in reversed(range(len(self.stacktrace))):
                builder.PrependUOffsetTRelative(stacktracelist[i])
            stacktrace = builder.EndVector()
        ChainStart(builder)
        if self.inputs is not None:
            ChainAddInputs(builder, inputs)
        if self.outputs is not None:
            ChainAddOutputs(builder, outputs)
        if self.instructions is not None:
            ChainAddInstructions(builder, instructions)
        if self.stacktrace is not None:
            ChainAddStacktrace(builder, stacktrace)
        chain = ChainEnd(builder)
        return chain
