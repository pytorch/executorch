# automatically generated by the FlatBuffers compiler, do not modify

# namespace: executorch_flatbuffer

from executorch.exir._serialize.generated import executorch_flatbuffer
import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from executorch.exir._serialize.generated.executorch_flatbuffer.BackendDelegateDataReference import BackendDelegateDataReference
from executorch.exir._serialize.generated.executorch_flatbuffer.CompileSpec import CompileSpec
from typing import Optional
np = import_numpy()

class BackendDelegate(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BackendDelegate()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBackendDelegate(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BackendDelegateBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # BackendDelegate
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BackendDelegate
    def Id(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # BackendDelegate
    def Processed(self) -> Optional[BackendDelegateDataReference]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = BackendDelegateDataReference()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BackendDelegate
    def CompileSpecs(self, j: int) -> Optional[CompileSpec]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = CompileSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BackendDelegate
    def CompileSpecsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BackendDelegate
    def CompileSpecsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def BackendDelegateStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def Start(builder: flatbuffers.Builder):
    BackendDelegateStart(builder)

def BackendDelegateAddId(builder: flatbuffers.Builder, id: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(id), 0)

def AddId(builder: flatbuffers.Builder, id: int):
    BackendDelegateAddId(builder, id)

def BackendDelegateAddProcessed(builder: flatbuffers.Builder, processed: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(processed), 0)

def AddProcessed(builder: flatbuffers.Builder, processed: int):
    BackendDelegateAddProcessed(builder, processed)

def BackendDelegateAddCompileSpecs(builder: flatbuffers.Builder, compileSpecs: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(compileSpecs), 0)

def AddCompileSpecs(builder: flatbuffers.Builder, compileSpecs: int):
    BackendDelegateAddCompileSpecs(builder, compileSpecs)

def BackendDelegateStartCompileSpecsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartCompileSpecsVector(builder, numElems: int) -> int:
    return BackendDelegateStartCompileSpecsVector(builder, numElems)

def BackendDelegateEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return BackendDelegateEnd(builder)

from executorch.exir._serialize.generated.executorch_flatbuffer import BackendDelegateDataReference
from executorch.exir._serialize.generated.executorch_flatbuffer import CompileSpec
try:
    from typing import List, Optional
except:
    pass

class BackendDelegateT(object):

    # BackendDelegateT
    def __init__(self):
        self.id = None  # type: str
        self.processed = None  # type: Optional[executorch_flatbuffer.BackendDelegateDataReference.BackendDelegateDataReferenceT]
        self.compileSpecs = None  # type: List[executorch_flatbuffer.CompileSpec.CompileSpecT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        backendDelegate = BackendDelegate()
        backendDelegate.Init(buf, pos)
        return cls.InitFromObj(backendDelegate)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, backendDelegate):
        x = BackendDelegateT()
        x._UnPack(backendDelegate)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.id == other.id and \
            self.processed == other.processed and \
            self.compileSpecs == other.compileSpecs

    # BackendDelegateT
    def _UnPack(self, backendDelegate):
        if backendDelegate is None:
            return
        self.id = backendDelegate.Id()
        if backendDelegate.Processed() is not None:
            self.processed = executorch_flatbuffer.BackendDelegateDataReference.BackendDelegateDataReferenceT.InitFromObj(backendDelegate.Processed())
        if not backendDelegate.CompileSpecsIsNone():
            self.compileSpecs = []
            for i in range(backendDelegate.CompileSpecsLength()):
                if backendDelegate.CompileSpecs(i) is None:
                    self.compileSpecs.append(None)
                else:
                    compileSpec_ = executorch_flatbuffer.CompileSpec.CompileSpecT.InitFromObj(backendDelegate.CompileSpecs(i))
                    self.compileSpecs.append(compileSpec_)

    # BackendDelegateT
    def Pack(self, builder):
        if self.id is not None:
            id = builder.CreateString(self.id)
        if self.processed is not None:
            processed = self.processed.Pack(builder)
        if self.compileSpecs is not None:
            compileSpecslist = []
            for i in range(len(self.compileSpecs)):
                compileSpecslist.append(self.compileSpecs[i].Pack(builder))
            BackendDelegateStartCompileSpecsVector(builder, len(self.compileSpecs))
            for i in reversed(range(len(self.compileSpecs))):
                builder.PrependUOffsetTRelative(compileSpecslist[i])
            compileSpecs = builder.EndVector()
        BackendDelegateStart(builder)
        if self.id is not None:
            BackendDelegateAddId(builder, id)
        if self.processed is not None:
            BackendDelegateAddProcessed(builder, processed)
        if self.compileSpecs is not None:
            BackendDelegateAddCompileSpecs(builder, compileSpecs)
        backendDelegate = BackendDelegateEnd(builder)
        return backendDelegate
