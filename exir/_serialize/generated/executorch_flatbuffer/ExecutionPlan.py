# automatically generated by the FlatBuffers compiler, do not modify

# namespace: executorch_flatbuffer

from executorch.exir._serialize.generated import executorch_flatbuffer
import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from executorch.exir._serialize.generated.executorch_flatbuffer.BackendDelegate import BackendDelegate
from executorch.exir._serialize.generated.executorch_flatbuffer.Chain import Chain
from executorch.exir._serialize.generated.executorch_flatbuffer.ContainerMetadata import ContainerMetadata
from executorch.exir._serialize.generated.executorch_flatbuffer.EValue import EValue
from executorch.exir._serialize.generated.executorch_flatbuffer.Operator import Operator
from typing import Optional
np = import_numpy()

class ExecutionPlan(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ExecutionPlan()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsExecutionPlan(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ExecutionPlanBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # ExecutionPlan
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ExecutionPlan
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ExecutionPlan
    def ContainerMetaType(self) -> Optional[ContainerMetadata]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = ContainerMetadata()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def Values(self, j: int) -> Optional[EValue]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = EValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def ValuesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def ValuesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # ExecutionPlan
    def Inputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ExecutionPlan
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # ExecutionPlan
    def InputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def InputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # ExecutionPlan
    def Outputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ExecutionPlan
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # ExecutionPlan
    def OutputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def OutputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # ExecutionPlan
    def Chains(self, j: int) -> Optional[Chain]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Chain()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def ChainsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def ChainsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # ExecutionPlan
    def Operators(self, j: int) -> Optional[Operator]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Operator()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def OperatorsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def OperatorsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # ExecutionPlan
    def Delegates(self, j: int) -> Optional[BackendDelegate]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = BackendDelegate()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def DelegatesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def DelegatesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # ExecutionPlan
    def NonConstBufferSizes(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # ExecutionPlan
    def NonConstBufferSizesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # ExecutionPlan
    def NonConstBufferSizesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def NonConstBufferSizesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

def ExecutionPlanStart(builder: flatbuffers.Builder):
    builder.StartObject(9)

def Start(builder: flatbuffers.Builder):
    ExecutionPlanStart(builder)

def ExecutionPlanAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def AddName(builder: flatbuffers.Builder, name: int):
    ExecutionPlanAddName(builder, name)

def ExecutionPlanAddContainerMetaType(builder: flatbuffers.Builder, containerMetaType: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(containerMetaType), 0)

def AddContainerMetaType(builder: flatbuffers.Builder, containerMetaType: int):
    ExecutionPlanAddContainerMetaType(builder, containerMetaType)

def ExecutionPlanAddValues(builder: flatbuffers.Builder, values: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0)

def AddValues(builder: flatbuffers.Builder, values: int):
    ExecutionPlanAddValues(builder, values)

def ExecutionPlanStartValuesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartValuesVector(builder, numElems: int) -> int:
    return ExecutionPlanStartValuesVector(builder, numElems)

def ExecutionPlanAddInputs(builder: flatbuffers.Builder, inputs: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def AddInputs(builder: flatbuffers.Builder, inputs: int):
    ExecutionPlanAddInputs(builder, inputs)

def ExecutionPlanStartInputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartInputsVector(builder, numElems: int) -> int:
    return ExecutionPlanStartInputsVector(builder, numElems)

def ExecutionPlanAddOutputs(builder: flatbuffers.Builder, outputs: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def AddOutputs(builder: flatbuffers.Builder, outputs: int):
    ExecutionPlanAddOutputs(builder, outputs)

def ExecutionPlanStartOutputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartOutputsVector(builder, numElems: int) -> int:
    return ExecutionPlanStartOutputsVector(builder, numElems)

def ExecutionPlanAddChains(builder: flatbuffers.Builder, chains: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(chains), 0)

def AddChains(builder: flatbuffers.Builder, chains: int):
    ExecutionPlanAddChains(builder, chains)

def ExecutionPlanStartChainsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartChainsVector(builder, numElems: int) -> int:
    return ExecutionPlanStartChainsVector(builder, numElems)

def ExecutionPlanAddOperators(builder: flatbuffers.Builder, operators: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(operators), 0)

def AddOperators(builder: flatbuffers.Builder, operators: int):
    ExecutionPlanAddOperators(builder, operators)

def ExecutionPlanStartOperatorsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartOperatorsVector(builder, numElems: int) -> int:
    return ExecutionPlanStartOperatorsVector(builder, numElems)

def ExecutionPlanAddDelegates(builder: flatbuffers.Builder, delegates: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(delegates), 0)

def AddDelegates(builder: flatbuffers.Builder, delegates: int):
    ExecutionPlanAddDelegates(builder, delegates)

def ExecutionPlanStartDelegatesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartDelegatesVector(builder, numElems: int) -> int:
    return ExecutionPlanStartDelegatesVector(builder, numElems)

def ExecutionPlanAddNonConstBufferSizes(builder: flatbuffers.Builder, nonConstBufferSizes: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(nonConstBufferSizes), 0)

def AddNonConstBufferSizes(builder: flatbuffers.Builder, nonConstBufferSizes: int):
    ExecutionPlanAddNonConstBufferSizes(builder, nonConstBufferSizes)

def ExecutionPlanStartNonConstBufferSizesVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def StartNonConstBufferSizesVector(builder, numElems: int) -> int:
    return ExecutionPlanStartNonConstBufferSizesVector(builder, numElems)

def ExecutionPlanEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return ExecutionPlanEnd(builder)

from executorch.exir._serialize.generated.executorch_flatbuffer import BackendDelegate
from executorch.exir._serialize.generated.executorch_flatbuffer import Chain
from executorch.exir._serialize.generated.executorch_flatbuffer import ContainerMetadata
from executorch.exir._serialize.generated.executorch_flatbuffer import EValue
from executorch.exir._serialize.generated.executorch_flatbuffer import Operator
try:
    from typing import List, Optional
except:
    pass

class ExecutionPlanT(object):

    # ExecutionPlanT
    def __init__(self):
        self.name = None  # type: str
        self.containerMetaType = None  # type: Optional[executorch_flatbuffer.ContainerMetadata.ContainerMetadataT]
        self.values = None  # type: List[executorch_flatbuffer.EValue.EValueT]
        self.inputs = None  # type: List[int]
        self.outputs = None  # type: List[int]
        self.chains = None  # type: List[executorch_flatbuffer.Chain.ChainT]
        self.operators = None  # type: List[executorch_flatbuffer.Operator.OperatorT]
        self.delegates = None  # type: List[executorch_flatbuffer.BackendDelegate.BackendDelegateT]
        self.nonConstBufferSizes = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        executionPlan = ExecutionPlan()
        executionPlan.Init(buf, pos)
        return cls.InitFromObj(executionPlan)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, executionPlan):
        x = ExecutionPlanT()
        x._UnPack(executionPlan)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.name == other.name and \
            self.containerMetaType == other.containerMetaType and \
            self.values == other.values and \
            self.inputs == other.inputs and \
            self.outputs == other.outputs and \
            self.chains == other.chains and \
            self.operators == other.operators and \
            self.delegates == other.delegates and \
            self.nonConstBufferSizes == other.nonConstBufferSizes

    # ExecutionPlanT
    def _UnPack(self, executionPlan):
        if executionPlan is None:
            return
        self.name = executionPlan.Name()
        if executionPlan.ContainerMetaType() is not None:
            self.containerMetaType = executorch_flatbuffer.ContainerMetadata.ContainerMetadataT.InitFromObj(executionPlan.ContainerMetaType())
        if not executionPlan.ValuesIsNone():
            self.values = []
            for i in range(executionPlan.ValuesLength()):
                if executionPlan.Values(i) is None:
                    self.values.append(None)
                else:
                    eValue_ = executorch_flatbuffer.EValue.EValueT.InitFromObj(executionPlan.Values(i))
                    self.values.append(eValue_)
        if not executionPlan.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(executionPlan.InputsLength()):
                    self.inputs.append(executionPlan.Inputs(i))
            else:
                self.inputs = executionPlan.InputsAsNumpy()
        if not executionPlan.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(executionPlan.OutputsLength()):
                    self.outputs.append(executionPlan.Outputs(i))
            else:
                self.outputs = executionPlan.OutputsAsNumpy()
        if not executionPlan.ChainsIsNone():
            self.chains = []
            for i in range(executionPlan.ChainsLength()):
                if executionPlan.Chains(i) is None:
                    self.chains.append(None)
                else:
                    chain_ = executorch_flatbuffer.Chain.ChainT.InitFromObj(executionPlan.Chains(i))
                    self.chains.append(chain_)
        if not executionPlan.OperatorsIsNone():
            self.operators = []
            for i in range(executionPlan.OperatorsLength()):
                if executionPlan.Operators(i) is None:
                    self.operators.append(None)
                else:
                    operator_ = executorch_flatbuffer.Operator.OperatorT.InitFromObj(executionPlan.Operators(i))
                    self.operators.append(operator_)
        if not executionPlan.DelegatesIsNone():
            self.delegates = []
            for i in range(executionPlan.DelegatesLength()):
                if executionPlan.Delegates(i) is None:
                    self.delegates.append(None)
                else:
                    backendDelegate_ = executorch_flatbuffer.BackendDelegate.BackendDelegateT.InitFromObj(executionPlan.Delegates(i))
                    self.delegates.append(backendDelegate_)
        if not executionPlan.NonConstBufferSizesIsNone():
            if np is None:
                self.nonConstBufferSizes = []
                for i in range(executionPlan.NonConstBufferSizesLength()):
                    self.nonConstBufferSizes.append(executionPlan.NonConstBufferSizes(i))
            else:
                self.nonConstBufferSizes = executionPlan.NonConstBufferSizesAsNumpy()

    # ExecutionPlanT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.containerMetaType is not None:
            containerMetaType = self.containerMetaType.Pack(builder)
        if self.values is not None:
            valueslist = []
            for i in range(len(self.values)):
                valueslist.append(self.values[i].Pack(builder))
            ExecutionPlanStartValuesVector(builder, len(self.values))
            for i in reversed(range(len(self.values))):
                builder.PrependUOffsetTRelative(valueslist[i])
            values = builder.EndVector()
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                ExecutionPlanStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                ExecutionPlanStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        if self.chains is not None:
            chainslist = []
            for i in range(len(self.chains)):
                chainslist.append(self.chains[i].Pack(builder))
            ExecutionPlanStartChainsVector(builder, len(self.chains))
            for i in reversed(range(len(self.chains))):
                builder.PrependUOffsetTRelative(chainslist[i])
            chains = builder.EndVector()
        if self.operators is not None:
            operatorslist = []
            for i in range(len(self.operators)):
                operatorslist.append(self.operators[i].Pack(builder))
            ExecutionPlanStartOperatorsVector(builder, len(self.operators))
            for i in reversed(range(len(self.operators))):
                builder.PrependUOffsetTRelative(operatorslist[i])
            operators = builder.EndVector()
        if self.delegates is not None:
            delegateslist = []
            for i in range(len(self.delegates)):
                delegateslist.append(self.delegates[i].Pack(builder))
            ExecutionPlanStartDelegatesVector(builder, len(self.delegates))
            for i in reversed(range(len(self.delegates))):
                builder.PrependUOffsetTRelative(delegateslist[i])
            delegates = builder.EndVector()
        if self.nonConstBufferSizes is not None:
            if np is not None and type(self.nonConstBufferSizes) is np.ndarray:
                nonConstBufferSizes = builder.CreateNumpyVector(self.nonConstBufferSizes)
            else:
                ExecutionPlanStartNonConstBufferSizesVector(builder, len(self.nonConstBufferSizes))
                for i in reversed(range(len(self.nonConstBufferSizes))):
                    builder.PrependInt64(self.nonConstBufferSizes[i])
                nonConstBufferSizes = builder.EndVector()
        ExecutionPlanStart(builder)
        if self.name is not None:
            ExecutionPlanAddName(builder, name)
        if self.containerMetaType is not None:
            ExecutionPlanAddContainerMetaType(builder, containerMetaType)
        if self.values is not None:
            ExecutionPlanAddValues(builder, values)
        if self.inputs is not None:
            ExecutionPlanAddInputs(builder, inputs)
        if self.outputs is not None:
            ExecutionPlanAddOutputs(builder, outputs)
        if self.chains is not None:
            ExecutionPlanAddChains(builder, chains)
        if self.operators is not None:
            ExecutionPlanAddOperators(builder, operators)
        if self.delegates is not None:
            ExecutionPlanAddDelegates(builder, delegates)
        if self.nonConstBufferSizes is not None:
            ExecutionPlanAddNonConstBufferSizes(builder, nonConstBufferSizes)
        executionPlan = ExecutionPlanEnd(builder)
        return executionPlan
