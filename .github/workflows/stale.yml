# The behavior is:
# - If a PR is not labeled stale, after 60 days inactivity label the PR as stale and comment about it.
# - If a PR is labeled stale, after 30 days inactivity close the PR.
# - `high priority` and `no-stale` PRs are exempt.

name: Close stale issues and pull requests

on:
  schedule:
    # Run weekly at 00:30 UTC every Sunday.
    - cron: '30 0 * * 0'
  workflow_dispatch:

jobs:
  stale:
    if: ${{ github.repository == 'pytorch/executorch' }}
    runs-on: linux.large
    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const retries = 7;
            const baseBackoff = 100;
            const sleep = timeout => new Promise(resolve => setTimeout(resolve, timeout));
            github.hook.wrap('request', async (request, options) => {
              for (let attempt = 1; attempt <= retries; attempt++) {
                try {
                  return await request(options);
                } catch (err) {
                  if (attempt < retries) {
                    core.warning(`Request getting retried. Attempt: ${attempt}`);
                    await sleep(baseBackoff * Math.pow(2, attempt));
                    continue;
                  }
                  throw err;
                }
              }
            });

            const MAX_API_REQUESTS = 100;
            const STALE_LABEL_THRESHOLD_MS = 1000 * 60 * 60 * 24 * 60;
            const STALE_CLOSE_THRESHOLD_MS = 1000 * 60 * 60 * 24 * 30;

            const STALE_MESSAGE =
              "Looks like this item hasn't been updated in a while so we're going to go ahead and mark this as `Stale`. <br>" +
              "Feel free to remove the `Stale` label if you feel this was a mistake. <br>" +
              "If you are unable to remove the `Stale` label please contact a maintainer in order to do so. <br>" +
              "If you want the bot to never mark this item stale again, add the `no-stale` label.<br>" +
              "`Stale` items will automatically be closed after 30 days of inactivity.<br>";

            let numAPIRequests = 0;
            let numProcessed = 0;

            async function processItem(item, isPR) {
              core.info(`[${item.number}] URL: ${item.html_url}`);
              numProcessed += 1;
              const labels = item.labels.map((label) => label.name);

              if (labels.includes("no-stale") || labels.includes("high priority")) {
                core.info(`[${item.number}] Skipping because item has an exempting label.`);
                return false;
              }

              let staleThresholdMillis;
              if (labels.includes("Stale")) {
                core.info(`[${item.number}] Item is labeled stale, checking whether we should close it.`);
                staleThresholdMillis = STALE_CLOSE_THRESHOLD_MS;
              } else {
                core.info(`[${item.number}] Checking whether to label item as stale.`);
                staleThresholdMillis = STALE_LABEL_THRESHOLD_MS;
              }

              const millisSinceLastUpdated =
                new Date().getTime() - new Date(item.updated_at).getTime();

              if (millisSinceLastUpdated < staleThresholdMillis) {
                core.info(`[${item.number}] Skipping because item was updated recently`);
                return false;
              }

              if (labels.includes("Stale")) {
                core.info(`[${item.number}] Closing item.`);
                numAPIRequests += 1;
                await github.rest.issues.update({
                  owner: "pytorch",
                  repo: "executorch",
                  issue_number: item.number,
                  state: "closed",
                });
              } else {
                core.info(`[${item.number}] Labeling item as stale.`);
                numAPIRequests += 1;
                await github.rest.issues.createComment({
                  owner: "pytorch",
                  repo: "executorch",
                  issue_number: item.number,
                  body: STALE_MESSAGE,
                });

                numAPIRequests += 1;
                await github.rest.issues.addLabels({
                  owner: "pytorch",
                  repo: "executorch",
                  issue_number: item.number,
                  labels: ["Stale"],
                });
              }
            }

            async function processType(listFn, isPR) {
              for await (const response of github.paginate.iterator(
                listFn,
                {
                  owner: "pytorch",
                  repo: "executorch",
                  state: "open",
                  sort: "created",
                  direction: "asc",
                  per_page: 100,
                }
              )) {
                numAPIRequests += 1;
                const items = response.data;
                for (const item of items) {
                  if (numAPIRequests > MAX_API_REQUESTS) {
                    core.warning("Max API requests exceeded, exiting.");
                    process.exit(0);
                  }
                  await core.group(`Processing ${isPR ? "PR" : "Issue"} #${item.number}`, async () => {
                    await processItem(item, isPR);
                  });
                }
              }
            }

            // Process PRs
            await processType(github.rest.pulls.list, true);

            // Process Issues (exclude PRs)
            await processType(
              async (params) => {
                const resp = await github.rest.issues.listForRepo(params);
                resp.data = resp.data.filter((issue) => !issue.pull_request);
                return resp;
              },
              false
            );

            core.info(`Processed ${numProcessed} items total.`);
