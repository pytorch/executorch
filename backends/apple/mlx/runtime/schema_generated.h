// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_MLX_DELEGATE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_MLX_DELEGATE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace mlx_delegate {

struct Tid;

struct Vid;

struct IntOrVid;
struct IntOrVidBuilder;

struct FloatOrVid;
struct FloatOrVidBuilder;

struct NoopNode;
struct NoopNodeBuilder;

struct LinearNode;
struct LinearNodeBuilder;

struct ItemIntNode;
struct ItemIntNodeBuilder;

struct ExpandDimsNode;
struct ExpandDimsNodeBuilder;

struct TileNode;
struct TileNodeBuilder;

struct TakeAlongAxisNode;
struct TakeAlongAxisNodeBuilder;

struct RMSNormNode;
struct RMSNormNodeBuilder;

struct LayerNormNode;
struct LayerNormNodeBuilder;

struct RopeNode;
struct RopeNodeBuilder;

struct SdpaNode;
struct SdpaNodeBuilder;

struct AddNode;
struct AddNodeBuilder;

struct AddScalarNode;
struct AddScalarNodeBuilder;

struct SymSizeNode;
struct SymSizeNodeBuilder;

struct MulNode;
struct MulNodeBuilder;

struct Conv1DNode;
struct Conv1DNodeBuilder;

struct GeluNode;
struct GeluNodeBuilder;

struct ARangeNode;
struct ARangeNodeBuilder;

struct SiluNode;
struct SiluNodeBuilder;

struct ReshapeNode;
struct ReshapeNodeBuilder;

struct TransposeNode;
struct TransposeNodeBuilder;

struct ContiguousNode;
struct ContiguousNodeBuilder;

struct IdCopyNode;
struct IdCopyNodeBuilder;

struct GatherNode;
struct GatherNodeBuilder;

struct SliceNode;
struct SliceNodeBuilder;

struct CastNode;
struct CastNodeBuilder;

struct QuantizedLinearNode;
struct QuantizedLinearNodeBuilder;

struct ConcatNode;
struct ConcatNodeBuilder;

struct FullNode;
struct FullNodeBuilder;

struct ZerosNode;
struct ZerosNodeBuilder;

struct OnesNode;
struct OnesNodeBuilder;

struct ArgmaxNode;
struct ArgmaxNodeBuilder;

struct SliceUpdateNode;
struct SliceUpdateNodeBuilder;

struct QuantizedGatherNode;
struct QuantizedGatherNodeBuilder;

struct Instruction;
struct InstructionBuilder;

struct TensorMeta;
struct TensorMetaBuilder;

struct SlotVariant;
struct SlotVariantBuilder;

struct NamedSlot;
struct NamedSlotBuilder;

struct DataSegment;
struct DataSegmentBuilder;

struct MLXGraph;
struct MLXGraphBuilder;

enum DTypeId : int8_t {
  DTypeId_f16 = 0,
  DTypeId_f32 = 1,
  DTypeId_bf16 = 2,
  DTypeId_i32 = 3,
  DTypeId_i64 = 4,
  DTypeId_u32 = 5,
  DTypeId_u8 = 6,
  DTypeId_boolean = 7,
  DTypeId_i8 = 8,
  DTypeId_MIN = DTypeId_f16,
  DTypeId_MAX = DTypeId_i8
};

inline const DTypeId (&EnumValuesDTypeId())[9] {
  static const DTypeId values[] = {
    DTypeId_f16,
    DTypeId_f32,
    DTypeId_bf16,
    DTypeId_i32,
    DTypeId_i64,
    DTypeId_u32,
    DTypeId_u8,
    DTypeId_boolean,
    DTypeId_i8
  };
  return values;
}

inline const char * const *EnumNamesDTypeId() {
  static const char * const names[10] = {
    "f16",
    "f32",
    "bf16",
    "i32",
    "i64",
    "u32",
    "u8",
    "boolean",
    "i8",
    nullptr
  };
  return names;
}

inline const char *EnumNameDTypeId(DTypeId e) {
  if (::flatbuffers::IsOutRange(e, DTypeId_f16, DTypeId_i8)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDTypeId()[index];
}

enum OpNode : uint8_t {
  OpNode_NONE = 0,
  OpNode_NoopNode = 1,
  OpNode_LinearNode = 2,
  OpNode_ItemIntNode = 3,
  OpNode_ExpandDimsNode = 4,
  OpNode_TileNode = 5,
  OpNode_TakeAlongAxisNode = 6,
  OpNode_RMSNormNode = 7,
  OpNode_LayerNormNode = 8,
  OpNode_RopeNode = 9,
  OpNode_SdpaNode = 10,
  OpNode_AddNode = 11,
  OpNode_AddScalarNode = 12,
  OpNode_SymSizeNode = 13,
  OpNode_MulNode = 14,
  OpNode_Conv1DNode = 15,
  OpNode_GeluNode = 16,
  OpNode_ARangeNode = 17,
  OpNode_SiluNode = 18,
  OpNode_ReshapeNode = 19,
  OpNode_TransposeNode = 20,
  OpNode_ContiguousNode = 21,
  OpNode_IdCopyNode = 22,
  OpNode_GatherNode = 23,
  OpNode_SliceNode = 24,
  OpNode_CastNode = 25,
  OpNode_QuantizedLinearNode = 26,
  OpNode_ConcatNode = 27,
  OpNode_FullNode = 28,
  OpNode_ZerosNode = 29,
  OpNode_OnesNode = 30,
  OpNode_ArgmaxNode = 31,
  OpNode_SliceUpdateNode = 32,
  OpNode_QuantizedGatherNode = 33,
  OpNode_MIN = OpNode_NONE,
  OpNode_MAX = OpNode_QuantizedGatherNode
};

inline const OpNode (&EnumValuesOpNode())[34] {
  static const OpNode values[] = {
    OpNode_NONE,
    OpNode_NoopNode,
    OpNode_LinearNode,
    OpNode_ItemIntNode,
    OpNode_ExpandDimsNode,
    OpNode_TileNode,
    OpNode_TakeAlongAxisNode,
    OpNode_RMSNormNode,
    OpNode_LayerNormNode,
    OpNode_RopeNode,
    OpNode_SdpaNode,
    OpNode_AddNode,
    OpNode_AddScalarNode,
    OpNode_SymSizeNode,
    OpNode_MulNode,
    OpNode_Conv1DNode,
    OpNode_GeluNode,
    OpNode_ARangeNode,
    OpNode_SiluNode,
    OpNode_ReshapeNode,
    OpNode_TransposeNode,
    OpNode_ContiguousNode,
    OpNode_IdCopyNode,
    OpNode_GatherNode,
    OpNode_SliceNode,
    OpNode_CastNode,
    OpNode_QuantizedLinearNode,
    OpNode_ConcatNode,
    OpNode_FullNode,
    OpNode_ZerosNode,
    OpNode_OnesNode,
    OpNode_ArgmaxNode,
    OpNode_SliceUpdateNode,
    OpNode_QuantizedGatherNode
  };
  return values;
}

inline const char * const *EnumNamesOpNode() {
  static const char * const names[35] = {
    "NONE",
    "NoopNode",
    "LinearNode",
    "ItemIntNode",
    "ExpandDimsNode",
    "TileNode",
    "TakeAlongAxisNode",
    "RMSNormNode",
    "LayerNormNode",
    "RopeNode",
    "SdpaNode",
    "AddNode",
    "AddScalarNode",
    "SymSizeNode",
    "MulNode",
    "Conv1DNode",
    "GeluNode",
    "ARangeNode",
    "SiluNode",
    "ReshapeNode",
    "TransposeNode",
    "ContiguousNode",
    "IdCopyNode",
    "GatherNode",
    "SliceNode",
    "CastNode",
    "QuantizedLinearNode",
    "ConcatNode",
    "FullNode",
    "ZerosNode",
    "OnesNode",
    "ArgmaxNode",
    "SliceUpdateNode",
    "QuantizedGatherNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpNode(OpNode e) {
  if (::flatbuffers::IsOutRange(e, OpNode_NONE, OpNode_QuantizedGatherNode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpNode()[index];
}

template<typename T> struct OpNodeTraits {
  static const OpNode enum_value = OpNode_NONE;
};

template<> struct OpNodeTraits<mlx_delegate::NoopNode> {
  static const OpNode enum_value = OpNode_NoopNode;
};

template<> struct OpNodeTraits<mlx_delegate::LinearNode> {
  static const OpNode enum_value = OpNode_LinearNode;
};

template<> struct OpNodeTraits<mlx_delegate::ItemIntNode> {
  static const OpNode enum_value = OpNode_ItemIntNode;
};

template<> struct OpNodeTraits<mlx_delegate::ExpandDimsNode> {
  static const OpNode enum_value = OpNode_ExpandDimsNode;
};

template<> struct OpNodeTraits<mlx_delegate::TileNode> {
  static const OpNode enum_value = OpNode_TileNode;
};

template<> struct OpNodeTraits<mlx_delegate::TakeAlongAxisNode> {
  static const OpNode enum_value = OpNode_TakeAlongAxisNode;
};

template<> struct OpNodeTraits<mlx_delegate::RMSNormNode> {
  static const OpNode enum_value = OpNode_RMSNormNode;
};

template<> struct OpNodeTraits<mlx_delegate::LayerNormNode> {
  static const OpNode enum_value = OpNode_LayerNormNode;
};

template<> struct OpNodeTraits<mlx_delegate::RopeNode> {
  static const OpNode enum_value = OpNode_RopeNode;
};

template<> struct OpNodeTraits<mlx_delegate::SdpaNode> {
  static const OpNode enum_value = OpNode_SdpaNode;
};

template<> struct OpNodeTraits<mlx_delegate::AddNode> {
  static const OpNode enum_value = OpNode_AddNode;
};

template<> struct OpNodeTraits<mlx_delegate::AddScalarNode> {
  static const OpNode enum_value = OpNode_AddScalarNode;
};

template<> struct OpNodeTraits<mlx_delegate::SymSizeNode> {
  static const OpNode enum_value = OpNode_SymSizeNode;
};

template<> struct OpNodeTraits<mlx_delegate::MulNode> {
  static const OpNode enum_value = OpNode_MulNode;
};

template<> struct OpNodeTraits<mlx_delegate::Conv1DNode> {
  static const OpNode enum_value = OpNode_Conv1DNode;
};

template<> struct OpNodeTraits<mlx_delegate::GeluNode> {
  static const OpNode enum_value = OpNode_GeluNode;
};

template<> struct OpNodeTraits<mlx_delegate::ARangeNode> {
  static const OpNode enum_value = OpNode_ARangeNode;
};

template<> struct OpNodeTraits<mlx_delegate::SiluNode> {
  static const OpNode enum_value = OpNode_SiluNode;
};

template<> struct OpNodeTraits<mlx_delegate::ReshapeNode> {
  static const OpNode enum_value = OpNode_ReshapeNode;
};

template<> struct OpNodeTraits<mlx_delegate::TransposeNode> {
  static const OpNode enum_value = OpNode_TransposeNode;
};

template<> struct OpNodeTraits<mlx_delegate::ContiguousNode> {
  static const OpNode enum_value = OpNode_ContiguousNode;
};

template<> struct OpNodeTraits<mlx_delegate::IdCopyNode> {
  static const OpNode enum_value = OpNode_IdCopyNode;
};

template<> struct OpNodeTraits<mlx_delegate::GatherNode> {
  static const OpNode enum_value = OpNode_GatherNode;
};

template<> struct OpNodeTraits<mlx_delegate::SliceNode> {
  static const OpNode enum_value = OpNode_SliceNode;
};

template<> struct OpNodeTraits<mlx_delegate::CastNode> {
  static const OpNode enum_value = OpNode_CastNode;
};

template<> struct OpNodeTraits<mlx_delegate::QuantizedLinearNode> {
  static const OpNode enum_value = OpNode_QuantizedLinearNode;
};

template<> struct OpNodeTraits<mlx_delegate::ConcatNode> {
  static const OpNode enum_value = OpNode_ConcatNode;
};

template<> struct OpNodeTraits<mlx_delegate::FullNode> {
  static const OpNode enum_value = OpNode_FullNode;
};

template<> struct OpNodeTraits<mlx_delegate::ZerosNode> {
  static const OpNode enum_value = OpNode_ZerosNode;
};

template<> struct OpNodeTraits<mlx_delegate::OnesNode> {
  static const OpNode enum_value = OpNode_OnesNode;
};

template<> struct OpNodeTraits<mlx_delegate::ArgmaxNode> {
  static const OpNode enum_value = OpNode_ArgmaxNode;
};

template<> struct OpNodeTraits<mlx_delegate::SliceUpdateNode> {
  static const OpNode enum_value = OpNode_SliceUpdateNode;
};

template<> struct OpNodeTraits<mlx_delegate::QuantizedGatherNode> {
  static const OpNode enum_value = OpNode_QuantizedGatherNode;
};

bool VerifyOpNode(::flatbuffers::Verifier &verifier, const void *obj, OpNode type);
bool VerifyOpNodeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum SlotType : int8_t {
  SlotType_TensorSlot = 0,
  SlotType_IntValueSlot = 1,
  SlotType_FloatValueSlot = 2,
  SlotType_BoolValueSlot = 3,
  SlotType_MIN = SlotType_TensorSlot,
  SlotType_MAX = SlotType_BoolValueSlot
};

inline const SlotType (&EnumValuesSlotType())[4] {
  static const SlotType values[] = {
    SlotType_TensorSlot,
    SlotType_IntValueSlot,
    SlotType_FloatValueSlot,
    SlotType_BoolValueSlot
  };
  return values;
}

inline const char * const *EnumNamesSlotType() {
  static const char * const names[5] = {
    "TensorSlot",
    "IntValueSlot",
    "FloatValueSlot",
    "BoolValueSlot",
    nullptr
  };
  return names;
}

inline const char *EnumNameSlotType(SlotType e) {
  if (::flatbuffers::IsOutRange(e, SlotType_TensorSlot, SlotType_BoolValueSlot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSlotType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Tid FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t idx_;

 public:
  Tid()
      : idx_(0) {
  }
  Tid(uint32_t _idx)
      : idx_(::flatbuffers::EndianScalar(_idx)) {
  }
  uint32_t idx() const {
    return ::flatbuffers::EndianScalar(idx_);
  }
};
FLATBUFFERS_STRUCT_END(Tid, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vid FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t idx_;

 public:
  Vid()
      : idx_(0) {
  }
  Vid(uint32_t _idx)
      : idx_(::flatbuffers::EndianScalar(_idx)) {
  }
  uint32_t idx() const {
    return ::flatbuffers::EndianScalar(idx_);
  }
};
FLATBUFFERS_STRUCT_END(Vid, 4);

struct IntOrVid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntOrVidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LITERAL = 4,
    VT_VID = 6,
    VT_IS_VID = 8
  };
  int64_t literal() const {
    return GetField<int64_t>(VT_LITERAL, 0);
  }
  const mlx_delegate::Vid *vid() const {
    return GetStruct<const mlx_delegate::Vid *>(VT_VID);
  }
  bool is_vid() const {
    return GetField<uint8_t>(VT_IS_VID, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LITERAL, 8) &&
           VerifyField<mlx_delegate::Vid>(verifier, VT_VID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_VID, 1) &&
           verifier.EndTable();
  }
};

struct IntOrVidBuilder {
  typedef IntOrVid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_literal(int64_t literal) {
    fbb_.AddElement<int64_t>(IntOrVid::VT_LITERAL, literal, 0);
  }
  void add_vid(const mlx_delegate::Vid *vid) {
    fbb_.AddStruct(IntOrVid::VT_VID, vid);
  }
  void add_is_vid(bool is_vid) {
    fbb_.AddElement<uint8_t>(IntOrVid::VT_IS_VID, static_cast<uint8_t>(is_vid), 0);
  }
  explicit IntOrVidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntOrVid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntOrVid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntOrVid> CreateIntOrVid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t literal = 0,
    const mlx_delegate::Vid *vid = nullptr,
    bool is_vid = false) {
  IntOrVidBuilder builder_(_fbb);
  builder_.add_literal(literal);
  builder_.add_vid(vid);
  builder_.add_is_vid(is_vid);
  return builder_.Finish();
}

struct FloatOrVid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatOrVidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LITERAL = 4,
    VT_VID = 6,
    VT_IS_VID = 8
  };
  double literal() const {
    return GetField<double>(VT_LITERAL, 0.0);
  }
  const mlx_delegate::Vid *vid() const {
    return GetStruct<const mlx_delegate::Vid *>(VT_VID);
  }
  bool is_vid() const {
    return GetField<uint8_t>(VT_IS_VID, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LITERAL, 8) &&
           VerifyField<mlx_delegate::Vid>(verifier, VT_VID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_VID, 1) &&
           verifier.EndTable();
  }
};

struct FloatOrVidBuilder {
  typedef FloatOrVid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_literal(double literal) {
    fbb_.AddElement<double>(FloatOrVid::VT_LITERAL, literal, 0.0);
  }
  void add_vid(const mlx_delegate::Vid *vid) {
    fbb_.AddStruct(FloatOrVid::VT_VID, vid);
  }
  void add_is_vid(bool is_vid) {
    fbb_.AddElement<uint8_t>(FloatOrVid::VT_IS_VID, static_cast<uint8_t>(is_vid), 0);
  }
  explicit FloatOrVidBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatOrVid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatOrVid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatOrVid> CreateFloatOrVid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double literal = 0.0,
    const mlx_delegate::Vid *vid = nullptr,
    bool is_vid = false) {
  FloatOrVidBuilder builder_(_fbb);
  builder_.add_literal(literal);
  builder_.add_vid(vid);
  builder_.add_is_vid(is_vid);
  return builder_.Finish();
}

struct NoopNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NoopNodeBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NoopNodeBuilder {
  typedef NoopNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NoopNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NoopNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NoopNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NoopNode> CreateNoopNode(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NoopNodeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LinearNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinearNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_WEIGHT = 6,
    VT_OUT = 8,
    VT_BIAS = 10
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *weight() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_WEIGHT);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const mlx_delegate::Tid *bias() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_BIAS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_WEIGHT, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_BIAS, 4) &&
           verifier.EndTable();
  }
};

struct LinearNodeBuilder {
  typedef LinearNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(LinearNode::VT_X, x);
  }
  void add_weight(const mlx_delegate::Tid *weight) {
    fbb_.AddStruct(LinearNode::VT_WEIGHT, weight);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(LinearNode::VT_OUT, out);
  }
  void add_bias(const mlx_delegate::Tid *bias) {
    fbb_.AddStruct(LinearNode::VT_BIAS, bias);
  }
  explicit LinearNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinearNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinearNode>(end);
    fbb_.Required(o, LinearNode::VT_X);
    fbb_.Required(o, LinearNode::VT_WEIGHT);
    fbb_.Required(o, LinearNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<LinearNode> CreateLinearNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *weight = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const mlx_delegate::Tid *bias = nullptr) {
  LinearNodeBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_out(out);
  builder_.add_weight(weight);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ItemIntNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ItemIntNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Vid *out() const {
    return GetStruct<const mlx_delegate::Vid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Vid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct ItemIntNodeBuilder {
  typedef ItemIntNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(ItemIntNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Vid *out) {
    fbb_.AddStruct(ItemIntNode::VT_OUT, out);
  }
  explicit ItemIntNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ItemIntNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ItemIntNode>(end);
    fbb_.Required(o, ItemIntNode::VT_X);
    fbb_.Required(o, ItemIntNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<ItemIntNode> CreateItemIntNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Vid *out = nullptr) {
  ItemIntNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ExpandDimsNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpandDimsNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_AXIS = 8
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct ExpandDimsNodeBuilder {
  typedef ExpandDimsNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(ExpandDimsNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ExpandDimsNode::VT_OUT, out);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ExpandDimsNode::VT_AXIS, axis, 0);
  }
  explicit ExpandDimsNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpandDimsNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpandDimsNode>(end);
    fbb_.Required(o, ExpandDimsNode::VT_X);
    fbb_.Required(o, ExpandDimsNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpandDimsNode> CreateExpandDimsNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    int32_t axis = 0) {
  ExpandDimsNodeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct TileNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TileNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_REPS = 8
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const ::flatbuffers::Vector<int32_t> *reps() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_REPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_REPS) &&
           verifier.VerifyVector(reps()) &&
           verifier.EndTable();
  }
};

struct TileNodeBuilder {
  typedef TileNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(TileNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(TileNode::VT_OUT, out);
  }
  void add_reps(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> reps) {
    fbb_.AddOffset(TileNode::VT_REPS, reps);
  }
  explicit TileNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TileNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TileNode>(end);
    fbb_.Required(o, TileNode::VT_X);
    fbb_.Required(o, TileNode::VT_OUT);
    fbb_.Required(o, TileNode::VT_REPS);
    return o;
  }
};

inline ::flatbuffers::Offset<TileNode> CreateTileNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> reps = 0) {
  TileNodeBuilder builder_(_fbb);
  builder_.add_reps(reps);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TileNode> CreateTileNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const std::vector<int32_t> *reps = nullptr) {
  auto reps__ = reps ? _fbb.CreateVector<int32_t>(*reps) : 0;
  return mlx_delegate::CreateTileNode(
      _fbb,
      x,
      out,
      reps__);
}

struct TakeAlongAxisNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TakeAlongAxisNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_INDICES = 6,
    VT_OUT = 8,
    VT_AXIS = 10
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *indices() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_INDICES);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_INDICES, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct TakeAlongAxisNodeBuilder {
  typedef TakeAlongAxisNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(TakeAlongAxisNode::VT_X, x);
  }
  void add_indices(const mlx_delegate::Tid *indices) {
    fbb_.AddStruct(TakeAlongAxisNode::VT_INDICES, indices);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(TakeAlongAxisNode::VT_OUT, out);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(TakeAlongAxisNode::VT_AXIS, axis, 0);
  }
  explicit TakeAlongAxisNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TakeAlongAxisNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TakeAlongAxisNode>(end);
    fbb_.Required(o, TakeAlongAxisNode::VT_X);
    fbb_.Required(o, TakeAlongAxisNode::VT_INDICES);
    fbb_.Required(o, TakeAlongAxisNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<TakeAlongAxisNode> CreateTakeAlongAxisNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *indices = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    int32_t axis = 0) {
  TakeAlongAxisNodeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_out(out);
  builder_.add_indices(indices);
  builder_.add_x(x);
  return builder_.Finish();
}

struct RMSNormNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RMSNormNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_WEIGHT = 6,
    VT_OUT = 8,
    VT_EPS = 10
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *weight() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_WEIGHT);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_WEIGHT, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           verifier.EndTable();
  }
};

struct RMSNormNodeBuilder {
  typedef RMSNormNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(RMSNormNode::VT_X, x);
  }
  void add_weight(const mlx_delegate::Tid *weight) {
    fbb_.AddStruct(RMSNormNode::VT_WEIGHT, weight);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(RMSNormNode::VT_OUT, out);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(RMSNormNode::VT_EPS, eps, 0.0f);
  }
  explicit RMSNormNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RMSNormNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RMSNormNode>(end);
    fbb_.Required(o, RMSNormNode::VT_X);
    fbb_.Required(o, RMSNormNode::VT_WEIGHT);
    fbb_.Required(o, RMSNormNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<RMSNormNode> CreateRMSNormNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *weight = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    float eps = 0.0f) {
  RMSNormNodeBuilder builder_(_fbb);
  builder_.add_eps(eps);
  builder_.add_out(out);
  builder_.add_weight(weight);
  builder_.add_x(x);
  return builder_.Finish();
}

struct LayerNormNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerNormNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_WEIGHT = 8,
    VT_BIAS = 10,
    VT_EPS = 12
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const mlx_delegate::Tid *weight() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_WEIGHT);
  }
  const mlx_delegate::Tid *bias() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_BIAS);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_WEIGHT, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_BIAS, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           verifier.EndTable();
  }
};

struct LayerNormNodeBuilder {
  typedef LayerNormNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(LayerNormNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(LayerNormNode::VT_OUT, out);
  }
  void add_weight(const mlx_delegate::Tid *weight) {
    fbb_.AddStruct(LayerNormNode::VT_WEIGHT, weight);
  }
  void add_bias(const mlx_delegate::Tid *bias) {
    fbb_.AddStruct(LayerNormNode::VT_BIAS, bias);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(LayerNormNode::VT_EPS, eps, 0.0f);
  }
  explicit LayerNormNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerNormNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerNormNode>(end);
    fbb_.Required(o, LayerNormNode::VT_X);
    fbb_.Required(o, LayerNormNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerNormNode> CreateLayerNormNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const mlx_delegate::Tid *weight = nullptr,
    const mlx_delegate::Tid *bias = nullptr,
    float eps = 0.0f) {
  LayerNormNodeBuilder builder_(_fbb);
  builder_.add_eps(eps);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct RopeNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RopeNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Q_IN = 4,
    VT_K_IN = 6,
    VT_Q_OUT = 8,
    VT_K_OUT = 10,
    VT_HEAD_DIM = 12,
    VT_POS = 14,
    VT_FREQS = 16,
    VT_TRADITIONAL = 18,
    VT_BASE = 20,
    VT_BASE_IS_SET = 22,
    VT_SCALE = 24
  };
  const mlx_delegate::Tid *q_in() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_Q_IN);
  }
  const mlx_delegate::Tid *k_in() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_K_IN);
  }
  const mlx_delegate::Tid *q_out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_Q_OUT);
  }
  const mlx_delegate::Tid *k_out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_K_OUT);
  }
  int32_t head_dim() const {
    return GetField<int32_t>(VT_HEAD_DIM, 0);
  }
  const mlx_delegate::Vid *pos() const {
    return GetStruct<const mlx_delegate::Vid *>(VT_POS);
  }
  const mlx_delegate::Tid *freqs() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_FREQS);
  }
  bool traditional() const {
    return GetField<uint8_t>(VT_TRADITIONAL, 0) != 0;
  }
  float base() const {
    return GetField<float>(VT_BASE, 0.0f);
  }
  bool base_is_set() const {
    return GetField<uint8_t>(VT_BASE_IS_SET, 0) != 0;
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_Q_IN, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_K_IN, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_Q_OUT, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_K_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_HEAD_DIM, 4) &&
           VerifyFieldRequired<mlx_delegate::Vid>(verifier, VT_POS, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_FREQS, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRADITIONAL, 1) &&
           VerifyField<float>(verifier, VT_BASE, 4) &&
           VerifyField<uint8_t>(verifier, VT_BASE_IS_SET, 1) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct RopeNodeBuilder {
  typedef RopeNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_q_in(const mlx_delegate::Tid *q_in) {
    fbb_.AddStruct(RopeNode::VT_Q_IN, q_in);
  }
  void add_k_in(const mlx_delegate::Tid *k_in) {
    fbb_.AddStruct(RopeNode::VT_K_IN, k_in);
  }
  void add_q_out(const mlx_delegate::Tid *q_out) {
    fbb_.AddStruct(RopeNode::VT_Q_OUT, q_out);
  }
  void add_k_out(const mlx_delegate::Tid *k_out) {
    fbb_.AddStruct(RopeNode::VT_K_OUT, k_out);
  }
  void add_head_dim(int32_t head_dim) {
    fbb_.AddElement<int32_t>(RopeNode::VT_HEAD_DIM, head_dim, 0);
  }
  void add_pos(const mlx_delegate::Vid *pos) {
    fbb_.AddStruct(RopeNode::VT_POS, pos);
  }
  void add_freqs(const mlx_delegate::Tid *freqs) {
    fbb_.AddStruct(RopeNode::VT_FREQS, freqs);
  }
  void add_traditional(bool traditional) {
    fbb_.AddElement<uint8_t>(RopeNode::VT_TRADITIONAL, static_cast<uint8_t>(traditional), 0);
  }
  void add_base(float base) {
    fbb_.AddElement<float>(RopeNode::VT_BASE, base, 0.0f);
  }
  void add_base_is_set(bool base_is_set) {
    fbb_.AddElement<uint8_t>(RopeNode::VT_BASE_IS_SET, static_cast<uint8_t>(base_is_set), 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(RopeNode::VT_SCALE, scale, 1.0f);
  }
  explicit RopeNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RopeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RopeNode>(end);
    fbb_.Required(o, RopeNode::VT_Q_IN);
    fbb_.Required(o, RopeNode::VT_K_IN);
    fbb_.Required(o, RopeNode::VT_Q_OUT);
    fbb_.Required(o, RopeNode::VT_K_OUT);
    fbb_.Required(o, RopeNode::VT_POS);
    return o;
  }
};

inline ::flatbuffers::Offset<RopeNode> CreateRopeNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *q_in = nullptr,
    const mlx_delegate::Tid *k_in = nullptr,
    const mlx_delegate::Tid *q_out = nullptr,
    const mlx_delegate::Tid *k_out = nullptr,
    int32_t head_dim = 0,
    const mlx_delegate::Vid *pos = nullptr,
    const mlx_delegate::Tid *freqs = nullptr,
    bool traditional = false,
    float base = 0.0f,
    bool base_is_set = false,
    float scale = 1.0f) {
  RopeNodeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_base(base);
  builder_.add_freqs(freqs);
  builder_.add_pos(pos);
  builder_.add_head_dim(head_dim);
  builder_.add_k_out(k_out);
  builder_.add_q_out(q_out);
  builder_.add_k_in(k_in);
  builder_.add_q_in(q_in);
  builder_.add_base_is_set(base_is_set);
  builder_.add_traditional(traditional);
  return builder_.Finish();
}

struct SdpaNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SdpaNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Q = 4,
    VT_K = 6,
    VT_V = 8,
    VT_OUT = 10,
    VT_SCALE = 12,
    VT_MASK = 14,
    VT_CAUSAL = 16
  };
  const mlx_delegate::Tid *q() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_Q);
  }
  const mlx_delegate::Tid *k() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_K);
  }
  const mlx_delegate::Tid *v() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_V);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  const mlx_delegate::Tid *mask() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_MASK);
  }
  bool causal() const {
    return GetField<uint8_t>(VT_CAUSAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_Q, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_K, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_V, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_MASK, 4) &&
           VerifyField<uint8_t>(verifier, VT_CAUSAL, 1) &&
           verifier.EndTable();
  }
};

struct SdpaNodeBuilder {
  typedef SdpaNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_q(const mlx_delegate::Tid *q) {
    fbb_.AddStruct(SdpaNode::VT_Q, q);
  }
  void add_k(const mlx_delegate::Tid *k) {
    fbb_.AddStruct(SdpaNode::VT_K, k);
  }
  void add_v(const mlx_delegate::Tid *v) {
    fbb_.AddStruct(SdpaNode::VT_V, v);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(SdpaNode::VT_OUT, out);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(SdpaNode::VT_SCALE, scale, 0.0f);
  }
  void add_mask(const mlx_delegate::Tid *mask) {
    fbb_.AddStruct(SdpaNode::VT_MASK, mask);
  }
  void add_causal(bool causal) {
    fbb_.AddElement<uint8_t>(SdpaNode::VT_CAUSAL, static_cast<uint8_t>(causal), 0);
  }
  explicit SdpaNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SdpaNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SdpaNode>(end);
    fbb_.Required(o, SdpaNode::VT_Q);
    fbb_.Required(o, SdpaNode::VT_K);
    fbb_.Required(o, SdpaNode::VT_V);
    fbb_.Required(o, SdpaNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<SdpaNode> CreateSdpaNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *q = nullptr,
    const mlx_delegate::Tid *k = nullptr,
    const mlx_delegate::Tid *v = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    float scale = 0.0f,
    const mlx_delegate::Tid *mask = nullptr,
    bool causal = false) {
  SdpaNodeBuilder builder_(_fbb);
  builder_.add_mask(mask);
  builder_.add_scale(scale);
  builder_.add_out(out);
  builder_.add_v(v);
  builder_.add_k(k);
  builder_.add_q(q);
  builder_.add_causal(causal);
  return builder_.Finish();
}

struct AddNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_OUT = 8
  };
  const mlx_delegate::Tid *a() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_A);
  }
  const mlx_delegate::Tid *b() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_B);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_A, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_B, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct AddNodeBuilder {
  typedef AddNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(const mlx_delegate::Tid *a) {
    fbb_.AddStruct(AddNode::VT_A, a);
  }
  void add_b(const mlx_delegate::Tid *b) {
    fbb_.AddStruct(AddNode::VT_B, b);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(AddNode::VT_OUT, out);
  }
  explicit AddNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddNode>(end);
    fbb_.Required(o, AddNode::VT_A);
    fbb_.Required(o, AddNode::VT_B);
    fbb_.Required(o, AddNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<AddNode> CreateAddNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *a = nullptr,
    const mlx_delegate::Tid *b = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  AddNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

struct AddScalarNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddScalarNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_OUT = 8
  };
  const mlx_delegate::IntOrVid *a() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_A);
  }
  const mlx_delegate::IntOrVid *b() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_B);
  }
  const mlx_delegate::Vid *out() const {
    return GetStruct<const mlx_delegate::Vid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_A) &&
           verifier.VerifyTable(a()) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyTable(b()) &&
           VerifyFieldRequired<mlx_delegate::Vid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct AddScalarNodeBuilder {
  typedef AddScalarNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(::flatbuffers::Offset<mlx_delegate::IntOrVid> a) {
    fbb_.AddOffset(AddScalarNode::VT_A, a);
  }
  void add_b(::flatbuffers::Offset<mlx_delegate::IntOrVid> b) {
    fbb_.AddOffset(AddScalarNode::VT_B, b);
  }
  void add_out(const mlx_delegate::Vid *out) {
    fbb_.AddStruct(AddScalarNode::VT_OUT, out);
  }
  explicit AddScalarNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddScalarNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddScalarNode>(end);
    fbb_.Required(o, AddScalarNode::VT_A);
    fbb_.Required(o, AddScalarNode::VT_B);
    fbb_.Required(o, AddScalarNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<AddScalarNode> CreateAddScalarNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> a = 0,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> b = 0,
    const mlx_delegate::Vid *out = nullptr) {
  AddScalarNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

struct SymSizeNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SymSizeNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_DIM = 6,
    VT_OUT = 8
  };
  const mlx_delegate::Tid *a() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_A);
  }
  int32_t dim() const {
    return GetField<int32_t>(VT_DIM, 0);
  }
  const mlx_delegate::Vid *out() const {
    return GetStruct<const mlx_delegate::Vid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_A, 4) &&
           VerifyField<int32_t>(verifier, VT_DIM, 4) &&
           VerifyFieldRequired<mlx_delegate::Vid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct SymSizeNodeBuilder {
  typedef SymSizeNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(const mlx_delegate::Tid *a) {
    fbb_.AddStruct(SymSizeNode::VT_A, a);
  }
  void add_dim(int32_t dim) {
    fbb_.AddElement<int32_t>(SymSizeNode::VT_DIM, dim, 0);
  }
  void add_out(const mlx_delegate::Vid *out) {
    fbb_.AddStruct(SymSizeNode::VT_OUT, out);
  }
  explicit SymSizeNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SymSizeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SymSizeNode>(end);
    fbb_.Required(o, SymSizeNode::VT_A);
    fbb_.Required(o, SymSizeNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<SymSizeNode> CreateSymSizeNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *a = nullptr,
    int32_t dim = 0,
    const mlx_delegate::Vid *out = nullptr) {
  SymSizeNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_dim(dim);
  builder_.add_a(a);
  return builder_.Finish();
}

struct MulNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MulNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_OUT = 8
  };
  const mlx_delegate::Tid *a() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_A);
  }
  const mlx_delegate::Tid *b() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_B);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_A, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_B, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct MulNodeBuilder {
  typedef MulNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(const mlx_delegate::Tid *a) {
    fbb_.AddStruct(MulNode::VT_A, a);
  }
  void add_b(const mlx_delegate::Tid *b) {
    fbb_.AddStruct(MulNode::VT_B, b);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(MulNode::VT_OUT, out);
  }
  explicit MulNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MulNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MulNode>(end);
    fbb_.Required(o, MulNode::VT_A);
    fbb_.Required(o, MulNode::VT_B);
    fbb_.Required(o, MulNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<MulNode> CreateMulNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *a = nullptr,
    const mlx_delegate::Tid *b = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  MulNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

struct Conv1DNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conv1DNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_W = 6,
    VT_OUT = 8,
    VT_STRIDE = 10,
    VT_PADDING = 12,
    VT_DILATION = 14,
    VT_GROUPS = 16
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *w() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_W);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  int32_t stride() const {
    return GetField<int32_t>(VT_STRIDE, 1);
  }
  int32_t padding() const {
    return GetField<int32_t>(VT_PADDING, 0);
  }
  int32_t dilation() const {
    return GetField<int32_t>(VT_DILATION, 1);
  }
  int32_t groups() const {
    return GetField<int32_t>(VT_GROUPS, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_W, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_PADDING, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATION, 4) &&
           VerifyField<int32_t>(verifier, VT_GROUPS, 4) &&
           verifier.EndTable();
  }
};

struct Conv1DNodeBuilder {
  typedef Conv1DNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(Conv1DNode::VT_X, x);
  }
  void add_w(const mlx_delegate::Tid *w) {
    fbb_.AddStruct(Conv1DNode::VT_W, w);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(Conv1DNode::VT_OUT, out);
  }
  void add_stride(int32_t stride) {
    fbb_.AddElement<int32_t>(Conv1DNode::VT_STRIDE, stride, 1);
  }
  void add_padding(int32_t padding) {
    fbb_.AddElement<int32_t>(Conv1DNode::VT_PADDING, padding, 0);
  }
  void add_dilation(int32_t dilation) {
    fbb_.AddElement<int32_t>(Conv1DNode::VT_DILATION, dilation, 1);
  }
  void add_groups(int32_t groups) {
    fbb_.AddElement<int32_t>(Conv1DNode::VT_GROUPS, groups, 1);
  }
  explicit Conv1DNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conv1DNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conv1DNode>(end);
    fbb_.Required(o, Conv1DNode::VT_X);
    fbb_.Required(o, Conv1DNode::VT_W);
    fbb_.Required(o, Conv1DNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<Conv1DNode> CreateConv1DNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *w = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    int32_t stride = 1,
    int32_t padding = 0,
    int32_t dilation = 1,
    int32_t groups = 1) {
  Conv1DNodeBuilder builder_(_fbb);
  builder_.add_groups(groups);
  builder_.add_dilation(dilation);
  builder_.add_padding(padding);
  builder_.add_stride(stride);
  builder_.add_out(out);
  builder_.add_w(w);
  builder_.add_x(x);
  return builder_.Finish();
}

struct GeluNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeluNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct GeluNodeBuilder {
  typedef GeluNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(GeluNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(GeluNode::VT_OUT, out);
  }
  explicit GeluNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeluNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeluNode>(end);
    fbb_.Required(o, GeluNode::VT_X);
    fbb_.Required(o, GeluNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<GeluNode> CreateGeluNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  GeluNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ARangeNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ARangeNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT = 4,
    VT_START = 6,
    VT_STOP = 8,
    VT_STEP = 10,
    VT_DTYPE = 12,
    VT_DTYPE_IS_SET = 14
  };
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  int32_t start() const {
    return GetField<int32_t>(VT_START, 0);
  }
  int32_t stop() const {
    return GetField<int32_t>(VT_STOP, 0);
  }
  int32_t step() const {
    return GetField<int32_t>(VT_STEP, 1);
  }
  mlx_delegate::DTypeId dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_DTYPE, 0));
  }
  bool dtype_is_set() const {
    return GetField<uint8_t>(VT_DTYPE_IS_SET, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_START, 4) &&
           VerifyField<int32_t>(verifier, VT_STOP, 4) &&
           VerifyField<int32_t>(verifier, VT_STEP, 4) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DTYPE_IS_SET, 1) &&
           verifier.EndTable();
  }
};

struct ARangeNodeBuilder {
  typedef ARangeNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ARangeNode::VT_OUT, out);
  }
  void add_start(int32_t start) {
    fbb_.AddElement<int32_t>(ARangeNode::VT_START, start, 0);
  }
  void add_stop(int32_t stop) {
    fbb_.AddElement<int32_t>(ARangeNode::VT_STOP, stop, 0);
  }
  void add_step(int32_t step) {
    fbb_.AddElement<int32_t>(ARangeNode::VT_STEP, step, 1);
  }
  void add_dtype(mlx_delegate::DTypeId dtype) {
    fbb_.AddElement<int8_t>(ARangeNode::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_dtype_is_set(bool dtype_is_set) {
    fbb_.AddElement<uint8_t>(ARangeNode::VT_DTYPE_IS_SET, static_cast<uint8_t>(dtype_is_set), 0);
  }
  explicit ARangeNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ARangeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ARangeNode>(end);
    fbb_.Required(o, ARangeNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<ARangeNode> CreateARangeNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    int32_t start = 0,
    int32_t stop = 0,
    int32_t step = 1,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16,
    bool dtype_is_set = false) {
  ARangeNodeBuilder builder_(_fbb);
  builder_.add_step(step);
  builder_.add_stop(stop);
  builder_.add_start(start);
  builder_.add_out(out);
  builder_.add_dtype_is_set(dtype_is_set);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

struct SiluNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SiluNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct SiluNodeBuilder {
  typedef SiluNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(SiluNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(SiluNode::VT_OUT, out);
  }
  explicit SiluNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SiluNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SiluNode>(end);
    fbb_.Required(o, SiluNode::VT_X);
    fbb_.Required(o, SiluNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<SiluNode> CreateSiluNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  SiluNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ReshapeNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReshapeNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_SHAPE = 8
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>> *>(VT_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.VerifyVectorOfTables(shape()) &&
           verifier.EndTable();
  }
};

struct ReshapeNodeBuilder {
  typedef ReshapeNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(ReshapeNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ReshapeNode::VT_OUT, out);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>>> shape) {
    fbb_.AddOffset(ReshapeNode::VT_SHAPE, shape);
  }
  explicit ReshapeNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReshapeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReshapeNode>(end);
    fbb_.Required(o, ReshapeNode::VT_X);
    fbb_.Required(o, ReshapeNode::VT_OUT);
    fbb_.Required(o, ReshapeNode::VT_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<ReshapeNode> CreateReshapeNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>>> shape = 0) {
  ReshapeNodeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReshapeNode> CreateReshapeNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const std::vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::IntOrVid>>(*shape) : 0;
  return mlx_delegate::CreateReshapeNode(
      _fbb,
      x,
      out,
      shape__);
}

struct TransposeNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransposeNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_PERM = 8
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const ::flatbuffers::Vector<int32_t> *perm() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PERM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_PERM) &&
           verifier.VerifyVector(perm()) &&
           verifier.EndTable();
  }
};

struct TransposeNodeBuilder {
  typedef TransposeNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(TransposeNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(TransposeNode::VT_OUT, out);
  }
  void add_perm(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> perm) {
    fbb_.AddOffset(TransposeNode::VT_PERM, perm);
  }
  explicit TransposeNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransposeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransposeNode>(end);
    fbb_.Required(o, TransposeNode::VT_X);
    fbb_.Required(o, TransposeNode::VT_OUT);
    fbb_.Required(o, TransposeNode::VT_PERM);
    return o;
  }
};

inline ::flatbuffers::Offset<TransposeNode> CreateTransposeNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> perm = 0) {
  TransposeNodeBuilder builder_(_fbb);
  builder_.add_perm(perm);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TransposeNode> CreateTransposeNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const std::vector<int32_t> *perm = nullptr) {
  auto perm__ = perm ? _fbb.CreateVector<int32_t>(*perm) : 0;
  return mlx_delegate::CreateTransposeNode(
      _fbb,
      x,
      out,
      perm__);
}

struct ContiguousNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContiguousNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct ContiguousNodeBuilder {
  typedef ContiguousNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(ContiguousNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ContiguousNode::VT_OUT, out);
  }
  explicit ContiguousNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContiguousNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContiguousNode>(end);
    fbb_.Required(o, ContiguousNode::VT_X);
    fbb_.Required(o, ContiguousNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<ContiguousNode> CreateContiguousNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  ContiguousNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct IdCopyNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IdCopyNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct IdCopyNodeBuilder {
  typedef IdCopyNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(IdCopyNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(IdCopyNode::VT_OUT, out);
  }
  explicit IdCopyNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IdCopyNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IdCopyNode>(end);
    fbb_.Required(o, IdCopyNode::VT_X);
    fbb_.Required(o, IdCopyNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<IdCopyNode> CreateIdCopyNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  IdCopyNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct GatherNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GatherNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_ = 4,
    VT_IDS = 6,
    VT_OUT = 8
  };
  const mlx_delegate::Tid *table_() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_TABLE_);
  }
  const mlx_delegate::Tid *ids() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_IDS);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_TABLE_, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_IDS, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           verifier.EndTable();
  }
};

struct GatherNodeBuilder {
  typedef GatherNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table_(const mlx_delegate::Tid *table_) {
    fbb_.AddStruct(GatherNode::VT_TABLE_, table_);
  }
  void add_ids(const mlx_delegate::Tid *ids) {
    fbb_.AddStruct(GatherNode::VT_IDS, ids);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(GatherNode::VT_OUT, out);
  }
  explicit GatherNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatherNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatherNode>(end);
    fbb_.Required(o, GatherNode::VT_TABLE_);
    fbb_.Required(o, GatherNode::VT_IDS);
    fbb_.Required(o, GatherNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<GatherNode> CreateGatherNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *table_ = nullptr,
    const mlx_delegate::Tid *ids = nullptr,
    const mlx_delegate::Tid *out = nullptr) {
  GatherNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_ids(ids);
  builder_.add_table_(table_);
  return builder_.Finish();
}

struct SliceNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliceNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_AXIS = 8,
    VT_START = 10,
    VT_END = 12
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const mlx_delegate::IntOrVid *axis() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_AXIS);
  }
  const mlx_delegate::IntOrVid *start() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_START);
  }
  const mlx_delegate::IntOrVid *end() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_END);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_AXIS) &&
           verifier.VerifyTable(axis()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffsetRequired(verifier, VT_END) &&
           verifier.VerifyTable(end()) &&
           verifier.EndTable();
  }
};

struct SliceNodeBuilder {
  typedef SliceNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(SliceNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(SliceNode::VT_OUT, out);
  }
  void add_axis(::flatbuffers::Offset<mlx_delegate::IntOrVid> axis) {
    fbb_.AddOffset(SliceNode::VT_AXIS, axis);
  }
  void add_start(::flatbuffers::Offset<mlx_delegate::IntOrVid> start) {
    fbb_.AddOffset(SliceNode::VT_START, start);
  }
  void add_end(::flatbuffers::Offset<mlx_delegate::IntOrVid> end) {
    fbb_.AddOffset(SliceNode::VT_END, end);
  }
  explicit SliceNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SliceNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SliceNode>(end);
    fbb_.Required(o, SliceNode::VT_X);
    fbb_.Required(o, SliceNode::VT_OUT);
    fbb_.Required(o, SliceNode::VT_AXIS);
    fbb_.Required(o, SliceNode::VT_START);
    fbb_.Required(o, SliceNode::VT_END);
    return o;
  }
};

inline ::flatbuffers::Offset<SliceNode> CreateSliceNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> axis = 0,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> start = 0,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> end = 0) {
  SliceNodeBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_axis(axis);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct CastNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CastNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_DTYPE = 8
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  mlx_delegate::DTypeId dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct CastNodeBuilder {
  typedef CastNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(CastNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(CastNode::VT_OUT, out);
  }
  void add_dtype(mlx_delegate::DTypeId dtype) {
    fbb_.AddElement<int8_t>(CastNode::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  explicit CastNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CastNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CastNode>(end);
    fbb_.Required(o, CastNode::VT_X);
    fbb_.Required(o, CastNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<CastNode> CreateCastNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  CastNodeBuilder builder_(_fbb);
  builder_.add_out(out);
  builder_.add_x(x);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

struct QuantizedLinearNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedLinearNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_W = 6,
    VT_SCALES = 8,
    VT_OUT = 10,
    VT_BIASES = 12,
    VT_BIAS = 14,
    VT_GROUP_SIZE = 16,
    VT_BITS = 18,
    VT_MODE = 20,
    VT_OUT_DTYPE = 22
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *w() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_W);
  }
  const mlx_delegate::Tid *scales() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_SCALES);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const mlx_delegate::Tid *biases() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_BIASES);
  }
  const mlx_delegate::Tid *bias() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_BIAS);
  }
  int32_t group_size() const {
    return GetField<int32_t>(VT_GROUP_SIZE, 0);
  }
  int32_t bits() const {
    return GetField<int32_t>(VT_BITS, 0);
  }
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  mlx_delegate::DTypeId out_dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_OUT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_W, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_SCALES, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_BIASES, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_BIAS, 4) &&
           VerifyField<int32_t>(verifier, VT_GROUP_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_BITS, 4) &&
           VerifyOffsetRequired(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyField<int8_t>(verifier, VT_OUT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct QuantizedLinearNodeBuilder {
  typedef QuantizedLinearNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(QuantizedLinearNode::VT_X, x);
  }
  void add_w(const mlx_delegate::Tid *w) {
    fbb_.AddStruct(QuantizedLinearNode::VT_W, w);
  }
  void add_scales(const mlx_delegate::Tid *scales) {
    fbb_.AddStruct(QuantizedLinearNode::VT_SCALES, scales);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(QuantizedLinearNode::VT_OUT, out);
  }
  void add_biases(const mlx_delegate::Tid *biases) {
    fbb_.AddStruct(QuantizedLinearNode::VT_BIASES, biases);
  }
  void add_bias(const mlx_delegate::Tid *bias) {
    fbb_.AddStruct(QuantizedLinearNode::VT_BIAS, bias);
  }
  void add_group_size(int32_t group_size) {
    fbb_.AddElement<int32_t>(QuantizedLinearNode::VT_GROUP_SIZE, group_size, 0);
  }
  void add_bits(int32_t bits) {
    fbb_.AddElement<int32_t>(QuantizedLinearNode::VT_BITS, bits, 0);
  }
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(QuantizedLinearNode::VT_MODE, mode);
  }
  void add_out_dtype(mlx_delegate::DTypeId out_dtype) {
    fbb_.AddElement<int8_t>(QuantizedLinearNode::VT_OUT_DTYPE, static_cast<int8_t>(out_dtype), 0);
  }
  explicit QuantizedLinearNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedLinearNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedLinearNode>(end);
    fbb_.Required(o, QuantizedLinearNode::VT_X);
    fbb_.Required(o, QuantizedLinearNode::VT_W);
    fbb_.Required(o, QuantizedLinearNode::VT_SCALES);
    fbb_.Required(o, QuantizedLinearNode::VT_OUT);
    fbb_.Required(o, QuantizedLinearNode::VT_MODE);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedLinearNode> CreateQuantizedLinearNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *w = nullptr,
    const mlx_delegate::Tid *scales = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const mlx_delegate::Tid *biases = nullptr,
    const mlx_delegate::Tid *bias = nullptr,
    int32_t group_size = 0,
    int32_t bits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    mlx_delegate::DTypeId out_dtype = mlx_delegate::DTypeId_f16) {
  QuantizedLinearNodeBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_bits(bits);
  builder_.add_group_size(group_size);
  builder_.add_bias(bias);
  builder_.add_biases(biases);
  builder_.add_out(out);
  builder_.add_scales(scales);
  builder_.add_w(w);
  builder_.add_x(x);
  builder_.add_out_dtype(out_dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizedLinearNode> CreateQuantizedLinearNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *w = nullptr,
    const mlx_delegate::Tid *scales = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const mlx_delegate::Tid *biases = nullptr,
    const mlx_delegate::Tid *bias = nullptr,
    int32_t group_size = 0,
    int32_t bits = 0,
    const char *mode = nullptr,
    mlx_delegate::DTypeId out_dtype = mlx_delegate::DTypeId_f16) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  return mlx_delegate::CreateQuantizedLinearNode(
      _fbb,
      x,
      w,
      scales,
      out,
      biases,
      bias,
      group_size,
      bits,
      mode__,
      out_dtype);
}

struct ConcatNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConcatNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_OUT = 8,
    VT_AXIS = 10
  };
  const mlx_delegate::Tid *a() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_A);
  }
  const mlx_delegate::Tid *b() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_B);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_A, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_B, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct ConcatNodeBuilder {
  typedef ConcatNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(const mlx_delegate::Tid *a) {
    fbb_.AddStruct(ConcatNode::VT_A, a);
  }
  void add_b(const mlx_delegate::Tid *b) {
    fbb_.AddStruct(ConcatNode::VT_B, b);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ConcatNode::VT_OUT, out);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatNode::VT_AXIS, axis, 0);
  }
  explicit ConcatNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConcatNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConcatNode>(end);
    fbb_.Required(o, ConcatNode::VT_A);
    fbb_.Required(o, ConcatNode::VT_B);
    fbb_.Required(o, ConcatNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<ConcatNode> CreateConcatNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *a = nullptr,
    const mlx_delegate::Tid *b = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    int32_t axis = 0) {
  ConcatNodeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_out(out);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

struct FullNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FullNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT = 4,
    VT_SHAPE = 6,
    VT_V = 8,
    VT_DTYPE = 10
  };
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  float v() const {
    return GetField<float>(VT_V, 0.0f);
  }
  mlx_delegate::DTypeId dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<float>(verifier, VT_V, 4) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct FullNodeBuilder {
  typedef FullNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(FullNode::VT_OUT, out);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(FullNode::VT_SHAPE, shape);
  }
  void add_v(float v) {
    fbb_.AddElement<float>(FullNode::VT_V, v, 0.0f);
  }
  void add_dtype(mlx_delegate::DTypeId dtype) {
    fbb_.AddElement<int8_t>(FullNode::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  explicit FullNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FullNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FullNode>(end);
    fbb_.Required(o, FullNode::VT_OUT);
    fbb_.Required(o, FullNode::VT_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<FullNode> CreateFullNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    float v = 0.0f,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  FullNodeBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_shape(shape);
  builder_.add_out(out);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FullNode> CreateFullNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    const std::vector<int32_t> *shape = nullptr,
    float v = 0.0f,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return mlx_delegate::CreateFullNode(
      _fbb,
      out,
      shape__,
      v,
      dtype);
}

struct ZerosNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZerosNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT = 4,
    VT_SHAPE = 6,
    VT_DTYPE = 8
  };
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  mlx_delegate::DTypeId dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct ZerosNodeBuilder {
  typedef ZerosNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ZerosNode::VT_OUT, out);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(ZerosNode::VT_SHAPE, shape);
  }
  void add_dtype(mlx_delegate::DTypeId dtype) {
    fbb_.AddElement<int8_t>(ZerosNode::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  explicit ZerosNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZerosNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZerosNode>(end);
    fbb_.Required(o, ZerosNode::VT_OUT);
    fbb_.Required(o, ZerosNode::VT_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<ZerosNode> CreateZerosNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  ZerosNodeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_out(out);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ZerosNode> CreateZerosNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    const std::vector<int32_t> *shape = nullptr,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return mlx_delegate::CreateZerosNode(
      _fbb,
      out,
      shape__,
      dtype);
}

struct OnesNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnesNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT = 4,
    VT_SHAPE = 6,
    VT_DTYPE = 8
  };
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  mlx_delegate::DTypeId dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct OnesNodeBuilder {
  typedef OnesNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(OnesNode::VT_OUT, out);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(OnesNode::VT_SHAPE, shape);
  }
  void add_dtype(mlx_delegate::DTypeId dtype) {
    fbb_.AddElement<int8_t>(OnesNode::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  explicit OnesNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnesNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnesNode>(end);
    fbb_.Required(o, OnesNode::VT_OUT);
    fbb_.Required(o, OnesNode::VT_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<OnesNode> CreateOnesNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  OnesNodeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_out(out);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OnesNode> CreateOnesNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *out = nullptr,
    const std::vector<int32_t> *shape = nullptr,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return mlx_delegate::CreateOnesNode(
      _fbb,
      out,
      shape__,
      dtype);
}

struct ArgmaxNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgmaxNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_OUT = 6,
    VT_AXIS = 8
  };
  const mlx_delegate::Tid *x() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_X);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_X, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct ArgmaxNodeBuilder {
  typedef ArgmaxNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(const mlx_delegate::Tid *x) {
    fbb_.AddStruct(ArgmaxNode::VT_X, x);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(ArgmaxNode::VT_OUT, out);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgmaxNode::VT_AXIS, axis, 0);
  }
  explicit ArgmaxNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgmaxNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgmaxNode>(end);
    fbb_.Required(o, ArgmaxNode::VT_X);
    fbb_.Required(o, ArgmaxNode::VT_OUT);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgmaxNode> CreateArgmaxNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *x = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    int32_t axis = 0) {
  ArgmaxNodeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_out(out);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SliceUpdateNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliceUpdateNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DST = 4,
    VT_UPDATE = 6,
    VT_AXIS = 8,
    VT_START = 10,
    VT_STOP = 12
  };
  const mlx_delegate::Tid *dst() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_DST);
  }
  const mlx_delegate::Tid *update() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_UPDATE);
  }
  const mlx_delegate::IntOrVid *axis() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_AXIS);
  }
  const mlx_delegate::IntOrVid *start() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_START);
  }
  const mlx_delegate::IntOrVid *stop() const {
    return GetPointer<const mlx_delegate::IntOrVid *>(VT_STOP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_DST, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_UPDATE, 4) &&
           VerifyOffsetRequired(verifier, VT_AXIS) &&
           verifier.VerifyTable(axis()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffsetRequired(verifier, VT_STOP) &&
           verifier.VerifyTable(stop()) &&
           verifier.EndTable();
  }
};

struct SliceUpdateNodeBuilder {
  typedef SliceUpdateNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dst(const mlx_delegate::Tid *dst) {
    fbb_.AddStruct(SliceUpdateNode::VT_DST, dst);
  }
  void add_update(const mlx_delegate::Tid *update) {
    fbb_.AddStruct(SliceUpdateNode::VT_UPDATE, update);
  }
  void add_axis(::flatbuffers::Offset<mlx_delegate::IntOrVid> axis) {
    fbb_.AddOffset(SliceUpdateNode::VT_AXIS, axis);
  }
  void add_start(::flatbuffers::Offset<mlx_delegate::IntOrVid> start) {
    fbb_.AddOffset(SliceUpdateNode::VT_START, start);
  }
  void add_stop(::flatbuffers::Offset<mlx_delegate::IntOrVid> stop) {
    fbb_.AddOffset(SliceUpdateNode::VT_STOP, stop);
  }
  explicit SliceUpdateNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SliceUpdateNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SliceUpdateNode>(end);
    fbb_.Required(o, SliceUpdateNode::VT_DST);
    fbb_.Required(o, SliceUpdateNode::VT_UPDATE);
    fbb_.Required(o, SliceUpdateNode::VT_AXIS);
    fbb_.Required(o, SliceUpdateNode::VT_START);
    fbb_.Required(o, SliceUpdateNode::VT_STOP);
    return o;
  }
};

inline ::flatbuffers::Offset<SliceUpdateNode> CreateSliceUpdateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *dst = nullptr,
    const mlx_delegate::Tid *update = nullptr,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> axis = 0,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> start = 0,
    ::flatbuffers::Offset<mlx_delegate::IntOrVid> stop = 0) {
  SliceUpdateNodeBuilder builder_(_fbb);
  builder_.add_stop(stop);
  builder_.add_start(start);
  builder_.add_axis(axis);
  builder_.add_update(update);
  builder_.add_dst(dst);
  return builder_.Finish();
}

struct QuantizedGatherNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedGatherNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_Q = 4,
    VT_SCALES = 6,
    VT_IDS = 8,
    VT_OUT = 10,
    VT_BIASES = 12,
    VT_GROUP_SIZE = 14,
    VT_BITS = 16,
    VT_MODE = 18,
    VT_OUT_DTYPE = 20
  };
  const mlx_delegate::Tid *table_q() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_TABLE_Q);
  }
  const mlx_delegate::Tid *scales() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_SCALES);
  }
  const mlx_delegate::Tid *ids() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_IDS);
  }
  const mlx_delegate::Tid *out() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_OUT);
  }
  const mlx_delegate::Tid *biases() const {
    return GetStruct<const mlx_delegate::Tid *>(VT_BIASES);
  }
  int32_t group_size() const {
    return GetField<int32_t>(VT_GROUP_SIZE, 0);
  }
  int32_t bits() const {
    return GetField<int32_t>(VT_BITS, 0);
  }
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  mlx_delegate::DTypeId out_dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_OUT_DTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_TABLE_Q, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_SCALES, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_IDS, 4) &&
           VerifyFieldRequired<mlx_delegate::Tid>(verifier, VT_OUT, 4) &&
           VerifyField<mlx_delegate::Tid>(verifier, VT_BIASES, 4) &&
           VerifyField<int32_t>(verifier, VT_GROUP_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_BITS, 4) &&
           VerifyOffsetRequired(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyField<int8_t>(verifier, VT_OUT_DTYPE, 1) &&
           verifier.EndTable();
  }
};

struct QuantizedGatherNodeBuilder {
  typedef QuantizedGatherNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_table_q(const mlx_delegate::Tid *table_q) {
    fbb_.AddStruct(QuantizedGatherNode::VT_TABLE_Q, table_q);
  }
  void add_scales(const mlx_delegate::Tid *scales) {
    fbb_.AddStruct(QuantizedGatherNode::VT_SCALES, scales);
  }
  void add_ids(const mlx_delegate::Tid *ids) {
    fbb_.AddStruct(QuantizedGatherNode::VT_IDS, ids);
  }
  void add_out(const mlx_delegate::Tid *out) {
    fbb_.AddStruct(QuantizedGatherNode::VT_OUT, out);
  }
  void add_biases(const mlx_delegate::Tid *biases) {
    fbb_.AddStruct(QuantizedGatherNode::VT_BIASES, biases);
  }
  void add_group_size(int32_t group_size) {
    fbb_.AddElement<int32_t>(QuantizedGatherNode::VT_GROUP_SIZE, group_size, 0);
  }
  void add_bits(int32_t bits) {
    fbb_.AddElement<int32_t>(QuantizedGatherNode::VT_BITS, bits, 0);
  }
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(QuantizedGatherNode::VT_MODE, mode);
  }
  void add_out_dtype(mlx_delegate::DTypeId out_dtype) {
    fbb_.AddElement<int8_t>(QuantizedGatherNode::VT_OUT_DTYPE, static_cast<int8_t>(out_dtype), 0);
  }
  explicit QuantizedGatherNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedGatherNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedGatherNode>(end);
    fbb_.Required(o, QuantizedGatherNode::VT_TABLE_Q);
    fbb_.Required(o, QuantizedGatherNode::VT_SCALES);
    fbb_.Required(o, QuantizedGatherNode::VT_IDS);
    fbb_.Required(o, QuantizedGatherNode::VT_OUT);
    fbb_.Required(o, QuantizedGatherNode::VT_MODE);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedGatherNode> CreateQuantizedGatherNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *table_q = nullptr,
    const mlx_delegate::Tid *scales = nullptr,
    const mlx_delegate::Tid *ids = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const mlx_delegate::Tid *biases = nullptr,
    int32_t group_size = 0,
    int32_t bits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    mlx_delegate::DTypeId out_dtype = mlx_delegate::DTypeId_f16) {
  QuantizedGatherNodeBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_bits(bits);
  builder_.add_group_size(group_size);
  builder_.add_biases(biases);
  builder_.add_out(out);
  builder_.add_ids(ids);
  builder_.add_scales(scales);
  builder_.add_table_q(table_q);
  builder_.add_out_dtype(out_dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizedGatherNode> CreateQuantizedGatherNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const mlx_delegate::Tid *table_q = nullptr,
    const mlx_delegate::Tid *scales = nullptr,
    const mlx_delegate::Tid *ids = nullptr,
    const mlx_delegate::Tid *out = nullptr,
    const mlx_delegate::Tid *biases = nullptr,
    int32_t group_size = 0,
    int32_t bits = 0,
    const char *mode = nullptr,
    mlx_delegate::DTypeId out_dtype = mlx_delegate::DTypeId_f16) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  return mlx_delegate::CreateQuantizedGatherNode(
      _fbb,
      table_q,
      scales,
      ids,
      out,
      biases,
      group_size,
      bits,
      mode__,
      out_dtype);
}

struct Instruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_TYPE = 4,
    VT_OP = 6
  };
  mlx_delegate::OpNode op_type() const {
    return static_cast<mlx_delegate::OpNode>(GetField<uint8_t>(VT_OP_TYPE, 0));
  }
  const void *op() const {
    return GetPointer<const void *>(VT_OP);
  }
  template<typename T> const T *op_as() const;
  const mlx_delegate::NoopNode *op_as_NoopNode() const {
    return op_type() == mlx_delegate::OpNode_NoopNode ? static_cast<const mlx_delegate::NoopNode *>(op()) : nullptr;
  }
  const mlx_delegate::LinearNode *op_as_LinearNode() const {
    return op_type() == mlx_delegate::OpNode_LinearNode ? static_cast<const mlx_delegate::LinearNode *>(op()) : nullptr;
  }
  const mlx_delegate::ItemIntNode *op_as_ItemIntNode() const {
    return op_type() == mlx_delegate::OpNode_ItemIntNode ? static_cast<const mlx_delegate::ItemIntNode *>(op()) : nullptr;
  }
  const mlx_delegate::ExpandDimsNode *op_as_ExpandDimsNode() const {
    return op_type() == mlx_delegate::OpNode_ExpandDimsNode ? static_cast<const mlx_delegate::ExpandDimsNode *>(op()) : nullptr;
  }
  const mlx_delegate::TileNode *op_as_TileNode() const {
    return op_type() == mlx_delegate::OpNode_TileNode ? static_cast<const mlx_delegate::TileNode *>(op()) : nullptr;
  }
  const mlx_delegate::TakeAlongAxisNode *op_as_TakeAlongAxisNode() const {
    return op_type() == mlx_delegate::OpNode_TakeAlongAxisNode ? static_cast<const mlx_delegate::TakeAlongAxisNode *>(op()) : nullptr;
  }
  const mlx_delegate::RMSNormNode *op_as_RMSNormNode() const {
    return op_type() == mlx_delegate::OpNode_RMSNormNode ? static_cast<const mlx_delegate::RMSNormNode *>(op()) : nullptr;
  }
  const mlx_delegate::LayerNormNode *op_as_LayerNormNode() const {
    return op_type() == mlx_delegate::OpNode_LayerNormNode ? static_cast<const mlx_delegate::LayerNormNode *>(op()) : nullptr;
  }
  const mlx_delegate::RopeNode *op_as_RopeNode() const {
    return op_type() == mlx_delegate::OpNode_RopeNode ? static_cast<const mlx_delegate::RopeNode *>(op()) : nullptr;
  }
  const mlx_delegate::SdpaNode *op_as_SdpaNode() const {
    return op_type() == mlx_delegate::OpNode_SdpaNode ? static_cast<const mlx_delegate::SdpaNode *>(op()) : nullptr;
  }
  const mlx_delegate::AddNode *op_as_AddNode() const {
    return op_type() == mlx_delegate::OpNode_AddNode ? static_cast<const mlx_delegate::AddNode *>(op()) : nullptr;
  }
  const mlx_delegate::AddScalarNode *op_as_AddScalarNode() const {
    return op_type() == mlx_delegate::OpNode_AddScalarNode ? static_cast<const mlx_delegate::AddScalarNode *>(op()) : nullptr;
  }
  const mlx_delegate::SymSizeNode *op_as_SymSizeNode() const {
    return op_type() == mlx_delegate::OpNode_SymSizeNode ? static_cast<const mlx_delegate::SymSizeNode *>(op()) : nullptr;
  }
  const mlx_delegate::MulNode *op_as_MulNode() const {
    return op_type() == mlx_delegate::OpNode_MulNode ? static_cast<const mlx_delegate::MulNode *>(op()) : nullptr;
  }
  const mlx_delegate::Conv1DNode *op_as_Conv1DNode() const {
    return op_type() == mlx_delegate::OpNode_Conv1DNode ? static_cast<const mlx_delegate::Conv1DNode *>(op()) : nullptr;
  }
  const mlx_delegate::GeluNode *op_as_GeluNode() const {
    return op_type() == mlx_delegate::OpNode_GeluNode ? static_cast<const mlx_delegate::GeluNode *>(op()) : nullptr;
  }
  const mlx_delegate::ARangeNode *op_as_ARangeNode() const {
    return op_type() == mlx_delegate::OpNode_ARangeNode ? static_cast<const mlx_delegate::ARangeNode *>(op()) : nullptr;
  }
  const mlx_delegate::SiluNode *op_as_SiluNode() const {
    return op_type() == mlx_delegate::OpNode_SiluNode ? static_cast<const mlx_delegate::SiluNode *>(op()) : nullptr;
  }
  const mlx_delegate::ReshapeNode *op_as_ReshapeNode() const {
    return op_type() == mlx_delegate::OpNode_ReshapeNode ? static_cast<const mlx_delegate::ReshapeNode *>(op()) : nullptr;
  }
  const mlx_delegate::TransposeNode *op_as_TransposeNode() const {
    return op_type() == mlx_delegate::OpNode_TransposeNode ? static_cast<const mlx_delegate::TransposeNode *>(op()) : nullptr;
  }
  const mlx_delegate::ContiguousNode *op_as_ContiguousNode() const {
    return op_type() == mlx_delegate::OpNode_ContiguousNode ? static_cast<const mlx_delegate::ContiguousNode *>(op()) : nullptr;
  }
  const mlx_delegate::IdCopyNode *op_as_IdCopyNode() const {
    return op_type() == mlx_delegate::OpNode_IdCopyNode ? static_cast<const mlx_delegate::IdCopyNode *>(op()) : nullptr;
  }
  const mlx_delegate::GatherNode *op_as_GatherNode() const {
    return op_type() == mlx_delegate::OpNode_GatherNode ? static_cast<const mlx_delegate::GatherNode *>(op()) : nullptr;
  }
  const mlx_delegate::SliceNode *op_as_SliceNode() const {
    return op_type() == mlx_delegate::OpNode_SliceNode ? static_cast<const mlx_delegate::SliceNode *>(op()) : nullptr;
  }
  const mlx_delegate::CastNode *op_as_CastNode() const {
    return op_type() == mlx_delegate::OpNode_CastNode ? static_cast<const mlx_delegate::CastNode *>(op()) : nullptr;
  }
  const mlx_delegate::QuantizedLinearNode *op_as_QuantizedLinearNode() const {
    return op_type() == mlx_delegate::OpNode_QuantizedLinearNode ? static_cast<const mlx_delegate::QuantizedLinearNode *>(op()) : nullptr;
  }
  const mlx_delegate::ConcatNode *op_as_ConcatNode() const {
    return op_type() == mlx_delegate::OpNode_ConcatNode ? static_cast<const mlx_delegate::ConcatNode *>(op()) : nullptr;
  }
  const mlx_delegate::FullNode *op_as_FullNode() const {
    return op_type() == mlx_delegate::OpNode_FullNode ? static_cast<const mlx_delegate::FullNode *>(op()) : nullptr;
  }
  const mlx_delegate::ZerosNode *op_as_ZerosNode() const {
    return op_type() == mlx_delegate::OpNode_ZerosNode ? static_cast<const mlx_delegate::ZerosNode *>(op()) : nullptr;
  }
  const mlx_delegate::OnesNode *op_as_OnesNode() const {
    return op_type() == mlx_delegate::OpNode_OnesNode ? static_cast<const mlx_delegate::OnesNode *>(op()) : nullptr;
  }
  const mlx_delegate::ArgmaxNode *op_as_ArgmaxNode() const {
    return op_type() == mlx_delegate::OpNode_ArgmaxNode ? static_cast<const mlx_delegate::ArgmaxNode *>(op()) : nullptr;
  }
  const mlx_delegate::SliceUpdateNode *op_as_SliceUpdateNode() const {
    return op_type() == mlx_delegate::OpNode_SliceUpdateNode ? static_cast<const mlx_delegate::SliceUpdateNode *>(op()) : nullptr;
  }
  const mlx_delegate::QuantizedGatherNode *op_as_QuantizedGatherNode() const {
    return op_type() == mlx_delegate::OpNode_QuantizedGatherNode ? static_cast<const mlx_delegate::QuantizedGatherNode *>(op()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OP_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_OP) &&
           VerifyOpNode(verifier, op(), op_type()) &&
           verifier.EndTable();
  }
};

template<> inline const mlx_delegate::NoopNode *Instruction::op_as<mlx_delegate::NoopNode>() const {
  return op_as_NoopNode();
}

template<> inline const mlx_delegate::LinearNode *Instruction::op_as<mlx_delegate::LinearNode>() const {
  return op_as_LinearNode();
}

template<> inline const mlx_delegate::ItemIntNode *Instruction::op_as<mlx_delegate::ItemIntNode>() const {
  return op_as_ItemIntNode();
}

template<> inline const mlx_delegate::ExpandDimsNode *Instruction::op_as<mlx_delegate::ExpandDimsNode>() const {
  return op_as_ExpandDimsNode();
}

template<> inline const mlx_delegate::TileNode *Instruction::op_as<mlx_delegate::TileNode>() const {
  return op_as_TileNode();
}

template<> inline const mlx_delegate::TakeAlongAxisNode *Instruction::op_as<mlx_delegate::TakeAlongAxisNode>() const {
  return op_as_TakeAlongAxisNode();
}

template<> inline const mlx_delegate::RMSNormNode *Instruction::op_as<mlx_delegate::RMSNormNode>() const {
  return op_as_RMSNormNode();
}

template<> inline const mlx_delegate::LayerNormNode *Instruction::op_as<mlx_delegate::LayerNormNode>() const {
  return op_as_LayerNormNode();
}

template<> inline const mlx_delegate::RopeNode *Instruction::op_as<mlx_delegate::RopeNode>() const {
  return op_as_RopeNode();
}

template<> inline const mlx_delegate::SdpaNode *Instruction::op_as<mlx_delegate::SdpaNode>() const {
  return op_as_SdpaNode();
}

template<> inline const mlx_delegate::AddNode *Instruction::op_as<mlx_delegate::AddNode>() const {
  return op_as_AddNode();
}

template<> inline const mlx_delegate::AddScalarNode *Instruction::op_as<mlx_delegate::AddScalarNode>() const {
  return op_as_AddScalarNode();
}

template<> inline const mlx_delegate::SymSizeNode *Instruction::op_as<mlx_delegate::SymSizeNode>() const {
  return op_as_SymSizeNode();
}

template<> inline const mlx_delegate::MulNode *Instruction::op_as<mlx_delegate::MulNode>() const {
  return op_as_MulNode();
}

template<> inline const mlx_delegate::Conv1DNode *Instruction::op_as<mlx_delegate::Conv1DNode>() const {
  return op_as_Conv1DNode();
}

template<> inline const mlx_delegate::GeluNode *Instruction::op_as<mlx_delegate::GeluNode>() const {
  return op_as_GeluNode();
}

template<> inline const mlx_delegate::ARangeNode *Instruction::op_as<mlx_delegate::ARangeNode>() const {
  return op_as_ARangeNode();
}

template<> inline const mlx_delegate::SiluNode *Instruction::op_as<mlx_delegate::SiluNode>() const {
  return op_as_SiluNode();
}

template<> inline const mlx_delegate::ReshapeNode *Instruction::op_as<mlx_delegate::ReshapeNode>() const {
  return op_as_ReshapeNode();
}

template<> inline const mlx_delegate::TransposeNode *Instruction::op_as<mlx_delegate::TransposeNode>() const {
  return op_as_TransposeNode();
}

template<> inline const mlx_delegate::ContiguousNode *Instruction::op_as<mlx_delegate::ContiguousNode>() const {
  return op_as_ContiguousNode();
}

template<> inline const mlx_delegate::IdCopyNode *Instruction::op_as<mlx_delegate::IdCopyNode>() const {
  return op_as_IdCopyNode();
}

template<> inline const mlx_delegate::GatherNode *Instruction::op_as<mlx_delegate::GatherNode>() const {
  return op_as_GatherNode();
}

template<> inline const mlx_delegate::SliceNode *Instruction::op_as<mlx_delegate::SliceNode>() const {
  return op_as_SliceNode();
}

template<> inline const mlx_delegate::CastNode *Instruction::op_as<mlx_delegate::CastNode>() const {
  return op_as_CastNode();
}

template<> inline const mlx_delegate::QuantizedLinearNode *Instruction::op_as<mlx_delegate::QuantizedLinearNode>() const {
  return op_as_QuantizedLinearNode();
}

template<> inline const mlx_delegate::ConcatNode *Instruction::op_as<mlx_delegate::ConcatNode>() const {
  return op_as_ConcatNode();
}

template<> inline const mlx_delegate::FullNode *Instruction::op_as<mlx_delegate::FullNode>() const {
  return op_as_FullNode();
}

template<> inline const mlx_delegate::ZerosNode *Instruction::op_as<mlx_delegate::ZerosNode>() const {
  return op_as_ZerosNode();
}

template<> inline const mlx_delegate::OnesNode *Instruction::op_as<mlx_delegate::OnesNode>() const {
  return op_as_OnesNode();
}

template<> inline const mlx_delegate::ArgmaxNode *Instruction::op_as<mlx_delegate::ArgmaxNode>() const {
  return op_as_ArgmaxNode();
}

template<> inline const mlx_delegate::SliceUpdateNode *Instruction::op_as<mlx_delegate::SliceUpdateNode>() const {
  return op_as_SliceUpdateNode();
}

template<> inline const mlx_delegate::QuantizedGatherNode *Instruction::op_as<mlx_delegate::QuantizedGatherNode>() const {
  return op_as_QuantizedGatherNode();
}

struct InstructionBuilder {
  typedef Instruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_type(mlx_delegate::OpNode op_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_OP_TYPE, static_cast<uint8_t>(op_type), 0);
  }
  void add_op(::flatbuffers::Offset<void> op) {
    fbb_.AddOffset(Instruction::VT_OP, op);
  }
  explicit InstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Instruction>(end);
    fbb_.Required(o, Instruction::VT_OP);
    return o;
  }
};

inline ::flatbuffers::Offset<Instruction> CreateInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    mlx_delegate::OpNode op_type = mlx_delegate::OpNode_NONE,
    ::flatbuffers::Offset<void> op = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_op(op);
  builder_.add_op_type(op_type);
  return builder_.Finish();
}

struct TensorMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorMetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_DTYPE = 6,
    VT_STRIDES = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>> *>(VT_SHAPE);
  }
  mlx_delegate::DTypeId dtype() const {
    return static_cast<mlx_delegate::DTypeId>(GetField<int8_t>(VT_DTYPE, 0));
  }
  const ::flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.VerifyVectorOfTables(shape()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct TensorMetaBuilder {
  typedef TensorMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>>> shape) {
    fbb_.AddOffset(TensorMeta::VT_SHAPE, shape);
  }
  void add_dtype(mlx_delegate::DTypeId dtype) {
    fbb_.AddElement<int8_t>(TensorMeta::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(TensorMeta::VT_STRIDES, strides);
  }
  explicit TensorMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorMeta>(end);
    fbb_.Required(o, TensorMeta::VT_SHAPE);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorMeta> CreateTensorMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>>> shape = 0,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides = 0) {
  TensorMetaBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_shape(shape);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorMeta> CreateTensorMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<mlx_delegate::IntOrVid>> *shape = nullptr,
    mlx_delegate::DTypeId dtype = mlx_delegate::DTypeId_f16,
    const std::vector<int32_t> *strides = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::IntOrVid>>(*shape) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return mlx_delegate::CreateTensorMeta(
      _fbb,
      shape__,
      dtype,
      strides__);
}

struct SlotVariant FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SlotVariantBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX = 4,
    VT_SLOT_TYPE = 6
  };
  uint32_t idx() const {
    return GetField<uint32_t>(VT_IDX, 0);
  }
  mlx_delegate::SlotType slot_type() const {
    return static_cast<mlx_delegate::SlotType>(GetField<int8_t>(VT_SLOT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_IDX, 4) &&
           VerifyField<int8_t>(verifier, VT_SLOT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct SlotVariantBuilder {
  typedef SlotVariant Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idx(uint32_t idx) {
    fbb_.AddElement<uint32_t>(SlotVariant::VT_IDX, idx, 0);
  }
  void add_slot_type(mlx_delegate::SlotType slot_type) {
    fbb_.AddElement<int8_t>(SlotVariant::VT_SLOT_TYPE, static_cast<int8_t>(slot_type), 0);
  }
  explicit SlotVariantBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SlotVariant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SlotVariant>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SlotVariant> CreateSlotVariant(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t idx = 0,
    mlx_delegate::SlotType slot_type = mlx_delegate::SlotType_TensorSlot) {
  SlotVariantBuilder builder_(_fbb);
  builder_.add_idx(idx);
  builder_.add_slot_type(slot_type);
  return builder_.Finish();
}

struct NamedSlot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedSlotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const mlx_delegate::SlotVariant *slot() const {
    return GetPointer<const mlx_delegate::SlotVariant *>(VT_SLOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_SLOT) &&
           verifier.VerifyTable(slot()) &&
           verifier.EndTable();
  }
};

struct NamedSlotBuilder {
  typedef NamedSlot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NamedSlot::VT_NAME, name);
  }
  void add_slot(::flatbuffers::Offset<mlx_delegate::SlotVariant> slot) {
    fbb_.AddOffset(NamedSlot::VT_SLOT, slot);
  }
  explicit NamedSlotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedSlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedSlot>(end);
    fbb_.Required(o, NamedSlot::VT_NAME);
    fbb_.Required(o, NamedSlot::VT_SLOT);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedSlot> CreateNamedSlot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<mlx_delegate::SlotVariant> slot = 0) {
  NamedSlotBuilder builder_(_fbb);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NamedSlot> CreateNamedSlotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<mlx_delegate::SlotVariant> slot = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mlx_delegate::CreateNamedSlot(
      _fbb,
      name__,
      slot);
}

struct DataSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_SIZE = 6
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
};

struct DataSegmentBuilder {
  typedef DataSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(DataSegment::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(DataSegment::VT_SIZE, size, 0);
  }
  explicit DataSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataSegment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataSegment> CreateDataSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0,
    uint64_t size = 0) {
  DataSegmentBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct MLXGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MLXGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NUM_CONSTANT_TENSORS = 6,
    VT_NUM_NON_CONSTANT_TENSORS = 8,
    VT_NUM_NON_CONSTANT_VALUES = 10,
    VT_INSTRUCTIONS = 12,
    VT_INPUT_MAP = 14,
    VT_OUTPUT_MAP = 16,
    VT_MUTABLE_BUFFER_MAP = 18,
    VT_NAMED_SLOTS = 20,
    VT_TENSOR_META = 22,
    VT_CONSTANT_SEGMENT = 24
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  uint32_t num_constant_tensors() const {
    return GetField<uint32_t>(VT_NUM_CONSTANT_TENSORS, 0);
  }
  uint32_t num_non_constant_tensors() const {
    return GetField<uint32_t>(VT_NUM_NON_CONSTANT_TENSORS, 0);
  }
  uint32_t num_non_constant_values() const {
    return GetField<uint32_t>(VT_NUM_NON_CONSTANT_VALUES, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::Instruction>> *instructions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::Instruction>> *>(VT_INSTRUCTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *input_map() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *>(VT_INPUT_MAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *output_map() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *>(VT_OUTPUT_MAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *mutable_buffer_map() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *>(VT_MUTABLE_BUFFER_MAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::NamedSlot>> *named_slots() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::NamedSlot>> *>(VT_NAMED_SLOTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::TensorMeta>> *tensor_meta() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::TensorMeta>> *>(VT_TENSOR_META);
  }
  const mlx_delegate::DataSegment *constant_segment() const {
    return GetPointer<const mlx_delegate::DataSegment *>(VT_CONSTANT_SEGMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_CONSTANT_TENSORS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUM_NON_CONSTANT_TENSORS, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUM_NON_CONSTANT_VALUES, 4) &&
           VerifyOffsetRequired(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(instructions()) &&
           verifier.VerifyVectorOfTables(instructions()) &&
           VerifyOffset(verifier, VT_INPUT_MAP) &&
           verifier.VerifyVector(input_map()) &&
           verifier.VerifyVectorOfTables(input_map()) &&
           VerifyOffset(verifier, VT_OUTPUT_MAP) &&
           verifier.VerifyVector(output_map()) &&
           verifier.VerifyVectorOfTables(output_map()) &&
           VerifyOffset(verifier, VT_MUTABLE_BUFFER_MAP) &&
           verifier.VerifyVector(mutable_buffer_map()) &&
           verifier.VerifyVectorOfTables(mutable_buffer_map()) &&
           VerifyOffset(verifier, VT_NAMED_SLOTS) &&
           verifier.VerifyVector(named_slots()) &&
           verifier.VerifyVectorOfTables(named_slots()) &&
           VerifyOffset(verifier, VT_TENSOR_META) &&
           verifier.VerifyVector(tensor_meta()) &&
           verifier.VerifyVectorOfTables(tensor_meta()) &&
           VerifyOffset(verifier, VT_CONSTANT_SEGMENT) &&
           verifier.VerifyTable(constant_segment()) &&
           verifier.EndTable();
  }
};

struct MLXGraphBuilder {
  typedef MLXGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(MLXGraph::VT_VERSION, version);
  }
  void add_num_constant_tensors(uint32_t num_constant_tensors) {
    fbb_.AddElement<uint32_t>(MLXGraph::VT_NUM_CONSTANT_TENSORS, num_constant_tensors, 0);
  }
  void add_num_non_constant_tensors(uint32_t num_non_constant_tensors) {
    fbb_.AddElement<uint32_t>(MLXGraph::VT_NUM_NON_CONSTANT_TENSORS, num_non_constant_tensors, 0);
  }
  void add_num_non_constant_values(uint32_t num_non_constant_values) {
    fbb_.AddElement<uint32_t>(MLXGraph::VT_NUM_NON_CONSTANT_VALUES, num_non_constant_values, 0);
  }
  void add_instructions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::Instruction>>> instructions) {
    fbb_.AddOffset(MLXGraph::VT_INSTRUCTIONS, instructions);
  }
  void add_input_map(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>> input_map) {
    fbb_.AddOffset(MLXGraph::VT_INPUT_MAP, input_map);
  }
  void add_output_map(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>> output_map) {
    fbb_.AddOffset(MLXGraph::VT_OUTPUT_MAP, output_map);
  }
  void add_mutable_buffer_map(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>> mutable_buffer_map) {
    fbb_.AddOffset(MLXGraph::VT_MUTABLE_BUFFER_MAP, mutable_buffer_map);
  }
  void add_named_slots(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::NamedSlot>>> named_slots) {
    fbb_.AddOffset(MLXGraph::VT_NAMED_SLOTS, named_slots);
  }
  void add_tensor_meta(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::TensorMeta>>> tensor_meta) {
    fbb_.AddOffset(MLXGraph::VT_TENSOR_META, tensor_meta);
  }
  void add_constant_segment(::flatbuffers::Offset<mlx_delegate::DataSegment> constant_segment) {
    fbb_.AddOffset(MLXGraph::VT_CONSTANT_SEGMENT, constant_segment);
  }
  explicit MLXGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MLXGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MLXGraph>(end);
    fbb_.Required(o, MLXGraph::VT_INSTRUCTIONS);
    return o;
  }
};

inline ::flatbuffers::Offset<MLXGraph> CreateMLXGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    uint32_t num_constant_tensors = 0,
    uint32_t num_non_constant_tensors = 0,
    uint32_t num_non_constant_values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::Instruction>>> instructions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>> input_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>> output_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>> mutable_buffer_map = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::NamedSlot>>> named_slots = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<mlx_delegate::TensorMeta>>> tensor_meta = 0,
    ::flatbuffers::Offset<mlx_delegate::DataSegment> constant_segment = 0) {
  MLXGraphBuilder builder_(_fbb);
  builder_.add_constant_segment(constant_segment);
  builder_.add_tensor_meta(tensor_meta);
  builder_.add_named_slots(named_slots);
  builder_.add_mutable_buffer_map(mutable_buffer_map);
  builder_.add_output_map(output_map);
  builder_.add_input_map(input_map);
  builder_.add_instructions(instructions);
  builder_.add_num_non_constant_values(num_non_constant_values);
  builder_.add_num_non_constant_tensors(num_non_constant_tensors);
  builder_.add_num_constant_tensors(num_constant_tensors);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MLXGraph> CreateMLXGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    uint32_t num_constant_tensors = 0,
    uint32_t num_non_constant_tensors = 0,
    uint32_t num_non_constant_values = 0,
    const std::vector<::flatbuffers::Offset<mlx_delegate::Instruction>> *instructions = nullptr,
    const std::vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *input_map = nullptr,
    const std::vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *output_map = nullptr,
    const std::vector<::flatbuffers::Offset<mlx_delegate::SlotVariant>> *mutable_buffer_map = nullptr,
    const std::vector<::flatbuffers::Offset<mlx_delegate::NamedSlot>> *named_slots = nullptr,
    const std::vector<::flatbuffers::Offset<mlx_delegate::TensorMeta>> *tensor_meta = nullptr,
    ::flatbuffers::Offset<mlx_delegate::DataSegment> constant_segment = 0) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto instructions__ = instructions ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::Instruction>>(*instructions) : 0;
  auto input_map__ = input_map ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>(*input_map) : 0;
  auto output_map__ = output_map ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>(*output_map) : 0;
  auto mutable_buffer_map__ = mutable_buffer_map ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::SlotVariant>>(*mutable_buffer_map) : 0;
  auto named_slots__ = named_slots ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::NamedSlot>>(*named_slots) : 0;
  auto tensor_meta__ = tensor_meta ? _fbb.CreateVector<::flatbuffers::Offset<mlx_delegate::TensorMeta>>(*tensor_meta) : 0;
  return mlx_delegate::CreateMLXGraph(
      _fbb,
      version__,
      num_constant_tensors,
      num_non_constant_tensors,
      num_non_constant_values,
      instructions__,
      input_map__,
      output_map__,
      mutable_buffer_map__,
      named_slots__,
      tensor_meta__,
      constant_segment);
}

inline bool VerifyOpNode(::flatbuffers::Verifier &verifier, const void *obj, OpNode type) {
  switch (type) {
    case OpNode_NONE: {
      return true;
    }
    case OpNode_NoopNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::NoopNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_LinearNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::LinearNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ItemIntNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ItemIntNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ExpandDimsNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ExpandDimsNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_TileNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::TileNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_TakeAlongAxisNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::TakeAlongAxisNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_RMSNormNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::RMSNormNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_LayerNormNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::LayerNormNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_RopeNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::RopeNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_SdpaNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::SdpaNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_AddNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::AddNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_AddScalarNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::AddScalarNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_SymSizeNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::SymSizeNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_MulNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::MulNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_Conv1DNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::Conv1DNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_GeluNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::GeluNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ARangeNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ARangeNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_SiluNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::SiluNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ReshapeNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ReshapeNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_TransposeNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::TransposeNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ContiguousNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ContiguousNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_IdCopyNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::IdCopyNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_GatherNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::GatherNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_SliceNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::SliceNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_CastNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::CastNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_QuantizedLinearNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::QuantizedLinearNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ConcatNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ConcatNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_FullNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::FullNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ZerosNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ZerosNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_OnesNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::OnesNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_ArgmaxNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::ArgmaxNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_SliceUpdateNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::SliceUpdateNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpNode_QuantizedGatherNode: {
      auto ptr = reinterpret_cast<const mlx_delegate::QuantizedGatherNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpNodeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpNode(
        verifier,  values->Get(i), types->GetEnum<OpNode>(i))) {
      return false;
    }
  }
  return true;
}

inline const mlx_delegate::MLXGraph *GetMLXGraph(const void *buf) {
  return ::flatbuffers::GetRoot<mlx_delegate::MLXGraph>(buf);
}

inline const mlx_delegate::MLXGraph *GetSizePrefixedMLXGraph(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<mlx_delegate::MLXGraph>(buf);
}

inline bool VerifyMLXGraphBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mlx_delegate::MLXGraph>(nullptr);
}

inline bool VerifySizePrefixedMLXGraphBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mlx_delegate::MLXGraph>(nullptr);
}

inline void FinishMLXGraphBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<mlx_delegate::MLXGraph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMLXGraphBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<mlx_delegate::MLXGraph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace mlx_delegate

#endif  // FLATBUFFERS_GENERATED_SCHEMA_MLX_DELEGATE_H_
