# automatically generated by the FlatBuffers compiler, do not modify

# namespace: mlx_delegate

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class MLXGraph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MLXGraph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMLXGraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # MLXGraph
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MLXGraph
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # MLXGraph
    def NumConstantTensors(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MLXGraph
    def NumNonConstantTensors(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MLXGraph
    def NumNonConstantValues(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # MLXGraph
    def Instructions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from mlx_delegate.Instruction import Instruction
            obj = Instruction()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MLXGraph
    def InstructionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MLXGraph
    def InstructionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # MLXGraph
    def InputMap(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from mlx_delegate.SlotVariant import SlotVariant
            obj = SlotVariant()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MLXGraph
    def InputMapLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MLXGraph
    def InputMapIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # MLXGraph
    def OutputMap(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from mlx_delegate.SlotVariant import SlotVariant
            obj = SlotVariant()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MLXGraph
    def OutputMapLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MLXGraph
    def OutputMapIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # MLXGraph
    def MutableBufferMap(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from mlx_delegate.SlotVariant import SlotVariant
            obj = SlotVariant()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MLXGraph
    def MutableBufferMapLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MLXGraph
    def MutableBufferMapIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # MLXGraph
    def NamedSlots(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from mlx_delegate.NamedSlot import NamedSlot
            obj = NamedSlot()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MLXGraph
    def NamedSlotsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MLXGraph
    def NamedSlotsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # MLXGraph
    def TensorMeta(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from mlx_delegate.TensorMeta import TensorMeta
            obj = TensorMeta()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # MLXGraph
    def TensorMetaLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MLXGraph
    def TensorMetaIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # MLXGraph
    def ConstantSegment(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from mlx_delegate.DataSegment import DataSegment
            obj = DataSegment()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def MLXGraphStart(builder):
    builder.StartObject(11)

def Start(builder):
    MLXGraphStart(builder)

def MLXGraphAddVersion(builder, version):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(version), 0)

def AddVersion(builder, version):
    MLXGraphAddVersion(builder, version)

def MLXGraphAddNumConstantTensors(builder, numConstantTensors):
    builder.PrependUint32Slot(1, numConstantTensors, 0)

def AddNumConstantTensors(builder, numConstantTensors):
    MLXGraphAddNumConstantTensors(builder, numConstantTensors)

def MLXGraphAddNumNonConstantTensors(builder, numNonConstantTensors):
    builder.PrependUint32Slot(2, numNonConstantTensors, 0)

def AddNumNonConstantTensors(builder, numNonConstantTensors):
    MLXGraphAddNumNonConstantTensors(builder, numNonConstantTensors)

def MLXGraphAddNumNonConstantValues(builder, numNonConstantValues):
    builder.PrependUint32Slot(3, numNonConstantValues, 0)

def AddNumNonConstantValues(builder, numNonConstantValues):
    MLXGraphAddNumNonConstantValues(builder, numNonConstantValues)

def MLXGraphAddInstructions(builder, instructions):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(instructions), 0)

def AddInstructions(builder, instructions):
    MLXGraphAddInstructions(builder, instructions)

def MLXGraphStartInstructionsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartInstructionsVector(builder, numElems):
    return MLXGraphStartInstructionsVector(builder, numElems)

def MLXGraphAddInputMap(builder, inputMap):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(inputMap), 0)

def AddInputMap(builder, inputMap):
    MLXGraphAddInputMap(builder, inputMap)

def MLXGraphStartInputMapVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartInputMapVector(builder, numElems):
    return MLXGraphStartInputMapVector(builder, numElems)

def MLXGraphAddOutputMap(builder, outputMap):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(outputMap), 0)

def AddOutputMap(builder, outputMap):
    MLXGraphAddOutputMap(builder, outputMap)

def MLXGraphStartOutputMapVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartOutputMapVector(builder, numElems):
    return MLXGraphStartOutputMapVector(builder, numElems)

def MLXGraphAddMutableBufferMap(builder, mutableBufferMap):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(mutableBufferMap), 0)

def AddMutableBufferMap(builder, mutableBufferMap):
    MLXGraphAddMutableBufferMap(builder, mutableBufferMap)

def MLXGraphStartMutableBufferMapVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartMutableBufferMapVector(builder, numElems):
    return MLXGraphStartMutableBufferMapVector(builder, numElems)

def MLXGraphAddNamedSlots(builder, namedSlots):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(namedSlots), 0)

def AddNamedSlots(builder, namedSlots):
    MLXGraphAddNamedSlots(builder, namedSlots)

def MLXGraphStartNamedSlotsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartNamedSlotsVector(builder, numElems):
    return MLXGraphStartNamedSlotsVector(builder, numElems)

def MLXGraphAddTensorMeta(builder, tensorMeta):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(tensorMeta), 0)

def AddTensorMeta(builder, tensorMeta):
    MLXGraphAddTensorMeta(builder, tensorMeta)

def MLXGraphStartTensorMetaVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartTensorMetaVector(builder, numElems):
    return MLXGraphStartTensorMetaVector(builder, numElems)

def MLXGraphAddConstantSegment(builder, constantSegment):
    builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(constantSegment), 0)

def AddConstantSegment(builder, constantSegment):
    MLXGraphAddConstantSegment(builder, constantSegment)

def MLXGraphEnd(builder):
    return builder.EndObject()

def End(builder):
    return MLXGraphEnd(builder)
