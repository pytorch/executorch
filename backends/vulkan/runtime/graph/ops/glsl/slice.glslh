/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#ifndef SLICE_GLSLH
#define SLICE_GLSLH

#include "indexing.glslh"

#ifdef USING_BUFFER

/*
 * Converts output tensor indices to input tensor indices for the slice operation
 * on buffer storage.
 *
 * Parameters assumed to be defined:
 * - inp: BufferMetadata
 * - selected_dim
 * - start
 * - step
 */
TensorIndex out_tidx_to_in_tidx(const TensorIndex out_tidx) {
  TensorIndex in_tidx = out_tidx;

  int in_size = int(size_at(inp, selected_dim));
  int adjusted_start = start;
  if (start < 0) {
    adjusted_start = start + in_size;
  }

  uint out_idx = idx_at(out_tidx, selected_dim);
  in_tidx.data[div_4(selected_dim)][mod_4(selected_dim)] =
      adjusted_start + int(out_idx) * step;

  return in_tidx;
}

#else // texture storage

/*
 * Converts output tensor indices to input tensor indices for the slice operation
 * on texture storage.
 *
 * Parameters assumed to be defined:
 * - inp: TextureMetadata
 * - selected_dim
 * - start
 * - step
 */
TensorIndex4D out_tidx_to_in_tidx(const TensorIndex4D out_tidx) {
  TensorIndex4D in_tidx = out_tidx;

  int adjusted_start = start;
  if (start < 0) {
    adjusted_start = start + inp.sizes[selected_dim];
  }

  in_tidx.data[selected_dim] = adjusted_start + out_tidx.data[selected_dim] * step;

  return in_tidx;
}

#endif // USING_BUFFER

#endif // SLICE_GLSLH
