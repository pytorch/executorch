/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to load a Int8InputTile from input buffer/texture.
 *
 * Requires:
 * - t_packed_int8_input to be declared in the shader layout
 *
 * Settings:
 * - PACKED_INT8_INPUT_BUFFER to indicate resource is a buffer, otherwise
 *   texture storage is assumed.
 */

#ifndef LINEAR_INT8_INPUT_TILE_LOAD_GLSLH
#define LINEAR_INT8_INPUT_TILE_LOAD_GLSLH

#extension GL_EXT_control_flow_attributes : require

#include "linear_int8_input_tile.glslh"

#ifdef PACKED_INT8_INPUT_BUFFER

ivec4 load_int8_input_block(
    const int block_x,
    const int block_y,
    const int nblocks_x) {
  return t_packed_int8_input[(block_y * nblocks_x) + block_x];
}

#else

ivec4 load_int8_input_block(
    const int block_x,
    const int block_y,
    const int nblocks_x) {
  return texelFetch(t_packed_int8_input, ivec3(block_x, block_y, 0), 0);
}

#endif // PACKED_INT8_INPUT_BUFFER

void load_int8_input_tile(
    out Int8InputTile in_tile,
    const int block_x,
    const int block_y,
    const int nblocks_x) {
#if TILE_M4 == 1 && TILE_K4 == 1
  in_tile.data[0][0] = load_int8_input_block(block_x, block_y, nblocks_x);

#elif TILE_M4 == 1 && TILE_K4 > 1
  [[unroll]] for (int x = 0; x < TILE_K4; ++x) {
    in_tile.data[0][x] = load_int8_input_block(block_x + x, block_y, nblocks_x);
  }

#elif TILE_M4 > 1 && TILE_K4 == 1
  [[unroll]] for (int y = 0; y < TILE_M4; ++y) {
    in_tile.data[y][0] = load_int8_input_block(block_x, block_y + y, nblocks_x);
  }

#else
  [[unroll]] for (int y = 0; y < TILE_M4; ++y) {
    [[unroll]] for (int x = 0; x < TILE_K4; ++x) {
      in_tile.data[y][x] =
          load_int8_input_block(block_x + x, block_y + y, nblocks_x);
    }
  }
#endif
}

#endif // LINEAR_INT8_INPUT_TILE_LOAD_GLSLH
