/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#ifndef LINEAR_INT4_WEIGHT_BLOCK_GLSLH
#define LINEAR_INT4_WEIGHT_BLOCK_GLSLH

/*
 * Assumes the following variables are defined in shader layout
 * - t_packed_int4_weight
 * - t_int4_weight
 *
 * Macro Settings:
 * - USING_BUFFER
 */

#extension GL_EXT_control_flow_attributes : require

#include "linear_common.glslh"

// Represents source data for 2 8Kx4N block of the weight matrix read from the
// input buffer. Each int element contains 8 packed 4-bit values along the K
// dimension. Overall the data represents 8Kx8N block.
struct Int4Weight2xBlockSourceData {
  uint data[8];
};

// Represents data for a packed 4Kx8N block of the weight matrix to be written
// out to output texture/buffer. An individual block was originally a 4Kx8N
// block in the original weight tensor, and then the top and bottom halves are
// concatenated along the width dim.
struct Int4WeightBlockPacked {
  ivec4 data;
};

void load_block_source_data_no_checks(
    out Int4Weight2xBlockSourceData src_data,
    const int k8,
    const int n_start,
    const int ntexels_K,
    const int N) {
  [[unroll]] for (int n = 0; n < 8; ++n) {
    src_data.data[n] = t_int4_weight[(n_start + n) * ntexels_K + k8];
  }
}

// To be used if K - k_start < 4
void load_block_source_data_with_checks(
    out Int4Weight2xBlockSourceData src_data,
    const int k8,
    const int n_start,
    const int ntexels_K,
    const int N) {
  [[unroll]] for (int n = 0; n < 8; ++n) {
    if (n_start + n < N) {
      src_data.data[n] = t_int4_weight[(n_start + n) * ntexels_K + k8];
    } else {
      // Equivalent to a row of zeros since int4 weights have an implicit zero
      // point of -8.
      src_data.data[n] = 0x88888888;
    }
  }
}

int pack_8x4bit_signed_into_int(
    const int val0,
    const int val1,
    const int val2,
    const int val3,
    const int val4,
    const int val5,
    const int val6,
    const int val7) {
  return int(
      ((val7 & 0xF) << 28) | ((val6 & 0xF) << 24) | ((val5 & 0xF) << 20) |
      ((val4 & 0xF) << 16) | ((val3 & 0xF) << 12) | ((val2 & 0xF) << 8) |
      ((val1 & 0xF) << 4) | ((val0 & 0xF)));
}

void create_packed_blocks(
    out Int4WeightBlockPacked block1,
    out Int4WeightBlockPacked block2,
    const Int4Weight2xBlockSourceData src_data) {
  [[unroll]] for (int row = 0; row < 4; ++row) {
    const int row_idx_1 = row;
    const int row_idx_2 = row + 4;
    block1.data[row] = pack_8x4bit_signed_into_int(
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 0),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 0),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 1),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 1),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 2),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 2),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 3),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 3));

    block2.data[row] = pack_8x4bit_signed_into_int(
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 4),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 4),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 5),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 5),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 6),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 6),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_1], 7),
        extract_4bit_from_packed_uint_le(src_data.data[row_idx_2], 7));
  }
}

void write_packed_block(
    const Int4WeightBlockPacked block,
    const int k4,
    const int n8,
    const int nblocks_K) {
#ifdef USING_BUFFER
  t_packed_int4_weight[n8 * nblocks_K + k4] = block.data;
#else
  imageStore(t_packed_int4_weight, ivec2(k4, n8), block.data);
#endif // USING_BUFFER
}

#ifdef DEBUG_MODE

void printInt4Weight2xBlockSourceData(
    const Int4Weight2xBlockSourceData src_data) {
  debugPrintfEXT("int4_weight_block_source_data: \\n");
  [[unroll]] for (int row = 0; row < 8; ++row) {
    debugPrintfEXT("row %i (raw: %u): ", row, src_data.data[row]);
    // Extract and print individual 4-bit values directly from packed int
    [[unroll]] for (int col = 0; col < 8; ++col) {
      int val_4bit = extract_4bit_from_packed_uint_le(src_data.data[row], col);
      debugPrintfEXT("[%i] ", val_4bit);
    }
    debugPrintfEXT("\\n");
  }
}

void printInt4WeightBlockPacked(const Int4WeightBlockPacked block) {
  debugPrintfEXT("int4_weight_block_packed: \\n");
  // Print unpacked 4-bit values for each int in block.data
  [[unroll]] for (int i = 0; i < 4; ++i) {
    debugPrintfEXT("block.data[%i] 4-bit values: ", i);
    [[unroll]] for (int col = 0; col < 8; ++col) {
      int val_4bit = extract_4bit_from_packed_int_le(block.data[i], col);
      debugPrintfEXT("[%i] ", val_4bit);
    }
    debugPrintfEXT("\\n");
  }
}

#endif // DEBUG_MODE

#endif // LINEAR_INT4_WEIGHT_BLOCK_GLSLH
