/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#ifndef CONV2D_FP_IM2COL_BLOCK
#define CONV2D_FP_IM2COL_BLOCK

/*
 * Defines utilities to convert between (col, row) indices of an im2col matrix
 * and 4-dimension tensor indices of image tensors.
 *
 * Requires:
 * - output_sizes to be defined in the shader layout, corresponding to the sizes
 *   of the output image of the convolution op.
 * - image_sizes to be defined in the shader layout, corresponding to the sizes
 *   of the input image of the convolution op.
 * - conv2d_params to be defined in the shader layout
 */

#extension GL_EXT_control_flow_attributes : require

#include "common.glslh"
#include "conv2d_common.glslh"

struct Im2ColMatrixIdx {
  int row;
  int col;
  // Relevant for grouped convolution. This indicates the column index relative
  // to the first column in the group.
  int col_idx_in_group;
  int group_idx;
};

void unwrap_m(out TensorIndex4D out_tidx_base, const int m) {
  out_tidx_base.data[3] = m / (output_sizes.y * output_sizes.x);
  out_tidx_base.data[1] = (m / output_sizes.x) % output_sizes.y;
  out_tidx_base.data[0] = m % output_sizes.x;

  // Initialize channels to 0; assume it will be set later on
  out_tidx_base.data[2] = 0;
}

void im2col_tidx_to_output_tidx(
    out TensorIndex4D output_tidx,
    const Im2ColMatrixIdx im2col_tidx) {
  unwrap_m(output_tidx, im2col_tidx.row);
  // Set channels
  output_tidx.data.z = im2col_tidx.col;
}

/*
 * Converts im2col matrix position to corresponding 4D tensor index, accounting
 * for grouped convolutions. The conversion should ensure that all data within
 * the same group occupy a contiguous block in memory.
 */
void im2col_idx_to_input_tidx(
    out TensorIndex4D input_tidx,
    const Im2ColMatrixIdx im2col_idx) {
  TensorIndex4D output_tidx;
  unwrap_m(output_tidx, im2col_idx.row);

  const int in_channels_per_group = conv2d_params.in_channels_per_group;
  // Determine the corresponding position within the convolution window based
  // on the col index (more specifically, the col index within the group)
  const int channel_within_group =
      im2col_idx.col_idx_in_group % in_channels_per_group;
  const int kernel_x = (im2col_idx.col_idx_in_group / in_channels_per_group) %
      conv2d_params.kernel_size.x;
  const int kernel_y = im2col_idx.col_idx_in_group /
      (in_channels_per_group * conv2d_params.kernel_size.x);

  // Calculate the actual input channel index
  const int channel_idx =
      im2col_idx.group_idx * conv2d_params.in_channels_per_group +
      channel_within_group;

  // Calculate corresponding input coordinates based on output position
  // associated with the row index.
  const int input_y = int(output_tidx.data.y * conv2d_params.stride.y) -
      int(conv2d_params.padding.y) + int(kernel_y * conv2d_params.dilation.y);
  const int input_x = int(output_tidx.data.x * conv2d_params.stride.x) -
      int(conv2d_params.padding.x) + int(kernel_x * conv2d_params.dilation.x);

  input_tidx.data = ivec4(input_x, input_y, channel_idx, output_tidx.data.w);
}

// 4x4 block of the im2col matrix
struct FPIm2ColBlock {
  VEC4_T data[4];
};

#endif // CONV2D_FP_IM2COL_BLOCK
