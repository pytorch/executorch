/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * This file defines utilties to perform int8 quantization and block packing of
 * matrix multiplation inputs. It also defines utilities to store packed block
 * data to an output buffer or texture.
 *
 * Requires:
 * - t_output to be defined in shader layout (output buffer/texture)
 *
 * Settings:
 * - OUTPUT_BUFFER to indicate if output resource is a buffer. Otherwise texture
 *   is assumed.
 */

#ifndef LINEAR_INT8_INPUT_BLOCK_GLSLH
#define LINEAR_INT8_INPUT_BLOCK_GLSLH

#define TILE_M 4
#define TILE_K4 1

#include "linear_fp_input_tile.glslh"

struct Int8InputBlock {
  ivec4 data;
};

ivec4 quantize(const VEC4_T val) {
  vec4 quantized = round(vec4(val) * inv_scale) + zp;

  // hard-code 8 bit quantization range
  return clamp(ivec4(quantized), -127, 127);
}

int pack_into_int32(const ivec4 quant_vals) {
  int packed = ((quant_vals[0] & 0xFF) << 0) | ((quant_vals[1] & 0xFF) << 8) |
      ((quant_vals[2] & 0xFF) << 16) | ((quant_vals[3] & 0xFF) << 24);

  return packed;
}

void quantize_and_pack(out Int8InputBlock packed, const FPInputTile in_block) {
  for (int row = 0; row < 4; ++row) {
    ivec4 quantized_inputs = quantize(in_block.data[row][0]);
    packed.data[row] = pack_into_int32(quantized_inputs);
  }
}

#ifdef OUTPUT_BUFFER

void write_block(
    const Int8InputBlock block,
    const int block_x,
    const int block_y,
    const int nblocks_x) {
  t_output[block_y * nblocks_x + block_x] = block.data;
}

#else // OUTPUT_TEXTURE

void write_block(
    const Int8InputBlock block,
    const int block_x,
    const int block_y,
    const int nblocks_x) {
  imageStore(t_output, ivec3(block_x, block_y, 0), block.data);
}

#endif // OUTPUT_BUFFER

#endif // LINEAR_INT8_INPUT_BLOCK_GLSLH
