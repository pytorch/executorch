/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to compute a FPOutTile using int8 input and weight tiles.
 *
 * Settings:
 * - TILE_M: The number of rows in the output tile.
 * - TILE_N4: The number of (groups of 4) columns in the output tile.
 */

#ifndef LINEAR_FP_OUTPUT_TILE_INT8_INT8_COMPUTE_GLSLH
#define LINEAR_FP_OUTPUT_TILE_INT8_INT8_COMPUTE_GLSLH

#extension GL_EXT_control_flow_attributes : require
#extension GL_EXT_integer_dot_product : require

#include "linear_common.glslh"
#include "linear_fp_output_tile.glslh"
#include "linear_fp_per_out_channel_params.glslh"
#include "linear_int8_input_scales_zps.glslh"
#include "linear_int8_input_tile.glslh"
#include "linear_int8_weight_tile.glslh"
#include "linear_int_accumulator.glslh"
#include "linear_int_per_in_channel_params.glslh"
#include "linear_int_per_out_channel_params.glslh"

// Accumulate int8 input and weight tiles into integer accumulator tile
void int_accumulate_with_int8_weight(
    inout Int32Accum accum,
    Int8InputTile in_tile,
    Int8WeightTile w_tile) {
  // Accum tile is indexed as accum[m][n4][n4i]
  //   -> gives integer accumulator for output tile element at (x = n, y = m)
  // Input tile is indexed as in_tile.data[m4][k4][m4i]
  //   -> gives packed integer containing the 4x 8-bit quantized values at index
  //      (k, m), (k + 1, m), (k + 2, m), (k + 3, m)
  // Weight tile is indexed as w_tile.data[k4][n4][n4i]
  //   -> gives packed integer containing the 4x 8-bit quantized values at index
  //      (n, k), (n, k + 1), (n, k + 2), (n, k + 3)
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    const int m4 = div_4(m);
    const int m4i = mod_4(m);
    [[unroll]] for (int n = 0; n < TILE_N; ++n) {
      const int n4 = div_4(n);
      const int n4i = mod_4(n);
      [[unroll]] for (int k4 = 0; k4 < TILE_K4; ++k4) {
        accum.data[m][n4][n4i] = dotPacked4x8AccSatEXT(
            in_tile.data[m4][k4][m4i],
            w_tile.data[k4][n4][n4i],
            accum.data[m][n4][n4i]);
      }
    }
  }
}

void accumulate_out_tile_with_int_accum(
    inout FPOutTile out_tile,
    const Int32Accum accum,
    const float input_q_scale,
    const int input_q_zp,
    const IntPerOutChannelParams weight_sums,
    const FPPerOutChannelParams weight_scales) {
  ivec4 input_zp_vec = ivec4(-input_q_zp);
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      // Unfortunately fma doesn't work with ivec4. Prefer to preserve integer
      // format for as long as possible to avoid precision loss.
      ivec4 accum_adjusted =
          input_zp_vec * weight_sums.data[n4] + accum.data[m][n4];
      out_tile.data[m][n4] =
          fma(VEC4_T(accum_adjusted),
              VEC4_T(input_q_scale * weight_scales.data[n4]),
              out_tile.data[m][n4]);
    }
  }
}

// overload of the above but with bias
void accumulate_out_tile_with_int_accum(
    inout FPOutTile out_tile,
    const Int32Accum accum,
    const float input_q_scale,
    const int input_q_zp,
    const IntPerOutChannelParams weight_sums,
    const FPPerOutChannelParams weight_scales,
    const FPPerOutChannelParams bias) {
  ivec4 input_zp_vec = ivec4(-input_q_zp);
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      // Apply scale and zero points to the int accumulator
      ivec4 accum_adjusted =
          input_zp_vec * weight_sums.data[n4] + accum.data[m][n4];
      out_tile.data[m][n4] =
          fma(VEC4_T(accum_adjusted),
              VEC4_T(input_q_scale * weight_scales.data[n4]),
              out_tile.data[m][n4]);
      out_tile.data[m][n4] += bias.data[n4];
    }
  }
}

#endif // LINEAR_FP_OUTPUT_TILE_INT8_INT8_COMPUTE_GLSLH
