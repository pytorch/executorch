/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to compute a FPOutTile using int8 input and weight tiles.
 *
 * Settings:
 * - TILE_M: The number of rows in the output tile.
 * - TILE_N4: The number of (groups of 4) columns in the output tile.
 */

#ifndef LINEAR_FP_OUTPUT_TILE_INT8_INT8_COMPUTE_GLSLH
#define LINEAR_FP_OUTPUT_TILE_INT8_INT8_COMPUTE_GLSLH

#extension GL_EXT_control_flow_attributes : require
#extension GL_EXT_integer_dot_product : require

#include "linear_common.glslh"
#include "linear_fp_output_tile.glslh"
#include "linear_fp_per_out_channel_params.glslh"
#include "linear_int8_input_tile.glslh"
#include "linear_int8_weight_tile.glslh"
#include "linear_int_per_out_channel_params.glslh"

// Stores integer accumulators for an output tile.
struct Int32Accum {
  ivec4 data[TILE_M][TILE_N4];
};

// Initialize values to 0
void initialize(out Int32Accum out_accum) {
#if TILE_N4 == 1
  [[unroll]] for (int y = 0; y < TILE_M; ++y) {
    out_accum.data[y][0] = ivec4(0);
  }

#else
  [[unroll]] for (int y = 0; y < TILE_M; ++y) {
    [[unroll]] for (int x4 = 0; x4 < TILE_K4; ++x4) {
      out_accum.data[y][x4] = ivec4(0);
    }
  }
#endif
}

// Accumulate int8 input and weight tiles into integer accumulator tile
void int_accumulate_with_int8_weight(
    inout Int32Accum accum,
    Int8InputTile in_tile,
    Int8WeightTile w_tile) {
  // Accum tile is indexed as accum[m][n4][n4i]
  //   -> gives integer accumulator for output tile element at (x = n, y = m)
  // Input tile is indexed as in_tile.data[m4][k4][m4i]
  //   -> gives packed integer containing the 4x 8-bit quantized values at index
  //      (k, m), (k + 1, m), (k + 2, m), (k + 3, m)
  // Weight tile is indexed as w_tile.data[k4][n4][n4i]
  //   -> gives packed integer containing the 4x 8-bit quantized values at index
  //      (n, k), (n, k + 1), (n, k + 2), (n, k + 3)
#if TILE_M4 == 1 && TILE_K4 == 1 && TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    // n = 0
    accum.data[m][0][0] = dotPacked4x8AccSatEXT(
        in_tile.data[0][0][m], w_tile.data[0][0][0], accum.data[m][0][0]);
    // n = 1
    accum.data[m][0][1] = dotPacked4x8AccSatEXT(
        in_tile.data[0][0][m], w_tile.data[0][0][1], accum.data[m][0][1]);
    // n = 2
    accum.data[m][0][2] = dotPacked4x8AccSatEXT(
        in_tile.data[0][0][m], w_tile.data[0][0][2], accum.data[m][0][2]);
    // n = 3
    accum.data[m][0][3] = dotPacked4x8AccSatEXT(
        in_tile.data[0][0][m], w_tile.data[0][0][3], accum.data[m][0][3]);
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    const int m4 = div_4(m);
    const int m4i = mod_4(m);
    [[unroll]] for (int n = 0; n < TILE_N; ++n) {
      const int n4 = div_4(n);
      const int n4i = mod_4(n);
      [[unroll]] for (int k4 = 0; k4 < TILE_K4; ++k4) {
        accum.data[m][n4][n4i] = dotPacked4x8AccSatEXT(
            in_tile.data[m4][k4][m4i],
            w_tile.data[k4][n4][n4i],
            accum.data[m][n4][n4i]);
      }
    }
  }

#endif
}

/*
 * Computes final weight matrix output tile using:
 * - int8 accumulator tile
 * - per output channel weight sums
 * - per output channel scales
 */
void accumulate_out_tile_with_int_accum(
    inout FPOutTile out_tile,
    const Int32Accum accum,
    const float input_q_scale,
    const int input_q_zp,
    const IntPerOutChannelParams weight_sums,
    const FPPerOutChannelParams weight_scales) {
  ivec4 input_zp_vec = ivec4(-input_q_zp);
#if TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    // Unfortunately fma doesn't work with ivec4. Prefer to preserve integer
    // format for as long as possible to avoid precision loss.
    ivec4 accum_adjusted =
        input_zp_vec * weight_sums.data[0] + accum.data[m][0];
    out_tile.data[m][0] =
        fma(VEC4_T(accum_adjusted),
            input_q_scale * weight_scales.data[0],
            out_tile.data[m][0]);
  }

#else
  // TODO(ssjia): Implement the general case
  not implemented

#endif
}

void accumulate_out_tile_with_int_accum(
    inout FPOutTile out_tile,
    const Int32Accum accum,
    const float input_q_scale,
    const int input_q_zp,
    const IntPerOutChannelParams weight_sums,
    const FPPerOutChannelParams weight_scales,
    const FPPerOutChannelParams bias) {
  ivec4 input_zp_vec = ivec4(-input_q_zp);
#if TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    // Apply scale and zero points to the int accumulator
    ivec4 accum_adjusted =
        input_zp_vec * weight_sums.data[0] + accum.data[m][0];
    out_tile.data[m][0] =
        fma(VEC4_T(accum_adjusted),
            input_q_scale * weight_scales.data[0],
            out_tile.data[m][0]);
    out_tile.data[m][0] += bias.data[0];
  }

#else
  // TODO(ssjia): Implement the general case
  not implemented

#endif
}

#ifdef DEBUG_MODE

void printInt32Accum(const Int32Accum tile) {
  debugPrintfEXT("int accum: \\n");
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      debugPrintfEXT(
          "  %d, %d, %d, %d,",
          tile.data[m][n4].x,
          tile.data[m][n4].y,
          tile.data[m][n4].z,
          tile.data[m][n4].w);
    }
    debugPrintfEXT("\\n");
  }
}

#endif

#endif // LINEAR_FP_OUTPUT_TILE_INT8_INT8_COMPUTE_GLSLH
