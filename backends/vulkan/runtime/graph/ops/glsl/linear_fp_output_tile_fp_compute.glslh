/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to compute a FPOutTile using fp input and weight tiles.
 */

#ifndef LINEAR_FP_OUTPUT_TILE_FP_COMPUTE_GLSLH
#define LINEAR_FP_OUTPUT_TILE_FP_COMPUTE_GLSLH

#extension GL_EXT_control_flow_attributes : require

#include "linear_common.glslh"
#include "linear_fp_input_tile.glslh"
#include "linear_fp_output_tile.glslh"
#include "linear_fp_per_out_channel_params.glslh"
#include "linear_fp_weight_tile.glslh"

/*
 * Accumulates floating point input tile and floating point weight tile into
 * floating point output tile.
 */
void fp_accumulate_with_fp_weight(
    inout FPOutTile accum,
    FPInputTile in_tile,
    FPWeightTile w_tile) {
#if TILE_N4 == 1 && TILE_K4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    accum.data[m][0] =
        fma(VEC4_T(in_tile.data[m][0][0]),
            w_tile.data[mul_4(0)][0],
            accum.data[m][0]);

    accum.data[m][0] =
        fma(VEC4_T(in_tile.data[m][0][1]),
            w_tile.data[mul_4(0) + 1][0],
            accum.data[m][0]);

    accum.data[m][0] =
        fma(VEC4_T(in_tile.data[m][0][2]),
            w_tile.data[mul_4(0) + 2][0],
            accum.data[m][0]);

    accum.data[m][0] =
        fma(VEC4_T(in_tile.data[m][0][3]),
            w_tile.data[mul_4(0) + 3][0],
            accum.data[m][0]);
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      const int n = mul_4(n4);
      [[unroll]] for (int k4 = 0; k4 < TILE_K4; ++k4) {
        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][0]),
                w_tile.data[mul_4(k4)][n4],
                accum.data[m][n4]);

        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][1]),
                w_tile.data[mul_4(k4) + 1][n4],
                accum.data[m][n4]);

        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][2]),
                w_tile.data[mul_4(k4) + 2][n4],
                accum.data[m][n4]);

        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][3]),
                w_tile.data[mul_4(k4) + 3][n4],
                accum.data[m][n4]);
      }
    }
  }

#endif
}

/*
 * Applies per output channel weight scales to the output tile.
 */
void apply_scales(inout FPOutTile tile, const FPPerOutChannelParams scales) {
#if TILE_M > 1 && TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    tile.data[m][0] = tile.data[m][0] * scales.data[0];
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      tile.data[m][n4] = tile.data[m][n4] * scales.data[n4];
    }
  }
#endif
}

/*
 * Applies per output channel weight scales and per output channel biases to the
 * output tile.
 */
void apply_scales_and_biases(
    inout FPOutTile tile,
    const FPPerOutChannelParams scales,
    const FPPerOutChannelParams bias) {
#if TILE_M > 1 && TILE_N4 == 1
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    tile.data[m][0] = tile.data[m][0] * scales.data[0] + bias.data[0];
  }

#else
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      tile.data[m][n4] = tile.data[m][n4] * scales.data[n4] + bias.data[n4];
    }
  }
#endif
}

#endif // LINEAR_FP_OUTPUT_TILE_FP_COMPUTE_GLSLH
