/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to compute a FPOutTile using fp input and weight tiles.
 */

#ifndef LINEAR_FP_OUTPUT_TILE_FP_COMPUTE_GLSLH
#define LINEAR_FP_OUTPUT_TILE_FP_COMPUTE_GLSLH

#extension GL_EXT_control_flow_attributes : require

#include "linear_common.glslh"
#include "linear_fp_input_tile.glslh"
#include "linear_fp_output_tile.glslh"
#include "linear_fp_per_out_channel_params.glslh"
#include "linear_fp_weight_tile.glslh"

void fp_accumulate_with_fp_weight(
    inout FPOutTile accum,
    FPInputTile in_tile,
    FPWeightTile w_tile) {
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      [[unroll]] for (int k4 = 0; k4 < TILE_K4; ++k4) {
        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][0]),
                w_tile.data[mul_4(k4)][n4],
                accum.data[m][n4]);

        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][1]),
                w_tile.data[mul_4(k4) + 1][n4],
                accum.data[m][n4]);

        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][2]),
                w_tile.data[mul_4(k4) + 2][n4],
                accum.data[m][n4]);

        accum.data[m][n4] =
            fma(VEC4_T(in_tile.data[m][k4][3]),
                w_tile.data[mul_4(k4) + 3][n4],
                accum.data[m][n4]);
      }
    }
  }
}

void apply_weight_scales(
    inout FPOutTile tile,
    const FPPerOutChannelParams scales) {
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      tile.data[m][n4] = tile.data[m][n4] * scales.data[n4];
    }
  }
}

void apply_weight_scales_and_biases(
    inout FPOutTile tile,
    const FPPerOutChannelParams scales,
    const FPPerOutChannelParams bias) {
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      tile.data[m][n4] = tile.data[m][n4] * scales.data[n4] + bias.data[n4];
    }
  }
}

void accumulate_out_tile_with_out_tile(
    inout FPOutTile accum,
    const FPOutTile other) {
  [[unroll]] for (int m = 0; m < TILE_M; ++m) {
    [[unroll]] for (int n4 = 0; n4 < TILE_N4; ++n4) {
      accum.data[m][n4] = accum.data[m][n4] + other.data[m][n4];
    }
  }
}

#endif // LINEAR_FP_OUTPUT_TILE_FP_COMPUTE_GLSLH
