/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 * Defines functions to compute a FPOutTile using fp input and weight tiles.
 */

#ifndef LINEAR_FP_OUTPUT_TILE_FP_INT4_COMPUTE_GLSLH
#define LINEAR_FP_OUTPUT_TILE_FP_INT4_COMPUTE_GLSLH

#extension GL_EXT_control_flow_attributes : require

#include "linear_common.glslh"
#include "linear_fp_input_tile.glslh"
#include "linear_fp_output_tile.glslh"
#include "linear_fp_per_out_channel_params.glslh"
#include "linear_int4_weight_tile.glslh"

// Unpacks a int containing 4 packed 8-bit integers into a vec4 containing each
// of the 4 unpacked 8-bit integers.
VEC4_T unpack_packed_4xint4(const int int8x4, const int n4_group) {
  return VEC4_T(
      extract_4bit_from_packed_int_le(int8x4, n4_group + 0),
      extract_4bit_from_packed_int_le(int8x4, n4_group + 2),
      extract_4bit_from_packed_int_le(int8x4, n4_group + 4),
      extract_4bit_from_packed_int_le(int8x4, n4_group + 6));
}

T extract_4bit_from_weight_block(
    const ivec4 block,
    const int col,
    const int row) {
  return T(((block[row] >> (4 * col)) & 0xF) - 8);
}

void fp_accumulate_with_int4_weight(
    inout FPOutTile accum,
    FPInputTile in_tile,
    Int4WeightTile w_tile,
    FPPerOutChannelParams scales_tile,
    FPPerOutChannelParams zeros_tile) {
  // Accum tile is indexed as accum[m][n4][n4i]
  // -> gives fp accumulator for output tile element at (x = n, y = m)
  // Input tile is indexed as in_tile.data[m][k4]
  // -> gives vec4 containing the fp inputs at index
  //    (k, m), (k + 1, m), (k + 2, m), (k + 3, m)
  // Weight tile is indexed as w_tile.data[k4][n8][n4i]
  // -> gives packed integer containing the 8x 4-bit quantized values at index
  //    (n, k), (n, k + 1), (n, k + 2), (n, k + 3),
  //    (n + 4, k), (n + 4, k + 1), (n + 4, k + 2), (n + 4, k + 3)
  VEC4_T weight_texels[2];
#if TILE_K4 == 1 && TILE_N8 == 1
  [[unroll]] for (int k = 0; k < 4; ++k) {
    const int base_col_1 = mul_2(k);
    const int base_col_2 = base_col_1 + 1;
    weight_texels[0] = VEC4_T(
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_1, 0),
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_1, 1),
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_1, 2),
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_1, 3));
    weight_texels[1] = VEC4_T(
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_2, 0),
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_2, 1),
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_2, 2),
        extract_4bit_from_weight_block(w_tile.data[0][0], base_col_2, 3));

    weight_texels[0] =
        fma(weight_texels[0], scales_tile.data[0], zeros_tile.data[0]);
    weight_texels[1] =
        fma(weight_texels[1], scales_tile.data[1], zeros_tile.data[1]);

    [[unroll]] for (int m = 0; m < TILE_M; ++m) {
      accum.data[m][0] = fma(
          VEC4_T(in_tile.data[m][0][k]), weight_texels[0], accum.data[m][0]);
      accum.data[m][1] = fma(
          VEC4_T(in_tile.data[m][0][k]), weight_texels[1], accum.data[m][1]);
    }
  }

#else
  // TODO(ssjia): Implement generic case
  not implemented

#endif
}

#endif // LINEAR_FP_OUTPUT_TILE_FP_INT4_COMPUTE_GLSLH
